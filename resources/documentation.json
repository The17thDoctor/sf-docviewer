{
  "hooks": {
    "1": "CheckTricorderOverride",
    "2": "EntityTakeDamage",
    "3": "PostEntityPaste",
    "4": "PreEntityCopy",
    "5": "TricorderOverride",
    "6": "calcview",
    "7": "chatboxclosed",
    "8": "chatboxopened",
    "9": "chattextchanged",
    "10": "dtvarchanged",
    "11": "entityremoved",
    "12": "hudlink",
    "13": "hudshoulddraw",
    "14": "hudunlink",
    "15": "input",
    "16": "inputmouseapply",
    "17": "keypress",
    "18": "keyrelease",
    "19": "net",
    "20": "networkentitycreated",
    "21": "notifyshouldtransmit",
    "22": "onentitycreated",
    "23": "onremove",
    "24": "onscreensizechanged",
    "25": "permissiongranted",
    "26": "permissionrevoked",
    "27": "playerauthed",
    "28": "playerbindpress",
    "29": "playerbuttondown",
    "30": "playerbuttonup",
    "31": "playerdeath",
    "32": "playerdisconnected",
    "33": "playerinitialspawn",
    "34": "playerspawn",
    "35": "playeruse",
    "36": "readcell",
    "37": "render",
    "38": "starfall_used",
    "39": "think",
    "40": "tick",
    "41": "writecell",
    "render": {
      "client": true,
      "description": "Called when a frame is requested to be drawn. You may want to unhook from this if you don't need \nto render anything for a bit"
    },
    "keyrelease": {
      "description": "Called when a player releases an input button.",
      "param": {
        "1": "ply",
        "2": "key",
        "key": "The IN_ button.",
        "ply": "The player releasing the button."
      }
    },
    "calcview": {
      "client": true,
      "description": "Called on a HUD when you are linked to it. Return a table with origin, angles and fov fields to change your camera view.",
      "param": {
        "1": "player",
        "2": "origin",
        "3": "angles",
        "4": "fov",
        "fov": "The default field of view of the camera.",
        "angles": "The default angles of the camera.",
        "origin": "The default location of the camera.",
        "player": "The local player."
      }
    },
    "playerinitialspawn": {
      "description": "Called when a player spawns for the first time.",
      "server": true,
      "param": {
        "1": "ply",
        "ply": "The player that has spawned for the first time."
      }
    },
    "playerdisconnected": {
      "description": "Called when a player disconnects.",
      "server": true,
      "param": {
        "1": "ply",
        "ply": "The player that left."
      }
    },
    "hudlink": {
      "description": "Called when a player links to your HUD (clientside only).",
      "client": true,
      "param": {
        "1": "player",
        "player": "The player linking."
      }
    },
    "notifyshouldtransmit": {
      "description": "Called when an entity enters or leaves the local player's PVS.",
      "client": true,
      "param": {
        "1": "entity",
        "2": "shouldTransmit",
        "shouldTransmit": "Whether the entity is transmitting or not.",
        "entity": "The entity whose transmission state has changed."
      }
    },
    "playerbuttondown": {
      "description": "Called when a player presses down any button.",
      "param": {
        "1": "ply",
        "2": "key",
        "key": "The KEY_ or MOUSE_ button.",
        "ply": "The player pressing the button."
      }
    },
    "dtvarchanged": {
      "description": "Called when a DTVar value is changed (if change detection was enabled by net.listenForDTVarChanges() or net.listenForAllDTVarChanges()).",
      "client": true,
      "param": {
        "1": "type",
        "2": "index",
        "3": "oldValue",
        "4": "newValue",
        "newValue": "The new value for the DTVar.",
        "oldValue": "The previous value for the DTVar.",
        "index": "The index under the given type of the DTVar that has changed.",
        "type": "The type of DTVar that has changed."
      }
    },
    "EntityTakeDamage": {
      "description": "Called when an entity takes damage through the server's damage system.",
      "param": {
        "1": "ent",
        "2": "inflictor",
        "3": "attacker",
        "4": "amount",
        "amount": "The amount of damage taken.",
        "attacker": "The owner of the weapon that caused the damage.",
        "inflictor": "The weapon that caused the damage.",
        "ent": "The entity that took damage."
      },
      "server": true
    },
    "permissiongranted": {
      "description": "Runs when a permission has been granted to this instance.",
      "param": {
        "1": "permission",
        "permission": "The permission that has been granted."
      }
    },
    "net": {
      "description": "Called when a network message is received.",
      "param": {
        "1": "length",
        "2": "player",
        "player": "The player that sent the network message (only on the server side).",
        "length": "The length of the network message in bits."
      }
    },
    "TricorderOverride": {
      "description": "Called when a player successfully uses their tricorder/scanner on the Starfall entity with this hook.",
      "param": {
        "1": "ply",
        "2": "tricorder",
        "tricorder": "The tricorder/scanner being used to override.",
        "ply": "The player that was successful in using their tricorder/scanner on your entity."
      },
      "server": true
    },
    "playerbuttonup": {
      "description": "Called when a player releases any button.",
      "param": {
        "1": "ply",
        "2": "key",
        "key": "The KEY_ or MOUSE_ button.",
        "ply": "The player releasing the button."
      }
    },
    "playerspawn": {
      "description": "Called when a player spawns.",
      "server": true,
      "param": {
        "1": "ply",
        "ply": "The player that has spawned."
      }
    },
    "networkentitycreated": {
      "description": "Called when a networked entity has been created.",
      "client": true,
      "param": {
        "1": "entity",
        "entity": "The entity that has been created."
      }
    },
    "chatboxclosed": {
      "client": true,
      "description": "Called on a HUD when you are linked to it and the chatbox has been closed. \nThis requires the READ_CHATBOX_STATE permission."
    },
    "playerauthed": {
      "description": "Called when a player's Steam ID has been confirmed.",
      "server": true,
      "param": {
        "1": "ply",
        "2": "steamID",
        "3": "uniqueID",
        "uniqueID": "Don't use it, it's not really unique thanks to Garry.",
        "steamID": "Their Steam ID.",
        "ply": "The player that has been authed."
      }
    },
    "PostEntityPaste": {
      "description": "Called when the chip has been restored.",
      "param": {
        "1": "data",
        "2": "createdEntities",
        "createdEntities": "A table keyed by entity index (at the point of saving), where each entity corresponds to an entity in the dupe.",
        "data": "The table of data you saved with PreEntityCopy."
      },
      "server": true
    },
    "writecell": {
      "description": "Called when a high speed device writes to a wired SF chip",
      "server": true,
      "param": {
        "1": "address",
        "2": "data",
        "data": "The data being written",
        "address": "The address written to"
      }
    },
    "keypress": {
      "description": "Called when a player presses an input button.",
      "param": {
        "1": "ply",
        "2": "key",
        "key": "The IN_ button.",
        "ply": "The player pressing the button."
      }
    },
    "readcell": {
      "ret": "The value read",
      "description": "Called when a high speed device reads from a wired SF chip",
      "server": true,
      "param": {
        "1": "address",
        "address": "The address requested"
      }
    },
    "tick": {
      "description": "Called once per game tick on both the client and the server.",
      "server": true,
      "client": true
    },
    "hudshoulddraw": {
      "client": true,
      "description": "Called on a HUD when you are linked to it. \nReturn a value to deny the given HUD element from drawing. \nSee: https://wiki.facepunch.com/gmod/HUD_Element_List \nIn addition to the above, the following extra elements are defined: \n* LuaHudHealth \n* LuaHudAmmo \n* LuaHudDeathNotice",
      "param": {
        "1": "element",
        "element": "The string name of the HUD element requesting permission to draw."
      }
    },
    "PreEntityCopy": {
      "description": "Called when the chip is being copied. \nNote: don't try to store anything other than basic numbers, booleans and strings. To store an entity, store its entity index, then use the created entities lookup in PostEntityPaste using the saved index.",
      "param": {
        "1": "data",
        "data": "Add values to this table to be saved."
      },
      "server": true
    },
    "entityremoved": {
      "description": "Called when an entity is removed.",
      "param": {
        "1": "ent",
        "ent": "The entity removed."
      }
    },
    "chatboxopened": {
      "client": true,
      "description": "Called on a HUD when you are linked to it and the chatbox has been opened. \nThis requires the READ_CHATBOX_STATE permission.",
      "param": {
        "1": "mode",
        "mode": "The mode the chatbox was opened with."
      }
    },
    "permissionrevoked": {
      "description": "Runs when a permission has been revoked from this instance.",
      "param": {
        "1": "permission",
        "permission": "The permission that has been revoked."
      }
    },
    "playerbindpress": {
      "description": "Called when a player runs a command. Return true to block the command (only works for the chip's owner).",
      "client": true,
      "param": {
        "1": "ply",
        "2": "bind",
        "3": "pressed",
        "pressed": "Boolean value whether the bind was activated or deactivated.",
        "bind": "The command run, e.g \"+attack\"",
        "ply": "The player using the command (the local player)."
      }
    },
    "chattextchanged": {
      "client": true,
      "description": "Called on a HUD when you are linked to it and the text in the chatbox input has changed. \nThis requires the READ_CHATBOX_STATE permission.",
      "param": {
        "1": "text",
        "text": "The contents of the chatbox input."
      }
    },
    "onscreensizechanged": {
      "description": "Called when the game's screen resolution has changed. \nCalling render.getScreenRes() will return the new size.",
      "client": true,
      "param": {
        "1": "oldWidth",
        "2": "oldHeight",
        "oldHeight": "The old screen height in pixels.",
        "oldWidth": "The old screen width in pixels."
      }
    },
    "CheckTricorderOverride": {
      "ret": "True if they should be allowed to use it, false otherwise.",
      "description": "Called when a player is attempting to use their tricorder/scanner on the Starfall entity with this hook.",
      "param": {
        "1": "ply",
        "2": "tricorder",
        "tricorder": "The tricorder/scanner being used to override.",
        "ply": "The player attempting to use their tricorder/scanner."
      },
      "server": true
    },
    "onremove": {
      "description": "Called when the chip is being removed or updated with new code.",
      "param": {
        "1": "reason",
        "reason": "The reason for the instance shutdown (one of \"UPDATING\", \"RESTARTING\", \"TERMINATING\" or \"REMOVING\")."
      }
    },
    "playeruse": {
      "description": "Called when a player uses an entity.",
      "server": true,
      "param": {
        "1": "ply",
        "2": "ent",
        "ent": "The entity that is being used.",
        "ply": "The player that pressed their use key."
      }
    },
    "playerdeath": {
      "description": "Called when a player dies.",
      "server": true,
      "param": {
        "1": "victim",
        "2": "inflictor",
        "3": "attacker",
        "victim": "The player that died.",
        "attacker": "The player that killed them.",
        "inflictor": "The entity that caused the death."
      }
    },
    "think": {
      "description": "Called once per game tick on the server and once per frame on the client.",
      "server": true,
      "client": true
    },
    "inputmouseapply": {
      "description": "Called when mouse input is applied to the local player's view.",
      "client": true,
      "param": {
        "1": "x",
        "2": "y",
        "3": "viewAngles",
        "x": "The amount of mouse movement along the x-axis this frame.",
        "viewAngles": "The view angles of the local player.",
        "y": "The amount of mouse movement along the y-axis this frame."
      }
    },
    "input": {
      "description": "Called when an input on a wired SF chip is written to",
      "server": true,
      "param": {
        "1": "input",
        "2": "value",
        "input": "The input name",
        "value": "The value of the input"
      }
    },
    "starfall_used": {
      "description": "Called when a player presses use on the screen entity this instance is running on.",
      "param": {
        "1": "activator",
        "2": "repeaterEntity",
        "repeaterEntity": "The repater screen entity that use was pressed on, if it was not pressed on the original screen.",
        "activator": "The player that pressed use on the screen."
      }
    },
    "onentitycreated": {
      "description": "Called when an entity is created.",
      "param": {
        "1": "ent",
        "ent": "The entity created."
      }
    },
    "hudunlink": {
      "description": "Called when a player unlinks from your HUD (clientside only).",
      "client": true,
      "param": {
        "1": "player",
        "player": "The player being unlinked."
      }
    }
  },
  "libraries": {
    "1": "Color",
    "2": "base64",
    "3": "bit",
    "4": "builtin",
    "5": "channels",
    "6": "chat",
    "7": "console",
    "8": "constraint",
    "9": "coroutine",
    "10": "debug",
    "11": "effects",
    "12": "emitter",
    "13": "emoji",
    "14": "ents",
    "15": "faction",
    "16": "fastlz",
    "17": "files",
    "18": "find",
    "19": "globaltables",
    "20": "holograms",
    "21": "hook",
    "22": "http",
    "23": "hud",
    "24": "input",
    "25": "io",
    "26": "json",
    "27": "math",
    "28": "mesh",
    "29": "net",
    "30": "npc",
    "31": "os",
    "32": "permissions",
    "33": "profiler",
    "34": "propprotection",
    "35": "props",
    "36": "quaternion",
    "37": "render",
    "38": "rendertarget",
    "39": "serverinfo",
    "40": "sounds",
    "41": "spacebuild",
    "42": "starfall",
    "43": "stargate",
    "44": "string",
    "45": "system",
    "46": "table",
    "47": "time",
    "48": "timer",
    "49": "trace",
    "50": "utf8",
    "51": "util",
    "52": "vgui",
    "53": "von",
    "54": "wire",
    "render": {
      "functions": {
        "1": "capturePixels",
        "2": "clear",
        "3": "clearBuffersObeyStencil",
        "4": "clearDepth",
        "5": "computeTextureCoords",
        "6": "createClientModel",
        "7": "createFont",
        "8": "cursorPos",
        "9": "cutOutStencil",
        "10": "disableScissorRect",
        "11": "drawBeam",
        "12": "drawBox",
        "13": "drawCircle",
        "14": "drawFilledCircle",
        "15": "drawLine",
        "16": "drawLine3D",
        "17": "drawPoly",
        "18": "drawQuad",
        "19": "drawRawText",
        "20": "drawRect",
        "21": "drawRectOutline",
        "22": "drawRoundedRect",
        "23": "drawSphere",
        "24": "drawSprite",
        "25": "drawStencil",
        "26": "drawText",
        "27": "drawTextRotated",
        "28": "drawTexturedRect",
        "29": "drawTexturedRectRotated",
        "30": "drawTexturedRectUV",
        "31": "drawWireframeBox",
        "32": "drawWireframeSphere",
        "33": "enableAlpha",
        "34": "enableClipping",
        "35": "enableColor",
        "36": "enableDepth",
        "37": "enableScissorRect",
        "38": "end3D",
        "39": "end3D2D",
        "40": "endStencil",
        "41": "frameNumber",
        "42": "getBlend",
        "43": "getClientModelCount",
        "44": "getClientModels",
        "45": "getColorModulation",
        "46": "getConfiguredScreenRes",
        "47": "getIsHighRes",
        "48": "getIsWidescreen",
        "49": "getMaxClientModels",
        "50": "getScreenInfo",
        "51": "getScreenPos",
        "52": "getScreenRes",
        "53": "getTextSize",
        "54": "getTextureID",
        "55": "ignoreZ",
        "56": "isEmitter",
        "57": "isHUD",
        "58": "isStencilEnabled",
        "59": "overrideBlend",
        "60": "overrideDepthEnable",
        "61": "popCustomClipPlane",
        "62": "popFilterMag",
        "63": "popFilterMin",
        "64": "popMatrix",
        "65": "pushCustomClipPlane",
        "66": "pushFilterMag",
        "67": "pushFilterMin",
        "68": "pushMatrix",
        "69": "readPixel",
        "70": "resetModelLighting",
        "71": "setAlphaMultiplier",
        "72": "setBlend",
        "73": "setColor",
        "74": "setColorModulation",
        "75": "setFont",
        "76": "setLightingMode",
        "77": "setLightingOrigin",
        "78": "setLocalModelLights",
        "79": "setMaterial",
        "80": "setMaterialOverride",
        "81": "setModelLighting",
        "82": "setTextPos",
        "83": "setTexture",
        "84": "start3D",
        "85": "start3D2D",
        "86": "startStencil",
        "87": "suppressEngineLighting",
        "88": "toScreen",
        "89": "vertex",
        "drawTexturedRectUV": {
          "client": true,
          "description": "Draws a textured rectangle with UV co-ordinates",
          "param": {
            "1": "x",
            "2": "y",
            "3": "w",
            "4": "h",
            "5": "startU",
            "6": "startV",
            "7": "endU",
            "8": "endV",
            "w": "Width",
            "y": "Y co-ordinate",
            "x": "X co-ordinate",
            "endV": "Ending V co-ordinate.",
            "endU": "Ending U co-ordinate.",
            "startV": "Starting V co-ordinate.",
            "startU": "Starting U co-ordinate.",
            "h": "Height"
          }
        },
        "drawTexturedRect": {
          "client": true,
          "description": "Draws a textured rectangle.",
          "param": {
            "1": "x",
            "2": "y",
            "3": "w",
            "4": "h",
            "y": "Y co-ordinate",
            "x": "X co-ordinate",
            "w": "Width",
            "h": "Height"
          }
        },
        "getMaxClientModels": {
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the maximum number of clientside models you can use."
        },
        "drawLine3D": {
          "client": true,
          "description": "Draws a line in 3D space.",
          "param": {
            "1": "start",
            "2": "end",
            "3": "color",
            "4": "writeZ",
            "writeZ": "Sets whether the line should write to the depth buffer.",
            "color": "The colour of the line.",
            "end": "The ending position of the line.",
            "start": "The starting position of the line."
          }
        },
        "pushMatrix": {
          "client": true,
          "description": "Pushes a matrix onto the matrix stack, pre-multiplying by the previously pushed matrix if present. \nNote that 3D2D cameras have their own separate matrix stack, thus attempting to pop a matrix \npushed before starting a 3D2D camera will result in an error, and any matrices not popped at the \nend of a 3D2D camera will be popped automatically.",
          "param": {
            "1": "mat",
            "mat": "The matrix"
          }
        },
        "pushFilterMag": {
          "client": true,
          "description": "Pushes a mag texture filter onto the texture filter stack."
        },
        "drawWireframeSphere": {
          "client": true,
          "description": "Draws a wireframe sphere in 3D space.",
          "param": {
            "1": "pos",
            "2": "radius",
            "3": "longitudeSteps",
            "4": "latitudeSteps",
            "5": "color",
            "radius": "The radius of the sphere.",
            "color": "The colour of the sphere.",
            "latitudeSteps": "The amount of latitude steps (controls how smooth the sphere is).",
            "longitudeSteps": "The amount of longitude steps (controls how smooth the sphere is).",
            "pos": "The position of the sphere."
          }
        },
        "drawStencil": {
          "client": true,
          "description": "Call this after render.startStencil() to switch to drawing what you want to be contained."
        },
        "getClientModels": {
          "returntypes": [
            "table<number,ClientsideModel>"
          ],
          "client": true,
          "description": "Returns a table of all currently active client side models for your instance."
        },
        "clearBuffersObeyStencil": {
          "client": true,
          "description": "Clears the surface, obeying any stencil checks. \nOnly works on screens and inside render target drawing operations.",
          "param": {
            "1": "r",
            "2": "g",
            "3": "b",
            "4": "a",
            "5": "clearDepth",
            "a": "Alpha value to clear to.",
            "r": "Red value to clear to.",
            "clearDepth": "Whether to clear the depth buffer.",
            "g": "Green value to clear to.",
            "b": "Blue value to clear to."
          }
        },
        "setBlend": {
          "client": true,
          "description": "Sets the alpha value to draw any models with following this point (only works in 3D cameras).",
          "param": {
            "1": "a",
            "a": "Alpha value between 0 and 1."
          }
        },
        "setTexture": {
          "client": true,
          "description": "Sets the texture for upcoming (2D) rendering.",
          "param": {
            "1": "texture",
            "texture": "Either a texture ID, an IMaterial, or nil to reset the texture."
          }
        },
        "drawTexturedRectRotated": {
          "client": true,
          "description": "Draws a rotated, textured rectangle.",
          "param": {
            "1": "x",
            "2": "y",
            "3": "w",
            "4": "h",
            "5": "rot",
            "y": "Y co-ordinate of center of rect",
            "h": "Height",
            "rot": "Rotation in degrees",
            "w": "Width",
            "x": "X co-ordinate of center of rect"
          }
        },
        "getIsHighRes": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the screen is running in high res mode."
        },
        "vertex": {
          "ret": "{ x = x or 0, y = y or 0, u = u or 0, v = v or 0 }",
          "deprecated": "This is literally creating a table. You don't need to use it.",
          "returntypes": [
            "Vertex"
          ],
          "client": true,
          "description": "Creates a vertex for use with polygons. This just creates a table; it doesn't really do anything special",
          "param": [
            "x",
            "y",
            "u",
            "v"
          ]
        },
        "getIsWidescreen": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the screen is running in widescreen mode."
        },
        "getScreenRes": {
          "ret": [
            "Width of the current rendering context in pixels.",
            "Height of the current rendering context in pixels."
          ],
          "returntypes": [
            "number",
            "number"
          ],
          "client": true,
          "description": "Returns the screen resolution in the current rendering context. \nFor HUDs/emitters, this returns the local player's screen resolution. \nFor screens or inside render targets, when called during rendering this returns the size of the render target. \nTo get the configured resolution of a Starfall screen, use render.getConfiguredScreenRes()."
        },
        "getBlend": {
          "ret": "Alpha value between 0 and 1.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the current blend."
        },
        "drawBox": {
          "client": true,
          "description": "Draws a rotated box in 3D space.",
          "param": {
            "1": "pos",
            "2": "ang",
            "3": "mins",
            "4": "maxs",
            "5": "color",
            "6": "writeZ",
            "writeZ": "Sets whether the box should write to the depth buffer.",
            "color": "The colour of the box.",
            "maxs": "The maxs vector for the box.",
            "mins": "The mins vector for the box.",
            "ang": "The angles of the box.",
            "pos": "The position of the box."
          }
        },
        "drawRect": {
          "client": true,
          "description": "Draws a rectangle using the current color.",
          "param": {
            "1": "x",
            "2": "y",
            "3": "w",
            "4": "h",
            "y": "Top left corner y co-ordinate",
            "x": "Top left corner x co-ordinate",
            "w": "Width",
            "h": "Height"
          }
        },
        "setModelLighting": {
          "client": true,
          "description": "Sets model lighting from one of 6 directions (see the BOX_ enums, only works in 3D cameras.)",
          "param": {
            "1": "index",
            "2": "r",
            "3": "g",
            "4": "b",
            "index": "Which direction light to set (BOX_ enums)."
          }
        },
        "start3D": {
          "client": true,
          "description": "Starts a 3D camera context. Used to render 3D models on a 2D surface. \nCalling with no arguments will replicate the current player's view.",
          "param": {
            "1": "pos",
            "2": "ang",
            "3": "fov",
            "4": "x",
            "5": "y",
            "6": "w",
            "7": "h",
            "8": "nearZ",
            "9": "farZ",
            "farZ": "The distance from the camera to start the far clipping plane.",
            "nearZ": "The distance from the camera to start the near clipping plane.",
            "h": "The height to take up on the 2D surface.",
            "w": "The width to take up on the 2D surface.",
            "y": "The Y position on the 2D surface to draw the 3D world.",
            "x": "The X position on the 2D surface to draw the 3D world.",
            "ang": "The angles of the camera.",
            "fov": "The field of view of the camera.",
            "pos": "The position in the new 3D world to position the camera."
          }
        },
        "enableScissorRect": {
          "client": true,
          "description": "Enables a scissor rect, which will prevent anything drawing outside the provided bounds.",
          "param": {
            "1": "x",
            "2": "y",
            "3": "endX",
            "4": "endY",
            "endY": "The y co-ordinate of the rect's bottom-right corner.",
            "endX": "The x co-ordinate of the rect's bottom-right corner.",
            "y": "The y co-ordinate of the rect's top-left corner.",
            "x": "The x co-ordinate of the rect's top-left corner."
          }
        },
        "popCustomClipPlane": {
          "client": true,
          "description": "Pops a clip plane from the clipping plane stack."
        },
        "clear": {
          "client": true,
          "description": "Clears the surface. Only works on screens and inside render target drawing operations.",
          "param": {
            "1": "r",
            "2": "g",
            "3": "b",
            "4": "a",
            "5": "clearDepth",
            "6": "clearStencil",
            "a": "Alpha value to clear to.",
            "clearStencil": "Whether to clear the stencil buffer.",
            "r": "Red value to clear to.",
            "clearDepth": "Whether to clear the depth buffer.",
            "g": "Green value to clear to.",
            "b": "Blue value to clear to."
          }
        },
        "toScreen": {
          "deprecated": "Use Vector:ToScreen() to get the same result.",
          "returntypes": [
            "ToScreenData"
          ],
          "client": true,
          "description": "Returns the location on the screen of a world space position as a table with x, y and boolean visible values. \nThis only works on HUDs.",
          "param": {
            "1": "pos",
            "pos": "World-space position vector you want to know the onscreen location of."
          }
        },
        "getTextureID": {
          "ret": "The ID of the texture, or nil if no such texture exists.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Looks up a texture ID by file name. \nWhen passed a PNG file path, the resulting material is equivalent to Material( texture, \"noclamp\" ). \nFor other materials, the returned ID will correspond to material that can be used in a 2D rendering context using \nthe \"UnlitGeneric\" shader.",
          "param": {
            "1": "texture",
            "texture": "Texture file path"
          }
        },
        "endStencil": {
          "client": true,
          "description": "Ends the stencil operation. Call this after drawStencil() to stop restricting drawing operations."
        },
        "createClientModel": {
          "returntypes": [
            "ClientsideModel"
          ],
          "client": true,
          "description": "Creates an invisible client side model. Call Model:drawModel() to draw it in a 3D camera.",
          "param": {
            "1": "model",
            "2": "renderGroup",
            "renderGroup": "One of the render.RENDERGROUP_* enums.",
            "model": "The model path to use."
          }
        },
        "popMatrix": {
          "client": true,
          "description": "Pops a matrix from the current matrix stack. \nNote that 3D2D cameras have their own separate matrix stack, thus attempting to pop a matrix \npushed before starting a 3D2D camera will result in an error, and any matrices not popped at the \nend of a 3D2D camera will be popped automatically."
        },
        "frameNumber": {
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the current frame number."
        },
        "cursorPos": {
          "ret": "X, Y co-ordinates of their aim position on the screen.",
          "returntypes": [
            "number",
            "number"
          ],
          "client": true,
          "description": "Gets a 2D cursor position where ply is aiming.",
          "param": {
            "1": "ply",
            "2": "screen",
            "ply": "The player to get the cursor position of.",
            "screen": "(Optional) Screen entity to get the cursor position for."
          }
        },
        "end3D2D": {
          "client": true,
          "description": "Ends a 3D2D camera. You must do this in order to start a new one, and you should end every camera you start."
        },
        "getScreenPos": {
          "ret": [
            "The screen position",
            "The screen angle"
          ],
          "returntypes": [
            "Vector",
            "Angle"
          ],
          "client": true,
          "description": "Returns the screen surface's world position and angle"
        },
        "getConfiguredScreenRes": {
          "ret": [
            "The configured width of the screen in pixels.",
            "The configured height of the screen in pixels."
          ],
          "returntypes": [
            "number",
            "number"
          ],
          "client": true,
          "description": "Returns the configured size of the Starfall screen. \nUse render.getScreenRes() to get the resolution of the current rendering context."
        },
        "drawBeam": {
          "client": true,
          "description": "Draws a beam in 3D space.",
          "param": {
            "1": "start",
            "2": "end",
            "3": "width",
            "4": "texStart",
            "5": "texEnd",
            "6": "color",
            "color": "The colour of the beam.",
            "texEnd": "The ending texture co-ordinate (between 0 and 1).",
            "texStart": "The starting texture co-ordinate (between 0 and 1).",
            "width": "The width of the beam.",
            "end": "The ending position of the beam.",
            "start": "The starting position of the beam."
          }
        },
        "pushFilterMin": {
          "client": true,
          "description": "Pushes a min texture filter onto the texture filter stack."
        },
        "setAlphaMultiplier": {
          "client": true,
          "description": "Sets a global alpha multiplier on all upcoming 2D drawing operations.",
          "param": {
            "1": "mult",
            "mult": "Value between 0 and 1 to multiply alpha by."
          }
        },
        "overrideBlend": {
          "client": true,
          "description": "Enables/disables overriding the current blending function.",
          "param": {
            "1": "enable",
            "2": "sourceBlend",
            "3": "destBlend",
            "4": "blendFunc",
            "5": "sourceBlendAlpha",
            "6": "destBlendAlpha",
            "7": "blendFuncAlpha",
            "blendFuncAlpha": "The blending function to use for alpha (one of render.BLENDFUNC_*).",
            "destBlendAlpha": "The blending factor for the destination alpha value (one of render.BLEND_*).",
            "sourceBlendAlpha": "The blending factor for the source alpha value (one of render.BLEND_*).",
            "blendFunc": "The blending function to use for colour (one of render.BLENDFUNC_*).",
            "destBlend": "The blending factor for the destination colour values (one of render.BLEND_*).",
            "sourceBlend": "The blending factor for the source colour values (one of render.BLEND_*).",
            "enable": "Whether to enable the override."
          }
        },
        "enableAlpha": {
          "client": true,
          "description": "Sets whether to write alpha when rendering.",
          "param": {
            "1": "shouldWrite",
            "shouldWrite": "Whether to write to the alpha channel."
          }
        },
        "ignoreZ": {
          "client": true,
          "description": "Sets whether to ignore the depth buffer (only works in 3D cameras).",
          "param": {
            "1": "bool",
            "bool": "Ignore depth?"
          }
        },
        "getColorModulation": {
          "ret": "R, G, B values between 0 and 1.",
          "returntypes": [
            "number",
            "number",
            "number"
          ],
          "client": true,
          "description": "Returns the current colour modulation."
        },
        "disableScissorRect": {
          "client": true,
          "description": "Disables the current scissor rect, if one is enabled."
        },
        "overrideDepthEnable": {
          "usage": "-- Force depth writing to be enabled (must be done outside the 3D2D block). \nrender.overrideDepthEnable( true, true ) \n \n-- First render a red rectangle. \nrender.start3D2D( Pos, Ang, 0.1 ) \n    render.setColor( 255, 0, 0 ) \n    render.drawRect( 0, 0, 256, 256 ) \nrender.end3D2D() \n \n-- Then render a yellow rectange behind it, note how this rectangle is occluded. \n-- If you comment out the overrideDepthEnable above, this will draw over the top of the red rectangle. \nrender.start3D2D( Pos - Dir * 5, Ang, 0.1 ) \n    render.setColor( 255, 255, 0 ) \n    render.drawRect( 0, 0, 256, 256 ) \nrender.end3D2D() \n \n-- Stop overriding depth writing. \nrender.overrideDepthEnable( false )",
          "client": true,
          "description": "Allows overriding the default depth write behaviour. \nThis can be used to make opaque rendered elements in 3D2D properly occlude each other.",
          "param": {
            "1": "enableOverride",
            "2": "shouldWrite",
            "shouldWrite": "Whether depth writing should be enabled. Has no effect if the override is not enabled.",
            "enableOverride": "Whether to override depth writing behaviour."
          }
        },
        "enableDepth": {
          "client": true,
          "description": "Sets whether to write to the depth buffer. \nNote that \"enabling\" depth writing here defers to the current rendering context's depth writing mode, which may not \nactually be enabled.",
          "param": {
            "1": "shouldWrite",
            "shouldWrite": "Whether to write to the depth buffer."
          }
        },
        "drawWireframeBox": {
          "client": true,
          "description": "Draws a rotated wireframe box in 3D space.",
          "param": {
            "1": "pos",
            "2": "ang",
            "3": "mins",
            "4": "maxs",
            "5": "color",
            "6": "writeZ",
            "writeZ": "Sets whether the box should write to the depth buffer.",
            "color": "The colour of the box.",
            "maxs": "The maxs vector for the box.",
            "mins": "The mins vector for the box.",
            "ang": "The angles of the box.",
            "pos": "The position of the box."
          }
        },
        "enableColor": {
          "usage": "render.startStencil() \n-- Turn off writing colour values. \nrender.enableColor( false ) \n-- Render your bounds here \n-- Turn back on writing colour values. \nrender.enableColor( true ) \nrender.drawStencil() \n-- Draw things constrained to the stencil \nrender.endStencil()",
          "client": true,
          "description": "Sets whether to write colour values. \nUse this to render to the stencil/depth buffer without it being visible. \nNOTE: The engine does not render in 2D if the current colour's alpha is 0, even if colour writing is disabled. You must have a non-zero alpha value set to render to the stencil buffer.",
          "param": {
            "1": "shouldWrite",
            "shouldWrite": "Whether to write colour values or not."
          }
        },
        "cutOutStencil": {
          "client": true,
          "description": "Call this after render.startStencil() to switch to drawing what you want to have the stencil cut out of. \nThis is the opposite of render.drawStencil()."
        },
        "setMaterialOverride": {
          "client": true,
          "description": "Sets an override material for upcoming 3D space rendering operations. This can be used to override the material on clientside models.",
          "param": {
            "1": "mat",
            "mat": "The IMaterial or RenderTarget to use, or nil to set to the default material."
          }
        },
        "isStencilEnabled": {
          "ret": "True if a stencil is currently in use, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether a stencil is currently being used."
        },
        "startStencil": {
          "usage": "-- Start the stencil, and draw a box to contain our content. \nrender.startStencil() \nrender.setColor( 255, 255, 255 ) \nrender.drawRect( 128, 128, 256, 256 ) \n-- Now draw text inside the box. \nrender.drawStencil() \nrender.setColor( 0, 0, 0 ) \nrender.drawText( Font, 256, 256, \"Hello World!\", render.TEXT_ALIGN_CENTER ) \n-- Finally, end the stencil. \nrender.endStencil()",
          "client": true,
          "description": "Starts a stencil operation. \nAnything drawn after this and before calling render.drawStencil() will be used to restrict drawing. \nAnything drawn after this and before calling render.cutOutStencil() will be cut out of what's drawn after."
        },
        "getTextSize": {
          "ret": [
            "Width of the text.",
            "Height of the text."
          ],
          "returntypes": [
            "number",
            "number"
          ],
          "client": true,
          "description": "Gets the size of the given text displayed with the given font in pixels.",
          "param": {
            "1": "font",
            "2": "text",
            "text": "Text string to check the size of",
            "font": "Font name returned by createFont"
          }
        },
        "drawQuad": {
          "client": true,
          "description": "Draws a quad in 3D space.",
          "param": {
            "1": "topLeft",
            "2": "topRight",
            "3": "bottomRight",
            "4": "bottomLeft",
            "bottomLeft": "The bottom left vector position.",
            "bottomRight": "The bottom right vector position.",
            "topRight": "The top right vector position.",
            "topLeft": "The top left vector position."
          }
        },
        "drawRectOutline": {
          "client": true,
          "description": "Draws a rectangle outline using the current color.",
          "param": {
            "1": "x",
            "2": "y",
            "3": "w",
            "4": "h",
            "5": "thickness",
            "thickness": "The thickness of the outline (default = 1). Thicknesses > 1 are slightly more costly to draw.",
            "h": "Height",
            "w": "Width",
            "y": "Top left corner y co-ordinate",
            "x": "Top left corner x co-ordinate"
          }
        },
        "popFilterMin": {
          "client": true,
          "description": "Pops a min texture filter from the texture filter stack."
        },
        "drawPoly": {
          "usage": "-- Draw a triangle in the centre of the screen. \nrender.drawPoly( { \n\t-- Top vertex, u = 0.5 as it's halfway along the width of the shape. \n\t{ x = 256, y = 256 - 64, u = 0.5, v = 0 }, \n\t-- Bottom right vertex. u = 1 as it's the full width along, v = 1 as it's the full height *down*. \n\t{ x = 256 + 64, y = 256 + 64, u = 1, v = 1 }, \n\t-- Bottom left vertex. u = 0 as it's the very left-most point, v = 1 as it's still the bottom. \n\t{ x = 256 - 64, y = 256 + 64, u = 0, v = 1 } \n} )",
          "client": true,
          "description": "Draws a polygon. Each vertex must be a table with x, y, u and v fields. \nVertices should be in clockwise order, starting at the upper-left most, and form a convex shape.",
          "param": {
            "1": "poly",
            "poly": "Array of vertices."
          }
        },
        "setColor": {
          "client": true,
          "description": "Sets the draw color",
          "param": {
            "1": "r",
            "2": "g",
            "3": "b",
            "4": "a",
            "a": "Alpha value or 0",
            "b": "Blue value or 0",
            "g": "Green value or 0",
            "r": "Red value or 0 or a colour object."
          }
        },
        "drawTextRotated": {
          "client": true,
          "description": "Draws the given text using whatever colour was set previously by setColor(). \nThe text is rotated around its central point by the given angle.",
          "param": {
            "1": "text",
            "2": "font",
            "3": "x",
            "4": "y",
            "5": "ang",
            "text": "The text to draw.",
            "ang": "Angle in degrees.",
            "y": "Y co-ordinate.",
            "x": "X co-ordinate.",
            "font": "The font to use."
          }
        },
        "drawText": {
          "client": true,
          "description": "Draws the given text using whatever colour was set previously by setColor(). \nThis will handle new lines and tabs for you, but will not be as performant as drawRawText().",
          "param": {
            "1": "font",
            "2": "x",
            "3": "y",
            "4": "text",
            "5": "alignment",
            "alignment": "(Optional) Text alignment.",
            "y": "Y co-ordinate.",
            "text": "Text to draw.",
            "x": "X co-ordinate.",
            "font": "The font name to use."
          }
        },
        "drawRawText": {
          "client": true,
          "description": "Draws the given text using whatever colour was set previously by setColor(), the position set by \nsetTextPos() and the font set by setFont(). \nUnlike drawText, this does not handle alignment, new lines or tabs for you. However, it \nwill be significantly more performant. \nAfter drawing, the text position will be updated to be after the width of the drawn text, so you \ndo not need to update it manually unless you wish to render elsewhere.",
          "param": {
            "1": "text",
            "text": "The text to draw."
          }
        },
        "drawRoundedRect": {
          "client": true,
          "description": "Draws a rounded rectangle using the current color.",
          "param": {
            "1": "radius",
            "2": "x",
            "3": "y",
            "4": "w",
            "5": "h",
            "y": "Top left corner y co-ordinate",
            "x": "Top left corner x co-ordinate",
            "radius": "The radius of the rounded corners. Should be power of 2.",
            "h": "Height",
            "w": "Width"
          }
        },
        "pushCustomClipPlane": {
          "client": true,
          "description": "Pushes a clip plane onto the clipping plane stack.",
          "param": {
            "1": "normal",
            "2": "distance",
            "distance": "The distance of the plane.",
            "normal": "The normal vector of the plane."
          }
        },
        "drawCircle": {
          "client": true,
          "description": "Draws a circle outline. \nFor widths > 1, this function can be costly. Consider implementing it yourself with a vertex caching system to get better performance.",
          "param": {
            "1": "x",
            "2": "y",
            "3": "rx",
            "4": "ry",
            "5": "width",
            "y": "Center y co-ordinate",
            "x": "Center x co-ordinate",
            "rx": "X Radius",
            "ry": "Y Radius",
            "width": "The width of the outline (default = 1). Widths > 1 are much more costly to draw."
          }
        },
        "setMaterial": {
          "client": true,
          "description": "Sets the material for upcoming 3D space rendering operations.",
          "param": {
            "1": "mat",
            "mat": "The IMaterial or RenderTarget to use, or nil to set to the default material."
          }
        },
        "isHUD": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the SF instance is a HUD."
        },
        "setLightingMode": {
          "client": true,
          "description": "Sets the lighting mode for upcoming model renders.",
          "param": {
            "1": "mode",
            "mode": "0 is default, 1 is shaded, 2 is fullbright."
          }
        },
        "setLightingOrigin": {
          "client": true,
          "description": "Sets the lighting origin (only works in 3D cameras).",
          "param": {
            "1": "vec",
            "vec": "Origin."
          }
        },
        "enableClipping": {
          "client": true,
          "description": "Enables/disables clipping.",
          "param": {
            "1": "enable",
            "enable": "Sets whether clipping is enabled. You should disable it after."
          }
        },
        "clearDepth": {
          "client": true,
          "description": "Clears the depth buffer."
        },
        "setColorModulation": {
          "client": true,
          "description": "Sets the colour to draw any models with following this point (only works in 3D cameras).",
          "param": {
            "1": "r",
            "2": "g",
            "3": "b",
            "b": "Blue value between 0 and 1.",
            "g": "Green value between 0 and 1.",
            "r": "Red value between 0 and 1."
          }
        },
        "setTextPos": {
          "client": true,
          "description": "Sets the position to draw text at. \nUse before calling drawRawText() to set its position.",
          "param": {
            "1": "x",
            "2": "y",
            "y": "Y co-ordinate.",
            "x": "X co-ordinate."
          }
        },
        "resetModelLighting": {
          "client": true,
          "description": "Resets model lighting (only works in 3D cameras.)",
          "param": {
            "1": "r",
            "2": "g",
            "3": "b",
            "b": "Blue value between 0 and 1.",
            "g": "Green value between 0 and 1.",
            "r": "Red value between 0 and 1."
          }
        },
        "createFont": {
          "ret": "The name of the font that was created. Use this in later rendering functions.",
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Creates a font. Cannot be used in a rendering hook, use it outside. Returns the font's unique name. \nThis only needs to be called once. After that, use the returned name to reference the font. \nIf using a table of parameters, only the first argument is used. The rest are ignored. \nCreating a font is a costly process, only create the fonts you absolutely need.",
          "param": {
            "1": "font",
            "2": "size",
            "3": "weight",
            "4": "antialias",
            "5": "additive",
            "6": "shadow",
            "7": "outline",
            "8": "blur",
            "outline": "Whether to add an outline to the font (default is false).",
            "font": "Base font name to use OR a table containing font parameters (see the Font structure).",
            "blur": "The strength of blurring to apply (between 0 and 10, default is 0).",
            "weight": "The weight of the font (how thick it is, minimum of 100, default is 500).",
            "shadow": "Whether to add a shadow to the font (default is false).",
            "additive": "Whether the font should render additively or not (default is false).",
            "antialias": "Whether to anti-alias the text, which smooths/blurs the edges (default is true).",
            "size": "The size of the font in pixels (between 4 and 255, default is 13)."
          }
        },
        "drawLine": {
          "client": true,
          "description": "Draws a line",
          "param": {
            "1": "x1",
            "2": "y1",
            "3": "x2",
            "4": "y2",
            "5": "width",
            "width": "The width of the line in pixels (default = 1). Widths > 1 are more costly to draw.",
            "y2": "Y end co-ordinate",
            "x2": "X end co-ordinate",
            "y1": "Y start co-ordinate",
            "x1": "X start co-ordinate"
          }
        },
        "drawSprite": {
          "client": true,
          "description": "Draws a sprite in 3D space.",
          "param": {
            "1": "pos",
            "2": "width",
            "3": "height",
            "4": "color",
            "color": "The colour of the sprite.",
            "height": "The height of the sprite.",
            "width": "The width of the sprite.",
            "pos": "The position of the sprite."
          }
        },
        "end3D": {
          "client": true,
          "description": "Ends a 3D camera context. You must do this to start a new one, and you should end every 3D camera you start."
        },
        "drawFilledCircle": {
          "client": true,
          "description": "Draws a filled circle.",
          "param": {
            "1": "x",
            "2": "y",
            "3": "rx",
            "4": "ry",
            "ry": "Y Radius",
            "rx": "X Radius",
            "y": "Center y co-ordinate",
            "x": "Center x co-ordinate"
          }
        },
        "start3D2D": {
          "client": true,
          "description": "Starts a 3D2D camera. Rendering inside this will be drawn in the world at the given location.",
          "param": {
            "1": "vec",
            "2": "ang",
            "3": "scale",
            "scale": "Number to scale all rendering inside by.",
            "ang": "Angles of the 3D2D camera.",
            "vec": "Position of the top left corner of the 3D2D camera."
          }
        },
        "setFont": {
          "client": true,
          "description": "Sets the font to draw text with. \nUse before drawRawText() to set its font.",
          "param": {
            "1": "font",
            "font": "The font name to use."
          }
        },
        "drawSphere": {
          "client": true,
          "description": "Draws a sphere in 3D space.",
          "param": {
            "1": "pos",
            "2": "radius",
            "3": "longitudeSteps",
            "4": "latitudeSteps",
            "5": "color",
            "radius": "The radius of the sphere.",
            "color": "The colour of the sphere.",
            "latitudeSteps": "The amount of latitude steps (controls how smooth the sphere is).",
            "longitudeSteps": "The amount of longitude steps (controls how smooth the sphere is).",
            "pos": "The position of the sphere."
          }
        },
        "getScreenInfo": {
          "ret": "A table describing the screen.",
          "returntypes": [
            "ScreenInfo"
          ],
          "client": true,
          "description": "Returns information about the screen, such as dimensions and rotation."
        },
        "popFilterMag": {
          "client": true,
          "description": "Pops a mag texture filter from the texture filter stack."
        },
        "computeTextureCoords": {
          "ret": [
            "The corrected u co-ordinate.",
            "The corrected v co-ordinate.",
            "The corrected end u co-ordinate.",
            "The corrected end v co-ordinate."
          ],
          "returntypes": [
            "number",
            "number",
            "number",
            "number"
          ],
          "usage": "local texture = render.getTextureID( \"some/material\" ) \n-- Compute the corrected texture co-ordinates to tile the texture in a 2x2 grid. \nlocal u0, v0, u1, v1 = render.computeTextureCoords( texture, 0, 0, 2, 2 ) \nhook( \"render\", \"example\", function() \n\trender.clear() \n\trender.setColor( 255, 255, 255 ) \n\trender.setTexture( texture ) \n\trender.drawTexturedRectUV( 0, 0, 512, 512, u0, v0, u1, v1 ) \nend )",
          "client": true,
          "description": "Computes corrected texture co-ordinates for the given texture/material. \nWhen using drawTexturedRectUV, the engine internally alters the texture co-ordinates. \nThis function accounts for that alteration and ensures the rendering operation uses the intended values.",
          "param": {
            "1": "texture",
            "2": "u",
            "3": "v",
            "4": "endU",
            "5": "endV",
            "endV": "The intended end v co-ordinate.",
            "endU": "The intended end u co-ordinate.",
            "v": "The intended v co-ordinate.",
            "u": "The intended u co-ordinate.",
            "texture": "The texture ID or IMaterial to compute corrected co-ordinates for."
          }
        },
        "setLocalModelLights": {
          "client": true,
          "description": "Sets up local model lights, you can use up to 4.",
          "param": {
            "1": "lights",
            "lights": "A table of up to 4 lights (see the LocalLight structure). Pass nil to reset them."
          }
        },
        "readPixel": {
          "ret": "Colour of the pixel as a colour object.",
          "returntypes": [
            "Color"
          ],
          "client": true,
          "description": "Reads the colour of the specified pixel.",
          "param": {
            "1": "x",
            "2": "y",
            "y": "Pixel y co-ordinate.",
            "x": "Pixel x co-ordinate."
          }
        },
        "getClientModelCount": {
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the number of clientside models you have currently in use across all instances."
        },
        "suppressEngineLighting": {
          "client": true,
          "description": "Sets whether to supress the standard lighting (only works in 3D cameras.)",
          "param": {
            "1": "bool",
            "bool": "Suppress?"
          }
        },
        "capturePixels": {
          "client": true,
          "description": "Dumps the current render target and allows the pixels to be accessed by render.readPixel."
        },
        "isEmitter": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the SF instance is an emitter."
        }
      },
      "description": "Render library. Screens are 512x512 units. Most functions require that you be in the rendering hook to call, otherwise an error is thrown. +x is right, +y is down",
      "fields": {
        "1": "TEXT_ALIGN_BOTTOM",
        "2": "TEXT_ALIGN_RIGHT",
        "3": "TEXT_ALIGN_CENTER",
        "4": "TEXT_ALIGN_TOP",
        "5": "TEXT_ALIGN_LEFT",
        "6": "RENDERGROUP_BOTH",
        "7": "RENDERGROUP_OPAQUE",
        "8": "RENDERGROUP_OPAQUE_BRUSH",
        "9": "RENDERGROUP_OPAQUE_HUGE",
        "10": "RENDERGROUP_OTHER",
        "11": "RENDERGROUP_STATIC",
        "12": "RENDERGROUP_STATIC_HUGE",
        "13": "RENDERGROUP_TRANSLUCENT",
        "14": "RENDERGROUP_VIEWMODEL",
        "15": "RENDERGROUP_VIEWMODEL_TRANSLUCENT",
        "16": "BOX_BACK",
        "17": "BOX_BOTTOM",
        "18": "BOX_FRONT",
        "19": "BOX_LEFT",
        "20": "BOX_RIGHT",
        "21": "BOX_TOP",
        "22": "MATERIAL_LIGHT_DISABLE",
        "23": "MATERIAL_LIGHT_POINT",
        "24": "MATERIAL_LIGHT_DIRECTIONAL",
        "25": "MATERIAL_LIGHT_SPOT",
        "26": "BLEND_ZERO",
        "27": "BLEND_ONE",
        "28": "BLEND_DST_COLOR",
        "29": "BLEND_ONE_MINUS_DST_COLOR",
        "30": "BLEND_SRC_ALPHA",
        "31": "BLEND_ONE_MINUS_SRC_ALPHA",
        "32": "BLEND_DST_ALPHA",
        "33": "BLEND_ONE_MINUS_DST_ALPHA",
        "34": "BLEND_SRC_ALPHA_SATURATE",
        "35": "BLEND_SRC_COLOR",
        "36": "BLEND_ONE_MINUS_SRC_COLOR",
        "37": "BLENDFUNC_ADD",
        "38": "BLENDFUNC_SUBTRACT",
        "39": "BLENDFUNC_REVERSE_SUBTRACT",
        "RENDERGROUP_OPAQUE_BRUSH": {
          "description": "RENDERGROUP_OPAQUE_BRUSH",
          "client": true
        },
        "RENDERGROUP_BOTH": {
          "description": "RENDERGROUP_BOTH",
          "client": true
        },
        "BOX_LEFT": {
          "description": "BOX_LEFT",
          "client": true
        },
        "TEXT_ALIGN_TOP": {
          "description": "TEXT_ALIGN_TOP",
          "client": true
        },
        "RENDERGROUP_OPAQUE": {
          "description": "RENDERGROUP_OPAQUE",
          "client": true
        },
        "BOX_BOTTOM": {
          "description": "BOX_BOTTOM",
          "client": true
        },
        "BLEND_ZERO": {
          "description": "BLEND_ZERO",
          "client": true
        },
        "BOX_BACK": {
          "description": "BOX_BACK",
          "client": true
        },
        "TEXT_ALIGN_LEFT": {
          "description": "TEXT_ALIGN_LEFT",
          "client": true
        },
        "MATERIAL_LIGHT_POINT": {
          "description": "A light that emits from a single point in all directions.",
          "client": true
        },
        "TEXT_ALIGN_CENTER": {
          "description": "TEXT_ALIGN_CENTER",
          "client": true
        },
        "RENDERGROUP_OPAQUE_HUGE": {
          "description": "RENDERGROUP_OPAQUE_HUGE",
          "client": true
        },
        "BLEND_ONE_MINUS_DST_COLOR": {
          "description": "BLEND_ONE_MINUS_DST_COLOR",
          "client": true
        },
        "TEXT_ALIGN_RIGHT": {
          "description": "TEXT_ALIGN_RIGHT",
          "client": true
        },
        "BLEND_SRC_COLOR": {
          "description": "BLEND_SRC_COLOR",
          "client": true
        },
        "BLENDFUNC_REVERSE_SUBTRACT": {
          "description": "BLENDFUNC_REVERSE_SUBTRACT",
          "client": true
        },
        "BLENDFUNC_SUBTRACT": {
          "description": "BLENDFUNC_SUBTRACT",
          "client": true
        },
        "RENDERGROUP_STATIC_HUGE": {
          "description": "RENDERGROUP_STATIC_HUGE",
          "client": true
        },
        "BLEND_SRC_ALPHA_SATURATE": {
          "description": "BLEND_SRC_ALPHA_SATURATE",
          "client": true
        },
        "BLEND_ONE_MINUS_DST_ALPHA": {
          "description": "BLEND_ONE_MINUS_DST_ALPHA",
          "client": true
        },
        "RENDERGROUP_OTHER": {
          "description": "RENDERGROUP_OTHER",
          "client": true
        },
        "BLEND_ONE": {
          "description": "BLEND_ONE",
          "client": true
        },
        "BLEND_DST_ALPHA": {
          "description": "BLEND_DST_ALPHA",
          "client": true
        },
        "RENDERGROUP_STATIC": {
          "description": "RENDERGROUP_STATIC",
          "client": true
        },
        "MATERIAL_LIGHT_DIRECTIONAL": {
          "description": "A light that emits from a point in a specific direction. Unlike a spot light, this does not have multiple cones.",
          "client": true
        },
        "BLEND_SRC_ALPHA": {
          "description": "BLEND_SRC_ALPHA",
          "client": true
        },
        "BLEND_DST_COLOR": {
          "description": "BLEND_DST_COLOR",
          "client": true
        },
        "BLEND_ONE_MINUS_SRC_COLOR": {
          "description": "BLEND_ONE_MINUS_SRC_COLOR",
          "client": true
        },
        "TEXT_ALIGN_BOTTOM": {
          "description": "TEXT_ALIGN_BOTTOM",
          "client": true
        },
        "MATERIAL_LIGHT_SPOT": {
          "description": "A spotlight comprising of 2 light cones.",
          "client": true
        },
        "BOX_RIGHT": {
          "description": "BOX_RIGHT",
          "client": true
        },
        "RENDERGROUP_VIEWMODEL_TRANSLUCENT": {
          "description": "RENDERGROUP_VIEWMODEL_TRANSLUCENT",
          "client": true
        },
        "BOX_FRONT": {
          "description": "BOX_FRONT",
          "client": true
        },
        "RENDERGROUP_VIEWMODEL": {
          "description": "RENDERGROUP_VIEWMODEL",
          "client": true
        },
        "BOX_TOP": {
          "description": "BOX_TOP",
          "client": true
        },
        "MATERIAL_LIGHT_DISABLE": {
          "description": "Disables the light at the given index.",
          "client": true
        },
        "BLENDFUNC_ADD": {
          "description": "BLENDFUNC_ADD",
          "client": true
        },
        "BLEND_ONE_MINUS_SRC_ALPHA": {
          "description": "BLEND_ONE_MINUS_SRC_ALPHA",
          "client": true
        },
        "RENDERGROUP_TRANSLUCENT": {
          "description": "RENDERGROUP_TRANSLUCENT",
          "client": true
        }
      },
      "client": true
    },
    "string": {
      "functions": {
        "1": "explode",
        "explode": {
          "ret": "An array containing the segments of the string split by the given delimiter.",
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Splits the given string based on the given delimiter.",
          "paramtypes": {
            "string": "string",
            "withPattern": "boolean?",
            "delimiter": "string"
          },
          "usage": "-- This will print \"comma\" as it's the second value when splitting by \",\". \nprint( string.explode( \"some,comma,separated,values\", \",\" )[ 2 ] )",
          "param": {
            "1": "string",
            "2": "delimiter",
            "3": "withPattern",
            "string": "The string to split.",
            "withPattern": "Whether the delimiter should be interpreted as a Lua pattern or not (default = false).",
            "delimiter": "The delimiter to split the string by."
          }
        }
      },
      "description": "Lua's (not glua's) string library",
      "externaldocs": "http://www.lua.org/manual/5.1/manual.html#5.4"
    },
    "bit": {
      "functions": [
      ],
      "description": "LuaJIT's bit library.",
      "externaldocs": "http://bitop.luajit.org/api.html"
    },
    "props": {
      "functions": {
        "1": "canCreate",
        "2": "create",
        "3": "createVehicleSeat",
        "4": "deleteOnShutdown",
        "5": "getAll",
        "6": "removeAll",
        "getAll": {
          "server": true,
          "returntypes": [
            "table"
          ],
          "description": "Returns a table containing every prop/vehicle seat you have spawned with props.create()/props.createVehicleSeat()."
        },
        "canCreate": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether a prop can be created."
        },
        "removeAll": {
          "server": true,
          "description": "Removes every prop/vehicle seat you have created with props.create()/props.createVehicleSeat()."
        },
        "deleteOnShutdown": {
          "server": true,
          "description": "Sets whether props/vehicle seats should be deleted when the instance shuts down (either from error or chip removal).",
          "param": {
            "1": "shouldDelete",
            "shouldDelete": "Whether all props/vehicle seats spawned by this instance be deleted on shutdown."
          }
        },
        "create": {
          "ret": [
            "The created prop entity, or nil if creation failed.",
            "If creation failed, the reason why."
          ],
          "server": true,
          "returntypes": [
            "Entity",
            "string"
          ],
          "description": "Creates a prop_physics entity with the given model. \nCan optionally place it at a given position, and set its angles. \nThis requires the SPAWN_ENTITY permission when running in restricted mode (e.g. executed from the shared area).",
          "param": {
            "1": "model",
            "2": "pos",
            "3": "ang",
            "4": "dontUndo",
            "dontUndo": "If true, then the prop will not be added to your undo list.",
            "ang": "Optional starting angles.",
            "pos": "Optional starting position.",
            "model": "The model to give the prop."
          }
        },
        "createVehicleSeat": {
          "ret": [
            "The created vehicle entity, or nil if creation failed.",
            "If creation failed, the reason why."
          ],
          "server": true,
          "returntypes": [
            "Entity",
            "string"
          ],
          "description": "Creates a vehicle seat with the given model. \nCan optionally place it at a given position, and set its angles. \nThis requires the SPAWN_ENTITY permission when running in restricted mode (e.g. executed from the shared area).",
          "param": {
            "1": "model",
            "2": "pos",
            "3": "ang",
            "4": "dontUndo",
            "dontUndo": "If true, then the vehicle will not be added to your undo list.",
            "ang": "Optional starting angles.",
            "pos": "Optional starting position.",
            "model": "The model to give the vehicle (must be a valid seat model, see the vehicles tab of the spawnmenu)."
          }
        }
      },
      "description": "Prop spawning library.",
      "server": true
    },
    "permissions": {
      "functions": {
        "1": "canPerformAction",
        "2": "register",
        "canPerformAction": {
          "ret": "True if the instance has been granted this permission, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether your instance has been granted permission to perform the given action. \nNote that this will throw an error if you have not registered the permission first.",
          "param": {
            "1": "action",
            "action": "The permission action to check access for."
          }
        },
        "register": {
          "usage": "-- Request access to draw halos and play sounds from the internet. \npermissions.register( { permissions.DRAW_HALOS, permissions.PLAY_URL_SOUNDS } )",
          "description": "Registers a permission request for this instance. You must register permissions in order to be granted them. \nAll valid permissions are fields on the permissions library table.",
          "param": {
            "1": "rights",
            "rights": "The permission(s) to register (a single value or a list of values)."
          }
        }
      },
      "description": "Permissions library. \nProvides an interface to check for access to certain priveleged functions.",
      "fields": {
        "1": "SPAWN_ENTITY",
        "2": "REMOVE_ENTITY",
        "3": "SET_PLAYER_POSITION",
        "4": "PLAY_CLIENT_SOUNDS",
        "5": "DRAW_HALOS",
        "6": "PLAY_URL_SOUNDS",
        "7": "USE_WEB_BROWSER",
        "8": "SEND_HTTP_REQUESTS",
        "9": "READ_CHATBOX_STATE",
        "10": "DRAW_MESH_HOLOGRAMS",
        "11": "USE_RENDER_TARGET_MATERIALS_WITH_HOLOGRAMS",
        "REMOVE_ENTITY": {
          "description": "Permission to remove entities belonging to the owner.",
          "server": true
        },
        "SET_PLAYER_POSITION": {
          "description": "Permission to set the owner's position.",
          "server": true
        },
        "USE_RENDER_TARGET_MATERIALS_WITH_HOLOGRAMS": {
          "description": "Permission to apply render target textures as a hologram's material.",
          "client": true
        },
        "READ_CHATBOX_STATE": {
          "description": "Permission to read the chatbox state, including typed text.",
          "client": true
        },
        "USE_WEB_BROWSER": {
          "description": "Permission to use the game's web browser.",
          "client": true
        },
        "DRAW_MESH_HOLOGRAMS": {
          "description": "Permission to draw meshes using holograms.",
          "client": true
        },
        "PLAY_URL_SOUNDS": {
          "description": "Permission to play sounds from the internet.",
          "client": true
        },
        "PLAY_CLIENT_SOUNDS": {
          "description": "Permission to play sounds on the client.",
          "client": true
        },
        "SEND_HTTP_REQUESTS": {
          "description": "Permission to make HTTP requests on the client (on the chip's owner only).",
          "client": true
        },
        "SPAWN_ENTITY": {
          "description": "Permission to spawn entities (props).",
          "server": true
        },
        "DRAW_HALOS": {
          "description": "Permission to draw halos on the client.",
          "client": true
        }
      }
    },
    "os": {
      "functions": [
      ],
      "description": "GLua's os library.",
      "externaldocs": "https://wiki.facepunch.com/gmod/os"
    },
    "table": {
      "functions": [
      ],
      "description": "Lua's (not glua's) table library",
      "externaldocs": "http://www.lua.org/manual/5.1/manual.html#5.5"
    },
    "wire": {
      "functions": {
        "1": "create",
        "2": "createInputs",
        "3": "createOutputs",
        "4": "delete",
        "5": "getInputs",
        "6": "getOutputs",
        "7": "self",
        "8": "setName",
        "self": {
          "ret": "The wirelink for the current instance's entity.",
          "server": true,
          "returntypes": [
            [
              "Wirelink",
              "nil"
            ],
            "string"
          ],
          "description": "Returns the wirelink representing the current instance's entity."
        },
        "delete": {
          "ret": "True if successful, false, error if not.",
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Deletes the wire leading to the given entity's input.",
          "param": {
            "1": "entity",
            "2": "input",
            "input": "The name of the input to unwire.",
            "entity": "The entity to delete the wire from."
          }
        },
        "createInputs": {
          "server": true,
          "usage": "-- Creates 2 wire inputs, a string and a number. \nwire.createInputs( { \"MyStringInput\", \"MyNumberInput\" }, { \"string\", \"normal\" } )",
          "description": "Creates/modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.",
          "param": {
            "1": "names",
            "2": "types",
            "types": "An array of input types. May be modified by the function. \nAvailable types: \n- \"normal\"/\"number\" \n- \"string\" \n- \"vector\" \n- \"angle\" \n- \"table\" \n- \"array\" \n- \"wirelink\" \n- \"entity\"",
            "names": "An array of input names. May be modified by the function."
          }
        },
        "setName": {
          "ret": [
            "True if the name was set, false otherwise.",
            "If the name could not be set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "name": "string",
            "entity": "Entity"
          },
          "description": "Sets the wire name of the entity (i.e. the name used by the wire namer tool).",
          "param": {
            "1": "entity",
            "2": "name",
            "name": "The name to assign to the entity.",
            "entity": "The entity to set the name for."
          }
        },
        "create": {
          "ret": "True if successful, false, error if not.",
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Wires the input of Entity1 to the output of Entity2.",
          "param": {
            "1": "entity1",
            "2": "entity2",
            "3": "input",
            "4": "output",
            "output": "The name of the output on Ent to wire to.",
            "input": "The name of the input on self to wire.",
            "entity2": "The entity to wire to.",
            "entity1": "The entity to wire from."
          }
        },
        "getOutputs": {
          "ret": "Table of entity's outputs, if it has any. Otherwise nil.",
          "server": true,
          "returntypes": [
            [
              "table<number,string>",
              "nil"
            ]
          ],
          "description": "Returns a table of entity's outputs",
          "param": {
            "1": "ent",
            "ent": "Entity with output(s)"
          }
        },
        "createOutputs": {
          "server": true,
          "usage": "-- Creates 2 wire outputs, a string and a number. \nwire.createOutputs( { \"MyStringOutput\", \"MyNumberOutput\" }, { \"string\", \"normal\" } )",
          "description": "Creates/modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.",
          "param": {
            "1": "names",
            "2": "types",
            "types": "An array of output types. May be modified by the function. \nAvailable types: \n- \"normal\"/\"number\" \n- \"string\" \n- \"vector\" \n- \"angle\" \n- \"table\" \n- \"array\" \n- \"entity\"",
            "names": "An array of output names. May be modified by the function."
          }
        },
        "getInputs": {
          "ret": "Table of entity's inputs, if it has any. Otherwise nil.",
          "server": true,
          "returntypes": [
            [
              "table<number,string>",
              "nil"
            ]
          ],
          "description": "Returns a table of entity's inputs",
          "param": {
            "1": "ent",
            "ent": "Entity with input(s)"
          }
        }
      },
      "description": "Wire library. Handles wire inputs/outputs, wirelinks, etc.",
      "tables": {
        "1": "ports",
        "ports": {
          "description": "Ports table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.",
          "server": true
        }
      },
      "server": true
    },
    "serverinfo": {
      "functions": {
        "1": "airDensity",
        "2": "gamemode",
        "3": "gravity",
        "4": "hostname",
        "5": "isDedicatedServer",
        "6": "isLan",
        "7": "isSinglePlayer",
        "8": "map",
        "9": "maxPlayers",
        "10": "numPlayers",
        "11": "performanceSettings",
        "map": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the map name"
        },
        "numPlayers": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the number of players on the server"
        },
        "isSinglePlayer": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether or not the current game is single player"
        },
        "performanceSettings": {
          "returntypes": [
            "PhysEnvSettings"
          ],
          "description": "Returns a table containing physics environment settings."
        },
        "airDensity": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the air density. See Glua's physenv.GetAirDensity()"
        },
        "isLan": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the server is on a LAN"
        },
        "hostname": {
          "returntypes": [
            "string"
          ],
          "description": "Returns The hostname"
        },
        "gravity": {
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the server's acceleration due to gravity vector."
        },
        "isDedicatedServer": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether or not the server is a dedicated server"
        },
        "gamemode": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the gamemode as a String"
        },
        "maxPlayers": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the maximum player limit"
        }
      },
      "description": "Server info functions.",
      "client": true,
      "server": true
    },
    "fastlz": {
      "functions": {
        "1": "compress",
        "2": "decompress",
        "decompress": {
          "ret": "The decompressed string.",
          "returntypes": [
            "string"
          ],
          "description": "Decompresses the given string.",
          "param": {
            "1": "string",
            "2": "maxSize",
            "maxSize": "An optional size limit in bytes after which decompression will be stopped.",
            "string": "The string value to be decompressed (compressed with fastlz.compress())."
          }
        },
        "compress": {
          "ret": "The compressed string.",
          "returntypes": [
            "string"
          ],
          "description": "Compresses the given string.",
          "param": {
            "1": "string",
            "string": "The string value to be compressed."
          }
        }
      },
      "description": "FastLZ library. \nProvides compression and decompression using the LZMA method."
    },
    "debug": {
      "functions": {
        "1": "isCalledBy",
        "2": "isCalledByAnyOf",
        "3": "traceback",
        "traceback": {
          "ret": "A string representing the current call stack, or the given message if it is not a string.",
          "returntypes": [
            "string"
          ],
          "description": "Provides the current stack traceback.",
          "paramtypes": {
            "stackLevel": "number?",
            "message": "string?",
            "thread": "thread?"
          },
          "usage": "-- Get a traceback starting at the current line \ndebug.traceback() \n \n-- Get a traceback with a message starting at the caller. \ndebug.traceback( \"Some error happened\", 2 ) \n \n-- Get a traceback from a coroutine. \ndebug.traceback( Thread ) \n \n-- Get a traceback from a coroutine at a given level (0 = yield, error or return). \ndebug.traceback( Thread, \"Some error happened\", 2 )",
          "param": {
            "1": "thread",
            "2": "message",
            "3": "stackLevel",
            "stackLevel": "(Optional) The stack level to start the traceback from (1 = where debug.traceback() is called or where a coroutine last yielded/died).",
            "message": "(Optional) The message to include on the first line of the traceback (e.g. a caught error).",
            "thread": "(Optional) The coroutine to get the traceback from."
          }
        },
        "isCalledByAnyOf": {
          "ret": "True if the function at the given stack level is contained in the lookup (using rawget).",
          "returntypes": [
            "boolean"
          ],
          "description": "Indicates whether any of the given functions are the caller at the given stack level.",
          "param": {
            "1": "level",
            "2": "funcs",
            "funcs": "The functions to look for (a lookup table with function keys).",
            "level": "The stack level above the current level to check (1 = current level)."
          }
        },
        "isCalledBy": {
          "ret": "True if the function at the given stack level is equal to the given function.",
          "returntypes": [
            "boolean"
          ],
          "description": "Indicates whether the given function is the caller at the given stack level.",
          "param": {
            "1": "level",
            "2": "func",
            "func": "The function to look for.",
            "level": "The stack level above the current level to check (1 = current level)."
          }
        }
      },
      "description": "Debug library."
    },
    "net": {
      "functions": {
        "1": "broadcast",
        "2": "bytesLeft",
        "3": "bytesWritten",
        "4": "canSend",
        "5": "getDTVar",
        "6": "getMaxDTVarIndex",
        "7": "listenForAllDTVarChanges",
        "8": "listenForDTVarChanges",
        "9": "quotaMax",
        "10": "quotaUsed",
        "11": "readAngle",
        "12": "readBit",
        "13": "readBool",
        "14": "readData",
        "15": "readDouble",
        "16": "readEntity",
        "17": "readFloat",
        "18": "readInt",
        "19": "readMatrix",
        "20": "readNormal",
        "21": "readString",
        "22": "readTable",
        "23": "readType",
        "24": "readUInt",
        "25": "readVector",
        "26": "send",
        "27": "sendOmit",
        "28": "sendPAS",
        "29": "sendPVS",
        "30": "sendToServer",
        "31": "setDTVar",
        "32": "start",
        "33": "writeAngle",
        "34": "writeBit",
        "35": "writeBool",
        "36": "writeData",
        "37": "writeDouble",
        "38": "writeEntity",
        "39": "writeFloat",
        "40": "writeInt",
        "41": "writeMatrix",
        "42": "writeNormal",
        "43": "writeString",
        "44": "writeTable",
        "45": "writeType",
        "46": "writeUInt",
        "47": "writeVector",
        "getDTVar": {
          "ret": "The value stored against the given DTVar.",
          "description": "Retrieves a DataTable value from the chip. \nUse net.setDTVar() on the server to set them.",
          "param": {
            "1": "type",
            "2": "index",
            "3": "chip",
            "chip": "Optional chip entity that you own to get the value from.",
            "index": "An integer between 1 and 32 (1 and 4 for strings).",
            "type": "Type of the DTVar. One of \"Angle\", \"Bool\", \"Entity\", \"Float\", \"Int\", \"String\", or \"Vector\"."
          }
        },
        "writeVector": {
          "description": "Writes a vector to the net message.",
          "param": {
            "1": "vec",
            "2": "lowPrecision",
            "lowPrecision": "If true, the written data will be smaller at the cost of precision.",
            "vec": "Vector to write."
          }
        },
        "readDouble": {
          "ret": "A double precision float value from the net message.",
          "returntypes": [
            "number"
          ],
          "description": "Reads a double precision float from the net message."
        },
        "readEntity": {
          "ret": "An entity from the net message.",
          "returntypes": [
            "Entity"
          ],
          "description": "Reads an entity from the net message."
        },
        "writeTable": {
          "description": "Writes an entire table to the net message. \nNOTE: This writes 8 bit key type, key, 8 bit value type, value for every key-value pair.",
          "param": {
            "1": "table",
            "table": "Table to write."
          }
        },
        "readFloat": {
          "ret": "A float value from the net message.",
          "returntypes": [
            "number"
          ],
          "description": "Reads a float from the net message.",
          "param": {
            "1": "double",
            "double": "Boolean flag to read a double precision float."
          }
        },
        "writeBit": {
          "description": "Writes a bit to the current net message.",
          "param": {
            "1": "bit",
            "bit": "Boolean true or false as the bit to write."
          }
        },
        "listenForAllDTVarChanges": {
          "client": true,
          "description": "Enables change detection for all DataTable values on the chip. \nChanges will be broadcast via. the \"dtvarchanged\" hook, passing the type, index, old value and new value. \nThis can increase CPU usage, so should only be used if all DataTable values are used and need change detection. \nUse net.listenForDTVarChanges() to specify more precise change detection."
        },
        "readTable": {
          "ret": "A table from the net message.",
          "returntypes": [
            "table"
          ],
          "description": "Reads a table from the net message."
        },
        "broadcast": {
          "server": true,
          "description": "Broadcasts the currently stored network message to every player."
        },
        "writeBool": {
          "description": "Writes a boolean to the current message.",
          "param": {
            "1": "bool",
            "bool": "Boolean value to write."
          }
        },
        "writeInt": {
          "description": "Writes an integer to the current net message.",
          "param": {
            "1": "int",
            "2": "bits",
            "3": "unsigned",
            "unsigned": "Boolean to send the integer as an unsigned integer. Unsigned integers have a larger range but can't be negative.",
            "bits": "Number of bits the integer uses. Must be between 1 and 32.",
            "int": "Integer to write."
          }
        },
        "readVector": {
          "ret": "A vector from the net message.",
          "returntypes": [
            "Vector"
          ],
          "description": "Reads a vector from the net message.",
          "param": {
            "1": "lowPrecision",
            "lowPrecision": "Should be the same as the value used for net.writeVector()."
          }
        },
        "bytesWritten": {
          "ret": "The number of bytes written to the current message.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the number of bytes currently written."
        },
        "setDTVar": {
          "server": true,
          "description": "Sets a DataTable value on the given chip entity. \nDataTable values are networked automatically to all clients whenever their value changes. \nEach chip has a limited number of values available per type. The index controls which value to set under a given type. \nIf you omit the last argument, the value will be set on the chip executing this function. \nFor entities, use ents.NULL_ENTITY to reset the value.",
          "param": {
            "1": "type",
            "2": "index",
            "3": "value",
            "4": "chip",
            "chip": "(Optional) Chip entity that you own to set the value on.",
            "value": "The value to set.",
            "index": "An integer between 1 and 32 (1 and 4 for strings).",
            "type": "Type of the DTVar. One of \"Angle\", \"Bool\", \"Entity\", \"Float\", \"Int\", \"String\", or \"Vector\"."
          }
        },
        "quotaMax": {
          "ret": "The maximum amount of bytes/s allowed.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the max amount of bytes/s allowed."
        },
        "writeFloat": {
          "description": "Writes a float to the current net message.",
          "param": {
            "1": "float",
            "2": "double",
            "double": "Boolean flag to use double precision instead of single.",
            "float": "Floating point number to write."
          }
        },
        "sendToServer": {
          "client": true,
          "description": "Sends the currently stored network message to the server."
        },
        "readType": {
          "ret": "A value of the given type from the net message.",
          "description": "Reads a value from the net message of the given type enum. \nUsually the type would be sent as part of net.writeType()",
          "param": {
            "1": "type",
            "type": "The type ID to read."
          }
        },
        "readBool": {
          "ret": "A boolean value from the net message.",
          "returntypes": [
            "boolean"
          ],
          "description": "Reads a boolean from the net message."
        },
        "writeAngle": {
          "description": "Writes an angle to the net message.",
          "param": {
            "1": "ang",
            "2": "lowPrecision",
            "lowPrecision": "If true, the written data will be smaller at the cost of precision.",
            "ang": "Angle to write."
          }
        },
        "writeEntity": {
          "description": "Writes an entity to the net message.",
          "param": {
            "1": "ent",
            "ent": "Entity to write."
          }
        },
        "sendPVS": {
          "server": true,
          "description": "Sends the currently stored network message to every player who has the given position in their PVS \n(Potentially Visible Set).",
          "param": {
            "1": "pos",
            "pos": "The position to check visibility for."
          }
        },
        "listenForDTVarChanges": {
          "client": true,
          "description": "Enables change detection for the given DataTable value. \nChanges will be broadcast via. the \"dtvarchanged\" hook, passing the type, index, old value and new value. \nIf an index is not provided, all indices for the given type will have change detection enabled.",
          "param": {
            "1": "type",
            "2": "index",
            "index": "(Optional) An integer between 1 and 32 (1 and 4 for strings).",
            "type": "Type of the DTVar. One of \"Angle\", \"Bool\", \"Entity\", \"Float\", \"Int\", \"String\", or \"Vector\"."
          }
        },
        "send": {
          "server": true,
          "description": "Sends the currently stored net message to the given player. Passing nil is the same as net.broadcast().",
          "param": {
            "1": "ply",
            "ply": "The player to send the message to. Passing nil sends to all."
          }
        },
        "writeNormal": {
          "description": "Writes a normalised vector to the net message.",
          "param": {
            "1": "normal",
            "normal": "Normalised vector to write."
          }
        },
        "quotaUsed": {
          "ret": "The amount of bytes currently used.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the amount of bytes in the net quota currently used. \nNote that this does not include the message currently being written, as the quota usage depends on the players the message will be sent to. \nIf called on the server with no target specified, this returns the average quota used across all players.",
          "param": {
            "1": "target",
            "target": "The player to get the current quota usage against (server only)."
          }
        },
        "readUInt": {
          "ret": "An unsigned integer value from the net message, consuming the specified number of bits.",
          "returntypes": [
            "number"
          ],
          "description": "Reads an unsigned integer from the net message.",
          "param": {
            "1": "bits",
            "bits": "Number of bits the integer was sent with. Must be between 1 and 32."
          }
        },
        "readBit": {
          "ret": "A bit value from the net message (either 1 or 0).",
          "returntypes": [
            "number"
          ],
          "description": "Reads a bit from the net message."
        },
        "readAngle": {
          "ret": "An angle from the net message.",
          "returntypes": [
            "Angle"
          ],
          "description": "Reads an angle from the net message.",
          "param": {
            "1": "lowPrecision",
            "lowPrecision": "Should be the same as the value used for net.writeAngle()."
          }
        },
        "sendPAS": {
          "server": true,
          "description": "Sends the currently stored network message to every player who has the given position in their PAS \n(Potentially Audible Set)",
          "param": {
            "1": "pos",
            "pos": "The position to check hearing for."
          }
        },
        "sendOmit": {
          "server": true,
          "description": "Sends the currently stored network message to every player except those you pass in.",
          "param": {
            "1": "plys",
            "plys": "A player or table of players to not send to."
          }
        },
        "readString": {
          "ret": "A string from the net message.",
          "returntypes": [
            "string"
          ],
          "description": "Reads a string from the net message."
        },
        "writeType": {
          "description": "Writes the value's type, then its value to the net message. \nNote that this means an extra byte for the type is sent so use only if necessary.",
          "param": {
            "1": "value",
            "value": "The value to write."
          }
        },
        "readNormal": {
          "ret": "A normialised vector from the net message.",
          "returntypes": [
            "Vector"
          ],
          "description": "Reads a normalised vector from the net message."
        },
        "readData": {
          "ret": "A binary string from the net message with the given length.",
          "returntypes": [
            "string"
          ],
          "description": "Reads binary data from the net message.",
          "param": [
            "length"
          ]
        },
        "getMaxDTVarIndex": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the maximum index available for the given DTVar type, or 0 if the given type is invalid. \nSome entity types can have less slots available.",
          "param": {
            "1": "type",
            "2": "chip",
            "chip": "(Optional) Chip entity that you own to get the maximum index from. Default is the instance's chip.",
            "type": "The type of DTVar to get the maximum index of."
          }
        },
        "bytesLeft": {
          "ret": "The number of bytes remaining to read in the current net message.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the number of bytes left in the current net message. Only works inside the net hook."
        },
        "writeString": {
          "description": "Writes a string to the net message. Some special characters may not be sent correctly. \nUse net.writeData for that.",
          "param": {
            "1": "string",
            "string": "String to write."
          }
        },
        "writeMatrix": {
          "description": "Writes a matrix to the net message.",
          "param": {
            "1": "matrix",
            "matrix": "The VMatrix to write."
          }
        },
        "writeUInt": {
          "description": "Writes an unsigned integer to the current net message.",
          "param": {
            "1": "int",
            "2": "bits",
            "bits": "Number of bits the integer uses. Must be between 1 and 32.",
            "int": "Integer to write."
          }
        },
        "readInt": {
          "ret": "An integer value from the net message, consuming the specified number of bits.",
          "returntypes": [
            "number"
          ],
          "description": "Reads an integer from the net message.",
          "param": {
            "1": "bits",
            "2": "unsigned",
            "unsigned": "Boolean flag to read an unsigned integer.",
            "bits": "Number of bits the integer was sent with. Must be between 1 and 32."
          }
        },
        "canSend": {
          "ret": "True if a net message can be sent, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Indicates whether a net message can be sent at this time. \nIf the target is omitted on the server, then this will return false if there is at least one player that cannot have a message sent to them at this time.",
          "param": {
            "1": "target",
            "target": "The specific player to check (server only)."
          }
        },
        "start": {
          "ret": [
            "True if the message started successfully, false otherwise.",
            "The reason the message did not start successfully, if the first returned value was false."
          ],
          "description": "Starts a net message. All net.write functions called after this and before a send or broadcast will be sent in one net message. Returns true if the message can be written, false otherwise.",
          "returntypes": [
            "boolean",
            "string"
          ],
          "param": {
            "1": "ent",
            "2": "unreliable",
            "unreliable": "If set to true, the message will not ensure the other end receives it and thus not wait for it before sending a new message.",
            "ent": "Optional Starfall entity to send the message to instead of the current instance's entity. Can only send to entities you own."
          }
        },
        "writeData": {
          "description": "Writes binary data to the net message.",
          "param": {
            "1": "data",
            "2": "length",
            "length": "The length, in bytes, of the data.",
            "data": "The data to send (a string)."
          }
        },
        "writeDouble": {
          "description": "Writes a double precision float to the current net message.",
          "param": {
            "1": "double",
            "double": "Double precision float to write."
          }
        },
        "readMatrix": {
          "ret": "A matrix from the net message.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Reads a VMatrix from the net message."
        }
      },
      "description": "Networking library. More reliable and flexible than usermessages. Allows for networking server to client or client to server.",
      "client": true,
      "server": true
    },
    "stargate": {
      "functions": {
        "1": "accessList",
        "2": "active",
        "3": "address",
        "4": "addressList",
        "5": "asuranBeam",
        "6": "blocked",
        "7": "canDial",
        "8": "cfdEnable",
        "9": "cfdEnabled",
        "10": "chevron",
        "11": "chevrons",
        "12": "close",
        "13": "destination",
        "14": "dhd",
        "15": "dhdPressButton",
        "16": "dial",
        "17": "enableTracking",
        "18": "gateRing",
        "19": "getAllJumpers",
        "20": "getAllRings",
        "21": "getAllStargates",
        "22": "getAllTransporters",
        "23": "getSignal",
        "24": "group",
        "25": "inbound",
        "26": "iris",
        "27": "irisActive",
        "28": "irisToggle",
        "29": "isInVehicle",
        "30": "listen",
        "31": "listenForCode",
        "32": "listenForRingTeleport",
        "33": "listenForTeleport",
        "34": "localgate",
        "35": "locationJammed",
        "36": "name",
        "37": "open",
        "38": "overloadPercent",
        "39": "overloadTime",
        "40": "overloading",
        "41": "private",
        "42": "radius",
        "43": "range",
        "44": "setAddress",
        "45": "setBlocked",
        "46": "setDestination",
        "47": "setGroup",
        "48": "setLocal",
        "49": "setName",
        "50": "setPrivate",
        "51": "setRadius",
        "52": "setRange",
        "53": "setSGC",
        "54": "setTrackTarget",
        "55": "setUsable",
        "56": "sgc",
        "57": "stop",
        "58": "stopCodeListen",
        "59": "stopTeleListen",
        "60": "target",
        "61": "teleport",
        "62": "transmit",
        "63": "unstable",
        "64": "usable",
        "overloading": {
          "ret": "True if the gate is being overloaded, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether the gate is being overloaded.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "getAllTransporters": {
          "ret": "A table containing a list of all Atlantis transporters on the map.",
          "server": true,
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Returns an array of all Atlantis transporters on the map.",
          "param": {
            "1": "filter",
            "filter": "(Optional) Filter function to filter the results."
          }
        },
        "setPrivate": {
          "ret": [
            "True if the private state was set, false otherwise.",
            "If the private state was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the private state of the Stargate.",
          "param": {
            "1": "gate",
            "2": "private",
            "private": "Boolean private.",
            "gate": "Stargate."
          }
        },
        "transmit": {
          "ret": [
            "True if the data was transimitted, false otherwise.",
            "If the data was not transmitted, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Transmits the given string data through the given Stargate's connection.",
          "param": {
            "1": "gate",
            "2": "data",
            "data": "String data to send through.",
            "gate": "Stargate."
          }
        },
        "setLocal": {
          "ret": [
            "True if the local state was set, false otherwise.",
            "If the local state was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the local state of the Stargate.",
          "param": {
            "1": "gate",
            "2": "local",
            "local": "Boolean local.",
            "gate": "Stargate."
          }
        },
        "getAllRings": {
          "ret": "A table containing a list of all ring bases on the map.",
          "server": true,
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Returns an array of all ring bases on the map.",
          "param": {
            "1": "filter",
            "filter": "(Optional) Filter function to filter the results."
          }
        },
        "localgate": {
          "ret": "True if the gate is set to local-only mode. False otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets the gate's local mode state.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "listen": {
          "server": true,
          "description": "Adds a listener function to the gate network. This is ran when a gate opens with an inbound connection, it passes the dialled gate.",
          "param": {
            "1": "callback",
            "2": "gate",
            "gate": "Optional Stargate to listen for specifically.",
            "callback": "Function to run when a gate opens. It's passed the opening gate."
          }
        },
        "getAllStargates": {
          "ret": "A table containing a list of all Stargates on the map.",
          "server": true,
          "returntypes": [
            "table<number,Stargate>"
          ],
          "description": "Returns an array of all Stargates on the map.",
          "param": {
            "1": "filter",
            "filter": "(Optional) Filter function to filter the results."
          }
        },
        "inbound": {
          "ret": "True if the gate currently has an inbound connection, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether the gate has an inbound connection.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "blocked": {
          "ret": "True if the gate is set to be blocked, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets the gate's blocked state (shows as red in the dialling menu).",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "unstable": {
          "ret": "True if the event horizon is unstable, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether the Stargate's event horizon is currently unstable.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "target": {
          "ret": "The gate that is connected to the given gate (either inbound or outbound).",
          "server": true,
          "returntypes": [
            "Stargate"
          ],
          "description": "Gets the gate connected to the given gate.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "destination": {
          "ret": "The name of the transporter that is set as the destination.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Returns the Atlantis transporter's destination.",
          "param": {
            "1": "transporter",
            "transporter": "Atlantis Transporter."
          }
        },
        "enableTracking": {
          "ret": [
            "True if tracking was enabled, false otherwise.",
            "If tracking was not enabled, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Enables projectile tracking on a puddle jumper or F-302.",
          "param": {
            "1": "ship",
            "2": "track",
            "track": "Boolean track.",
            "ship": "Jumper or F-302 entity."
          }
        },
        "listenForTeleport": {
          "server": true,
          "description": "Adds a listener function for an entity teleporting through a Stargate.",
          "param": {
            "1": "callback",
            "2": "gate",
            "gate": "Stargate to listen for entities teleporting to.",
            "callback": "Function to run when an entity teleports to the gate. It's passed the entity."
          }
        },
        "getAllJumpers": {
          "ret": "A table containing a list of all puddle jumpers on the map.",
          "server": true,
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Returns an array of all puddle jumpers on the map.",
          "param": {
            "1": "filter",
            "filter": "(Optional) Filter function to filter the results."
          }
        },
        "setUsable": {
          "ret": [
            "True if the usability was set, false otherwise.",
            "If the usability was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the usability of a ring base.",
          "param": {
            "1": "ring",
            "2": "usable",
            "usable": "Boolean usable.",
            "ring": "Ring base."
          }
        },
        "cfdEnabled": {
          "ret": "True if the CFD is enabled, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether a Call Forwarding Device is enabled.",
          "param": {
            "1": "cfd",
            "cfd": "CFD entity."
          }
        },
        "cfdEnable": {
          "ret": [
            "True if the CFD was enabled/disabled, false otherwise.",
            "If the CFD was not enabled/disabled, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Enables or disables a Call Forwarding Device.",
          "param": {
            "1": "cfd",
            "2": "enable",
            "enable": "Boolean enable.",
            "cfd": "CFD entity."
          }
        },
        "setDestination": {
          "ret": [
            "True if the destination was set, false otherwise.",
            "If the destination was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets an Atlantis transporter's destination name.",
          "param": {
            "1": "transporter",
            "2": "destination",
            "destination": "String destination name.",
            "transporter": "Atlantis Transporter."
          }
        },
        "listenForRingTeleport": {
          "server": true,
          "usage": "stargate.listenForRingTeleport( function( SourceRings, DestinationRings, Entities ) \n\tprint( SourceRings, \"teleported the following entities to\", DestinationRings, \":\" ) \n\tfor i = 1, #Entities do \n\t\tprint( Entities[ i ] ) \n\tend \nend, RingBase )",
          "description": "Adds a listener function for entities teleporting through a ring base.",
          "param": {
            "1": "callback",
            "2": "ringBase",
            "ringBase": "The ring base entity to listen for entities teleporting to.",
            "callback": "Function to run when entities teleport to the ring base. It's passed the source ring base entity, the destination ring base entity, and a table of entities that were teleported."
          }
        },
        "chevron": {
          "ret": "The currently dialled chevron number (between 0 to 9).",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets the gate's currently dialled chevron number.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "iris": {
          "ret": "The iris on the gate, if it exists.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Gets the iris on the gate, if it has one.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "setRadius": {
          "ret": [
            "True if the radius was set, false otherwise.",
            "If the radius was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the radius on an Asgard transporter.",
          "param": {
            "1": "transporter",
            "2": "radius",
            "radius": "The radius within which entities should be transported.",
            "transporter": "The Asgard transporter entity."
          }
        },
        "setAddress": {
          "ret": [
            "True if the address was set, false otherwise.",
            "If the address was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the address of the given gate.",
          "param": {
            "1": "gate",
            "2": "address",
            "address": "Address to set.",
            "gate": "Stargate."
          }
        },
        "name": {
          "ret": "The name of the gate/transporter, if it is visible. Otherwise an empty string.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets the gate or Atlantis transporter's name, if it is visible.",
          "param": {
            "1": "gate",
            "gate": "Stargate or Atlantis transporter."
          }
        },
        "stopTeleListen": {
          "server": true,
          "description": "Removes a listener for teleporting entities.",
          "param": {
            "1": "function",
            "2": "gate",
            "gate": "Stargate to stop listening to.",
            "function": "Function to remove."
          }
        },
        "radius": {
          "ret": "The radius in Hammer units for the given transporter.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the set radius of the given Asgard transporter.",
          "param": {
            "1": "transporter",
            "transporter": "The Asgard transporter entity."
          }
        },
        "usable": {
          "ret": "True if the ring base is usable, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets the usability of a ring base.",
          "param": {
            "1": "ring",
            "ring": "Ring base."
          }
        },
        "listenForCode": {
          "server": true,
          "description": "Adds a listener function for an iris code received.",
          "param": {
            "1": "callback",
            "2": "gate",
            "gate": "Stargate to listen for codes received.",
            "callback": "Function to run when the code is received. It's passed the given code."
          }
        },
        "locationJammed": {
          "ret": "True if the given location is jammed, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Determines if the given location is jammed.",
          "param": {
            "1": "location",
            "2": "player",
            "player": "(Optional) Player to check jamming against. Pass false to ignore any immunity.",
            "location": "Vector location to check."
          }
        },
        "getSignal": {
          "ret": "The string value for the signal receieved.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets the currently received signal from the given Stargate.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "address": {
          "ret": "The address of the gate or ring base, if it is visible. Otherwise an empty string.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets the gate or ring base address if it is visible.",
          "param": {
            "1": "gate",
            "gate": "Stargate or ring base to get the address from."
          }
        },
        "gateRing": {
          "ret": "The entity that represents the ring on the gate, if it exists.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Gets the ring entity on SG1, infinity, movie and universe gates.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "accessList": {
          "ret": [
            "True if the access list is applied.",
            "If the access list is not applied, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Restricts access to a gate to players/Steam IDs in the given list.",
          "param": {
            "1": "gate",
            "2": "list",
            "list": "A table of players and/or Steam IDs to allow. Anyone else is blocked.",
            "gate": "The stargate to restrict access to."
          }
        },
        "group": {
          "ret": "The gate's group, if visible. Otherwise an empty string.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets the gate's group, if it is visible.",
          "param": {
            "1": "gate",
            "gate": "Stargate to get the group from."
          }
        },
        "irisToggle": {
          "ret": [
            "True if the iris was toggled, false otherwise.",
            "If the iris was not toggled, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Toggles the given iris.",
          "param": {
            "1": "iris",
            "iris": "Iris entity."
          }
        },
        "range": {
          "ret": "The ring base's range in Hammer units.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets the range of a ring base.",
          "param": {
            "1": "ring",
            "ring": "Ring base."
          }
        },
        "irisActive": {
          "ret": "True if the iris is active, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given iris is active.",
          "param": {
            "1": "iris",
            "iris": "Iris entity."
          }
        },
        "dial": {
          "ret": [
            "True if the gate was dialled, false otherwise.",
            "If the gate was not dialled, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Dials the given gate to another.",
          "param": {
            "1": "gate",
            "2": "target",
            "3": "mode",
            "mode": "The mode with which to dial. One of the stargate.DIAL_MODE_* enum values.",
            "target": "String address to dial to.",
            "gate": "Stargate to dial from."
          }
        },
        "setRange": {
          "ret": [
            "True if the range was set, false otherwise.",
            "If the range was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the range of a ring base.",
          "param": {
            "1": "ring",
            "2": "range",
            "range": "Range to set.",
            "ring": "Ring base."
          }
        },
        "close": {
          "ret": [
            "True if the gate was closed, false otherwise.",
            "If the gate was not closed, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Closes the given Stargate.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "dhdPressButton": {
          "ret": [
            "True if the button was pressed, false otherwise.",
            "If the button was not pressed, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Emulates a button press on the given DHD.",
          "param": {
            "1": "dhd",
            "2": "button",
            "dhd": "DHD entity.",
            "button": "String button to press, e.g \"A\"."
          }
        },
        "private": {
          "ret": "True if the gate/transporter is private (and thus the address/group/name is hidden if not the owner), false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets the gate or Atlantis transporter's private state.",
          "param": {
            "1": "gate",
            "gate": "or Atlantis transporter."
          }
        },
        "chevrons": {
          "ret": "A string containing the currently active chevrons.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets the gate's currently activated chevrons as a string. Emulates the \"Chevrons [STRING]\" output.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "setSGC": {
          "ret": [
            "True if the SGC mode was set, false otherwise.",
            "If the SGC mode was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the SGC mode of the given Stargate.",
          "param": {
            "1": "gate",
            "2": "sgc",
            "sgc": "Boolean SGC mode.",
            "gate": "Stargate."
          }
        },
        "active": {
          "ret": "True if the gate or ring base is currently active, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether the gate or ring base is active.",
          "param": {
            "1": "gate",
            "gate": "Stargate or ring base."
          }
        },
        "isInVehicle": {
          "ret": [
            "True if the player is in a vehicle, false otherwise.",
            "If the player is in a vehicle, the entity they are currently in."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "Entity"
          ],
          "description": "Returns whether the given player is in a vehicle.",
          "param": {
            "1": "ply",
            "ply": "Player to check."
          }
        },
        "canDial": {
          "ret": [
            "True if it can be dialled, false otherwise.",
            "If the target cannot be dialled, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Gets whether the given gate can dial the given target gate.",
          "param": {
            "1": "gate",
            "2": "target",
            "target": "The gate being dialled.",
            "gate": "The gate that will dial."
          }
        },
        "stopCodeListen": {
          "server": true,
          "description": "Removes a listener for iris codes.",
          "param": {
            "1": "function",
            "2": "gate",
            "gate": "Stargate to stop listening to.",
            "function": "Function to remove."
          }
        },
        "teleport": {
          "ret": [
            "True if the teleport was successfully triggered, false otherwise.",
            "If the teleport was not triggered, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Teleports using either an Asgard or Atlantis transporter. Functionality is different for each.",
          "param": {
            "1": "transporter",
            "2": "origin",
            "3": "dest",
            "4": "sendAll",
            "sendAll": "If using an Asgard transporter, boolean flag to send objects as well as players.",
            "dest": "If using an Asgard transporter, the destination vector to teleport to.",
            "origin": "If using an Asgard transporter, the origin vector to teleport from.",
            "transporter": "The transporter entity to use."
          }
        },
        "addressList": {
          "ret": "A table containing a list of gate addresses that are available to dial.",
          "server": true,
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Gets a list of diallable addresses from the gate.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "asuranBeam": {
          "ret": "True if an Asuran weapon is being fired through the gate, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether an Asuran weapon is firing through the gate.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "open": {
          "ret": "True if the gate is open, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether the gate is open.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "dhd": {
          "ret": "The DHD associated with the gate, if it exists.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Gets the DHD on the gate if it has one.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "setBlocked": {
          "ret": [
            "True if the blocked state was set, false otherwise.",
            "If the blocked state was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the blocked state of the given Stargate.",
          "param": {
            "1": "gate",
            "2": "blocked",
            "blocked": "Boolean blocked.",
            "gate": "Stargate."
          }
        },
        "overloadPercent": {
          "ret": "A number between 0 and 100 indicating how much the gate has been overloaded.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets the percentage the given gate has been overloaded.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "setName": {
          "ret": [
            "True if the name was set, false otherwise.",
            "If the name was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the name of the given Stargate.",
          "param": {
            "1": "gate",
            "2": "name",
            "name": "Name to set.",
            "gate": "Stargate."
          }
        },
        "overloadTime": {
          "ret": "The time in seconds until the gate will overload.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets the time remaining before overloading.",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        },
        "stop": {
          "server": true,
          "description": "Removes a gate network listener.",
          "param": {
            "1": "function",
            "2": "gate",
            "gate": "Stargate to stop listening to if one was set.",
            "function": "Function to remove."
          }
        },
        "setTrackTarget": {
          "ret": [
            "True if the track target was set, false otherwise.",
            "If the track target was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the tracking target on a puddle jumper or F-302.",
          "param": {
            "1": "ship",
            "2": "pos",
            "pos": "Position.",
            "ship": "Jumper or F-302 entity."
          }
        },
        "setGroup": {
          "ret": [
            "True if the group was set, false otherwise.",
            "If the group was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the group of the given Stargate.",
          "param": {
            "1": "gate",
            "2": "group",
            "group": "Group to set.",
            "gate": "Stargate."
          }
        },
        "sgc": {
          "ret": "True if the gate is set to use SGC dialling mode, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets the gate's SGC mode state (applicable to milky-way gates only).",
          "param": {
            "1": "gate",
            "gate": "Stargate."
          }
        }
      },
      "description": "Stargate library for interfacing with the Carter's Addon Pack.",
      "fields": {
        "1": "DIAL_MODE_SLOW",
        "2": "DIAL_MODE_FAST",
        "3": "DIAL_MODE_NOX",
        "DIAL_MODE_SLOW": {
          "description": "Slow dialling mode (for use with Stargate:dial()).",
          "server": true
        },
        "DIAL_MODE_FAST": {
          "description": "Fast dialling mode (for use with Stargate:dial()).",
          "server": true
        },
        "DIAL_MODE_NOX": {
          "description": "Nox dialling mode (for use with Stargate:dial()).",
          "server": true
        }
      },
      "server": true
    },
    "find": {
      "functions": {
        "1": "all",
        "2": "allPlayers",
        "3": "alongRay",
        "4": "byClass",
        "5": "byIndex",
        "6": "byModel",
        "7": "inBox",
        "8": "inCone",
        "9": "inSphere",
        "10": "playerByName",
        "inSphere": {
          "ret": "An array of found entities",
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Finds entities in a sphere",
          "param": {
            "1": "center",
            "2": "radius",
            "3": "filter",
            "radius": "Sphere radius",
            "center": "Center of the sphere",
            "filter": "(Optional) Function to filter results."
          }
        },
        "allPlayers": {
          "ret": "An array of found entities",
          "returntypes": [
            "table<number,Player>"
          ],
          "description": "Finds all players (including bots)",
          "param": {
            "1": "filter",
            "filter": "(Optional) Function to filter results."
          }
        },
        "inCone": {
          "ret": "An array of found entities",
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Finds entities in a cone",
          "param": {
            "1": "pos",
            "2": "dir",
            "3": "distance",
            "4": "cosAngle",
            "5": "filter",
            "dir": "The direction to project the cone",
            "cosAngle": "The cosine of the angle of the cone (between 0 and 1, where 1 is 0 and 0 is 180.)",
            "distance": "The length to project the cone",
            "filter": "(Optional) Function to filter results.",
            "pos": "The cone vertex position"
          }
        },
        "inBox": {
          "ret": "An array of found entities",
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Finds entities in a box",
          "param": {
            "1": "min",
            "2": "max",
            "3": "filter",
            "max": "Top corner",
            "min": "Bottom corner",
            "filter": "(Optional) Function to filter results."
          }
        },
        "byIndex": {
          "ret": "The matching entity if it exists, or nil otherwise.",
          "returntypes": [
            "Entity"
          ],
          "description": "Finds an entity by its index.",
          "param": {
            "1": "index",
            "index": "The entity index."
          }
        },
        "playerByName": {
          "ret": "The best match found or nil.",
          "returntypes": [
            "Player"
          ],
          "description": "Finds a player by name.",
          "param": {
            "1": "name",
            "name": "Name to find."
          }
        },
        "byClass": {
          "ret": "An array of found entities",
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Finds entities by class name",
          "param": {
            "1": "class",
            "2": "filter",
            "filter": "(Optional) Function to filter results.",
            "class": "The class name"
          }
        },
        "all": {
          "ret": "An array of found entities",
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Finds all entitites",
          "param": {
            "1": "filter",
            "filter": "(Optional) Function to filter results."
          }
        },
        "byModel": {
          "ret": "An array of found entities",
          "returntypes": [
            "table<number,Entity>"
          ],
          "usage": "-- Find all entities whose model path starts with \"models/props_borealis\" \nlocal Ents = find.byModel( \"models/props_borealis/*\" ) \n-- Find all entities whose model is exactly \"models/props_borealis/bluebarrel001.mdl\" \nlocal Barrels = find.byModel( \"models/props_borealis/bluebarrel001.mdl\" )",
          "description": "Finds entities by their model path. \nThis supports a single wildcard at the end of the path to find all entities whose model starts with the given path.",
          "param": {
            "1": "modelPath",
            "2": "filter",
            "filter": "(Optional) Function to filter results.",
            "modelPath": "The model file to search for, optionally with a wildcard at the end."
          }
        },
        "alongRay": {
          "ret": "An array of found entities.",
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Finds all entities intersecting the given ray.",
          "param": {
            "1": "startPos",
            "2": "endPos",
            "3": "mins",
            "4": "maxs",
            "5": "filter",
            "endPos": "The end position of the ray.",
            "filter": "(Optional) Function to filter results.",
            "maxs": "(Optional) Sets the maxs corner of the axis-aligned box to test entities with (assuming mins was provided).",
            "mins": "(Optional) If provided, sets the mins corner of an axis-aligned box that will be used to test entities along the ray.",
            "startPos": "The starting position of the ray."
          }
        }
      },
      "description": "Find library. Finds entities in various shapes.",
      "client": true,
      "server": true
    },
    "system": {
      "functions": {
        "1": "hasFocus",
        "2": "isLinux",
        "3": "isOSX",
        "4": "isWindows",
        "hasFocus": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns true if the game window currently has focus. This may only work on Windows."
        },
        "isLinux": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns true if the client is running on Linux."
        },
        "isWindows": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns true if the client is running on Windows."
        },
        "isOSX": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns true if the client is running on Mac OS X."
        }
      },
      "description": "System library.",
      "client": true
    },
    "hud": {
      "functions": {
        "1": "getChatBoxMode",
        "2": "getChatBoxPos",
        "3": "getChatBoxSize",
        "4": "getLinkedPlayers",
        "5": "getLinkedVehicle",
        "6": "isChatBoxOpen",
        "7": "isLinked",
        "8": "isLinkedToVehicle",
        "9": "isPlayerLinked",
        "10": "link",
        "11": "unlink",
        "12": "unlinkPlayer",
        "unlinkPlayer": {
          "server": true,
          "paramtypes": {
            "ply": "Player"
          },
          "description": "Unlinks the given player from the current HUD instance.",
          "param": {
            "1": "ply",
            "ply": "The player to unlink."
          }
        },
        "link": {
          "description": "Links the chip owner to the current HUD instance. \nOnly works on the chip owner. Cannot link other players."
        },
        "isChatBoxOpen": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns true if the chatbox is currently open, false otherwise. \nThis requires the READ_CHATBOX_STATE permission."
        },
        "getChatBoxSize": {
          "ret": [
            "The width of the chatbox.",
            "The height of the chatbox."
          ],
          "returntypes": [
            "number",
            "number"
          ],
          "client": true,
          "description": "Returns the size of the chatbox. \nIf the chatbox has not yet been opened, this will return nil. \nThis requires the READ_CHATBOX_STATE permission."
        },
        "getLinkedVehicle": {
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Returns the vehicle the HUD is linked to, if it has been linked."
        },
        "getChatBoxPos": {
          "ret": [
            "The x co-ordinate of the chatbox position.",
            "The y co-ordinate of the chatbox position."
          ],
          "returntypes": [
            [
              "number",
              "nil"
            ],
            "number"
          ],
          "client": true,
          "description": "Returns the screen position of the chatbox. \nIf the chatbox has not yet been opened, this will return nil. \nThis requires the READ_CHATBOX_STATE permission."
        },
        "isLinked": {
          "ret": "True if the local player is linked to the HUD this instance is running on.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Determines if the local player is linked to the HUD."
        },
        "getChatBoxMode": {
          "returntypes": [
            [
              "string",
              "nil"
            ]
          ],
          "client": true,
          "description": "Returns the current mode the chatbox is in. \nIf the chatbox has not yet been opened, this will return nil. \nThis requires the READ_CHATBOX_STATE permission."
        },
        "isPlayerLinked": {
          "server": true,
          "paramtypes": {
            "ply": "Player"
          },
          "description": "Returns true if the given player is linked to the current HUD instance, false otherwise.",
          "param": {
            "1": "ply",
            "ply": "The player to check."
          }
        },
        "isLinkedToVehicle": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given vehicle is linked to the HUD.",
          "param": {
            "1": "vehicle",
            "vehicle": "The vehicle entity to check."
          }
        },
        "getLinkedPlayers": {
          "server": true,
          "returntypes": [
            "table<number,Player>"
          ],
          "description": "Returns a list of all players that are currently linked to the current HUD instance."
        },
        "unlink": {
          "description": "Unlinks the chip owner/local player from the current HUD instance."
        }
      },
      "description": "HUD library. Used for HUD specific functionality."
    },
    "globaltables": {
      "functions": [
      ],
      "description": "Cross-instance tables",
      "client": true,
      "tables": {
        "1": "global",
        "2": "player",
        "global": {
          "description": "Global table shared by all instances on the same side. \nNote that values written will persist only until the player who wrote them disconnects."
        },
        "player": {
          "description": "Player-unique global table."
        }
      },
      "server": true
    },
    "time": {
      "functions": {
        "1": "curTime",
        "2": "frameTime",
        "3": "realFrameTime",
        "4": "realTime",
        "5": "sysTime",
        "sysTime": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the system time, a highly precise value useful for timing operations."
        },
        "realTime": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the time since the map first loaded."
        },
        "curTime": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the current synchronised game time."
        },
        "frameTime": {
          "returntypes": [
            "number"
          ],
          "description": "Returns time between frames on the client and ticks on the server."
        },
        "realFrameTime": {
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the time between frames. \nThe difference between this and frameTime() is that this is not affected by host_timescale."
        }
      },
      "description": "Deals with time and timers.",
      "client": true,
      "server": true
    },
    "base64": {
      "functions": {
        "1": "decode",
        "2": "encode",
        "encode": {
          "ret": "The encoded string.",
          "returntypes": [
            "string"
          ],
          "description": "Encodes the given string into base 64.",
          "param": {
            "1": "string",
            "string": "The string to be encoded."
          }
        },
        "decode": {
          "ret": "The decoded string.",
          "returntypes": [
            "string"
          ],
          "description": "Decodes the given string from base 64.",
          "param": {
            "1": "string",
            "string": "The string to be decoded."
          }
        }
      },
      "description": "Base 64 encoding library."
    },
    "spacebuild": {
      "functions": {
        "1": "warp",
        "warp": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Activates the given warp drive and sends it to the given destination.",
          "param": {
            "1": "drive",
            "2": "dest",
            "dest": "Vector destination.",
            "drive": "Warp drive entity."
          }
        }
      },
      "description": "'Spacebuild' library for interfacing with SBEP/Stargazer.",
      "server": true
    },
    "constraint": {
      "functions": {
        "1": "findConstraintEntity",
        "2": "getAllConstrainedEntities",
        "3": "getConstrainedEntities",
        "4": "hasConstraints",
        "5": "noCollide",
        "6": "removeAll",
        "7": "removeConstraints",
        "8": "weld",
        "removeConstraints": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "type": "string",
            "entity": "Entity"
          },
          "description": "Removes all constraints of the given type from the given entity.",
          "param": {
            "1": "entity",
            "2": "type",
            "type": "The type of constraint to remove, e.g. \"Weld\", \"NoCollide\".",
            "entity": "The entity to remove constraints from."
          }
        },
        "getConstrainedEntities": {
          "ret": "An array of all entities that are directly constrained to the provided entity.",
          "server": true,
          "returntypes": [
            "table<number,Entity>"
          ],
          "paramtypes": {
            "entity": "Entity"
          },
          "description": "Gets all constrained entities directly constrained to the given entity. This is not recursive.",
          "param": {
            "1": "entity",
            "entity": "The entity to get constrained entities for."
          }
        },
        "weld": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "deleteEnt1OnBreak": "boolean?",
            "noCollide": "boolean?",
            "forceLimit": "number?",
            "bone2": "number?",
            "bone1": "number?",
            "entity2": "Entity",
            "entity1": "Entity"
          },
          "description": "Creates a weld constraint between two entities.",
          "param": {
            "1": "entity1",
            "2": "entity2",
            "3": "bone1",
            "4": "bone2",
            "5": "forceLimit",
            "6": "noCollide",
            "7": "deleteEnt1OnBreak",
            "deleteEnt1OnBreak": "Sets whether to delete the first entity when the weld breaks.",
            "noCollide": "Whether to make the weld ignore collisions between the two entities.",
            "forceLimit": "Limit on the weld before it breaks, default is 0 (no limit).",
            "bone2": "Bone on the second entity, defaults to 0.",
            "bone1": "Bone on the first entity, defaults to 0.",
            "entity2": "Second entity.",
            "entity1": "First entity."
          }
        },
        "removeAll": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "entity": "Entity"
          },
          "description": "Removes all constraints from the given entity, regardless of type.",
          "param": {
            "1": "entity",
            "entity": "The entity to remove constraints from."
          }
        },
        "findConstraintEntity": {
          "server": true,
          "returntypes": [
            "Entity"
          ],
          "paramtypes": {
            "type": "string",
            "entity": "Entity"
          },
          "description": "Returns the first matching entity that is constrained to this one by the given constraint type.",
          "param": {
            "1": "entity",
            "2": "type",
            "type": "The type of constraint, e.g. \"Weld\", \"NoCollide\".",
            "entity": "The entity to get the constrained entity for."
          }
        },
        "getAllConstrainedEntities": {
          "ret": "An array of all entities that are constrained and passed the filter if it was provided.",
          "server": true,
          "returntypes": [
            "table<number,Entity>"
          ],
          "paramtypes": {
            "filter": "function?",
            "entity": "Entity"
          },
          "description": "Gets a table of all constrained entities, including those constrained indirectly through other entities.",
          "param": {
            "1": "entity",
            "2": "filter",
            "filter": "(Optional) Filter function, return true to keep the entity, false to discard it.",
            "entity": "The entity to get constrained entities for."
          }
        },
        "noCollide": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "bone2": "number?",
            "bone1": "number?",
            "entity2": "Entity",
            "entity1": "Entity"
          },
          "description": "Creates a no-collide constraint between two entities.",
          "param": {
            "1": "entity1",
            "2": "entity2",
            "3": "bone1",
            "4": "bone2",
            "bone2": "Bone on the second entity, defaults to 0.",
            "bone1": "Bone on the first entity, defaults to 0.",
            "entity2": "Second entity.",
            "entity1": "First entity."
          }
        },
        "hasConstraints": {
          "ret": "True if the entity is constrained to at least one other entity, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "paramtypes": {
            "entity": "Entity"
          },
          "description": "Returns whether the given entity has any constraints.",
          "param": {
            "1": "entity",
            "entity": "The entity to check for constraints."
          }
        }
      },
      "description": "Constraint library.",
      "server": true
    },
    "http": {
      "functions": {
        "1": "cooldownTime",
        "2": "fetch",
        "3": "nextRequest",
        "4": "post",
        "post": {
          "ret": [
            "True if the request fired, false otherwise.",
            "If the request did not fire, the reason why."
          ],
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Performs a POST request. \nRequires the SEND_HTTP_REQUESTS permission to be granted when used on the client.",
          "param": {
            "1": "url",
            "2": "params",
            "3": "onSuccess",
            "4": "onFail",
            "onFail": "Function to run on failure. It's passed an error message explaining the failure.",
            "onSuccess": "The function to run on success. It's passed the response body, a table of header values, and the response code.",
            "params": "The table of parameters of the POST request.",
            "url": "The URL to request."
          }
        },
        "nextRequest": {
          "returntypes": [
            "number"
          ],
          "description": "Returns when you can next run a request."
        },
        "cooldownTime": {
          "returntypes": [
            "number"
          ],
          "description": "Returns how long until the next request is allowed."
        },
        "fetch": {
          "ret": [
            "True if the request fired, false otherwise.",
            "If the request did not fire, the reason why."
          ],
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Performs a GET request. \nRequires the SEND_HTTP_REQUESTS permission to be granted when used on the client side.",
          "param": {
            "1": "url",
            "2": "onSuccess",
            "3": "onFail",
            "onFail": "Function to run on failure. It's passed an error message explaining the failure.",
            "onSuccess": "Function to run on success. It's passed the response body, a table of header values, and the response code.",
            "url": "The URL to request."
          }
        }
      },
      "description": "HTTP library, allows for GET and POST requests.",
      "client": true,
      "server": true
    },
    "hook": {
      "functions": {
        "1": "add",
        "2": "remove",
        "3": "run",
        "remove": {
          "usage": "hook.remove( \"input\", \"DetectWireInputs\" )",
          "server": true,
          "client": true,
          "description": "Remove a hook",
          "param": {
            "1": "hookName",
            "2": "name",
            "name": "The unique name for this hook.",
            "hookName": "The hook name."
          }
        },
        "run": {
          "usage": "local Result = hook.run( \"myevent\", \"Some\", \"arguments\", \"yay\", 1, 2, 3 )",
          "returntypes": [
            "Any..."
          ],
          "server": true,
          "client": true,
          "description": "Run a hook",
          "param": {
            "1": "hookName",
            "2": "...",
            "...": "Arguments to pass to listeners.",
            "hookName": "The hook name."
          }
        },
        "add": {
          "usage": "hook.add( \"input\", \"DetectWireInputs\", function( Input, Value ) \n\t-- Do stuff here... \nend )",
          "description": "Registers a hook callback.",
          "param": {
            "1": "hookName",
            "2": "name",
            "3": "func",
            "hookName": "The hook name.",
            "func": "A callback function to run for this hook.",
            "name": "A unique identifier for this callback."
          }
        }
      },
      "description": "Deals with hooks",
      "client": true,
      "server": true
    },
    "console": {
      "functions": {
        "1": "error",
        "2": "info",
        "3": "warn",
        "error": {
          "description": "Writes an error to the console.",
          "param": {
            "1": "error",
            "2": "traceback",
            "traceback": "Optional stack traceback.",
            "error": "The error message."
          }
        },
        "info": {
          "description": "Writes a plain information message to the editor console for this entity. \nFormatting arguments are equivalent to console.info( string.format( message, ... ) )",
          "param": {
            "1": "message",
            "2": "...",
            "...": "Optional formatting arguments.",
            "message": "The message to write."
          }
        },
        "warn": {
          "description": "Writes a plain warning message to the editor console for this entity. \nFormatting arguments are equivalent to console.warn( string.format( message, ... ) )",
          "param": {
            "1": "message",
            "2": "...",
            "...": "Optional formatting arguments.",
            "message": "The message to write."
          }
        }
      },
      "description": "Console library. Allows for writing to the editor console."
    },
    "utf8": {
      "functions": [
      ],
      "description": "GLua's utf8 library.",
      "externaldocs": "https://wiki.facepunch.com/gmod/utf8"
    },
    "emitter": {
      "functions": {
        "1": "setDrawEverywhere",
        "setDrawEverywhere": {
          "client": true,
          "description": "Sets whether rendered elements on the emitter this instance is running on are visible everywhere. \nIf disabled, emitters in unloaded regions and emitters that are flagged with no-draw will not render. \nBy default, this is enabled.",
          "param": {
            "1": "drawEverywhere",
            "drawEverywhere": "Whether to draw regardless of emitter visibility/proximity."
          }
        }
      },
      "description": "Emitter library. Used for emitter specific functionality.",
      "client": true
    },
    "Color": {
      "description": "Colour helper functions.",
      "functions": {
        "1": "fromHSV",
        "2": "fromHex",
        "fromHSV": {
          "ret": "A new colour table with values converted into RGB from HSV.",
          "description": "Creates a colour object from the given HSV values",
          "returntypes": [
            "Color"
          ],
          "param": {
            "1": "h",
            "2": "s",
            "3": "v",
            "4": "a",
            "a": "(Optional) Alpha value, defaults to 255.",
            "v": "Value, 0 - 1",
            "s": "Saturation, 0 - 1",
            "h": "Hue, 0 - 1"
          }
        },
        "fromHex": {
          "ret": "A new colour table matching the hex value.",
          "description": "Creates a colour from a single hexadecimal value, either a string or a number.",
          "returntypes": [
            "Color"
          ],
          "param": {
            "1": "hex",
            "2": "alpha",
            "alpha": "(Optional) Alpha value, defaults to 255.",
            "hex": "Either a string of the form \"#FFFFFF\", or a number of the form 0xFFFFFF"
          }
        }
      }
    },
    "json": {
      "functions": {
        "1": "deserialize",
        "2": "serialize",
        "deserialize": {
          "ret": "The JSON data as a table, or nil if it was not valid JSON.",
          "returntypes": [
            "table"
          ],
          "description": "Deserialises a JSON encoded string. Returns the deserialised table.",
          "param": {
            "1": "string",
            "string": "A string of JSON encoded data."
          }
        },
        "serialize": {
          "ret": "A JSON string representing the table.",
          "returntypes": [
            "string"
          ],
          "description": "Serialises a table using JSON. Returns the serialised string.",
          "param": {
            "1": "table",
            "2": "prettyPrint",
            "prettyPrint": "Whether to pretty-print the output.",
            "table": "The table to be serialised."
          }
        }
      },
      "description": "JSON library.",
      "client": true,
      "server": true
    },
    "npc": {
      "functions": [
      ],
      "description": "NPC library for altering NPC behaviour.",
      "fields": {
        "1": "WEAPON_PROFICIENCY_POOR",
        "2": "WEAPON_PROFICIENCY_AVERAGE",
        "3": "WEAPON_PROFICIENCY_GOOD",
        "4": "WEAPON_PROFICIENCY_VERY_GOOD",
        "5": "WEAPON_PROFICIENCY_PERFECT",
        "6": "D_HT",
        "7": "D_FR",
        "8": "D_LI",
        "9": "D_NU",
        "WEAPON_PROFICIENCY_GOOD": {
          "description": "Good weapon proficiency (i.e. will sometimes miss).",
          "server": true
        },
        "D_HT": {
          "description": "Represents a hate relationship (to be used with NPC:setRelationship()).",
          "server": true
        },
        "WEAPON_PROFICIENCY_VERY_GOOD": {
          "description": "Very good weapon proficiency (i.e. will rarely miss).",
          "server": true
        },
        "WEAPON_PROFICIENCY_AVERAGE": {
          "description": "Average weapon proficiency (i.e. will miss roughly half the time).",
          "server": true
        },
        "WEAPON_PROFICIENCY_POOR": {
          "description": "Poor weapon proficiency (i.e. will miss most of the time).",
          "server": true
        },
        "D_LI": {
          "description": "Represents a like relationship (to be used with NPC:setRelationship()).",
          "server": true
        },
        "D_NU": {
          "description": "Represents a neutral relationship (to be used with NPC:setRelationship()).",
          "server": true
        },
        "WEAPON_PROFICIENCY_PERFECT": {
          "description": "Perfect weapon proficiency (i.e. will almost never miss).",
          "server": true
        },
        "D_FR": {
          "description": "Represents a fear relationship (to be used with NPC:setRelationship()).",
          "server": true
        }
      },
      "server": true
    },
    "chat": {
      "functions": {
        "1": "botSay",
        "2": "botSayAlliance",
        "3": "canSay",
        "4": "canTell",
        "5": "interval",
        "6": "listen",
        "7": "nextSay",
        "8": "nextTell",
        "9": "say",
        "10": "stop",
        "11": "tell",
        "botSayAlliance": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Displays a message in the chat with a prefix to all alliance members.",
          "param": {
            "1": "prefix",
            "2": "...",
            "...": "Colour, string, colour...",
            "prefix": "The prefix text to display in [] brackets."
          }
        },
        "canTell": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Returns whether the given player can be sent a direct message.",
          "param": {
            "1": "target",
            "target": "The player to check."
          }
        },
        "botSay": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Displays a message in the chat with a prefix to all faction members.",
          "param": {
            "1": "prefix",
            "2": "...",
            "...": "Colour, string, colour...",
            "prefix": "The prefix text to display in [] brackets."
          }
        },
        "listen": {
          "server": true,
          "description": "Registers a new listener function to chat. Return true in your callback to hide your own chat.",
          "param": {
            "1": "callback",
            "2": "ply",
            "ply": "(Optional) The specific player you want to listen for. Pass nil to listen to all chat.",
            "callback": "The function that will listen to chat, receives chat message, player."
          }
        },
        "tell": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Displays a message to a specific player. Same arguments as chat.say after the player argument.",
          "param": {
            "1": "target",
            "2": "...",
            "...": "Colour, string, colour...",
            "target": "The player to send the message to."
          }
        },
        "stop": {
          "server": true,
          "description": "Removes a listener.",
          "param": {
            "1": "callback",
            "2": "ply",
            "ply": "(Optional) The player that you are no longer listening to. Pass nil if you did so in chat.listen().",
            "callback": "The function getting removed, should be the same one added by chat.listen()."
          }
        },
        "say": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Displays a message to all players in your faction. Takes colour, string, colour, string...",
          "param": {
            "1": "...",
            "...": "Colour, string, colour..."
          }
        },
        "interval": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the enforced delay (in seconds) between chat messages through chat.say, chat.botSay etc."
        },
        "canSay": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Returns whether a chat message through chat.say, chat.botSay etc. can be sent."
        },
        "nextTell": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the time until the next tell is allowed (in seconds). Pass a player to get their specific cooldown.",
          "param": {
            "1": "target",
            "target": "(Optional) Target player to get the cooldown for."
          }
        },
        "nextSay": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the time left (in seconds) until the next chat message through chat.say, chat.botSay etc. can be sent."
        }
      },
      "description": "Chat functions",
      "server": true
    },
    "channels": {
      "functions": {
        "1": "canSend",
        "2": "listen",
        "3": "listenPrivate",
        "4": "remove",
        "5": "removePrivate",
        "6": "send",
        "7": "sendPrivate",
        "removePrivate": {
          "description": "Removes a listener from your private channel.",
          "param": {
            "1": "id",
            "id": "The ID value given to channels.listenPrivate()."
          }
        },
        "remove": {
          "server": true,
          "client": true,
          "description": "Removes a listener.",
          "param": {
            "1": "channelName",
            "2": "id",
            "id": "The ID value given to channels.listen().",
            "channelName": "The name of the channel the callback was listening to."
          }
        },
        "listenPrivate": {
          "server": true,
          "client": true,
          "description": "Adds a listener to your private channel.",
          "param": {
            "1": "id",
            "2": "callback",
            "callback": "The function to run when this channel receives data. It is passed the entity calling, and data sent.",
            "id": "The ID of the callback, used later to remove it."
          }
        },
        "canSend": {
          "ret": "True if you can immediately send a channel message, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the current instance is permitted to send a channel message. \nChannels are rate limited per tick and per instance."
        },
        "send": {
          "server": true,
          "client": true,
          "description": "Sends data to the given channel.",
          "param": {
            "1": "channelName",
            "2": "...",
            "channelName": "The channel to send data to."
          }
        },
        "sendPrivate": {
          "server": true,
          "client": true,
          "description": "Sends data to your private channel.",
          "param": [
            "..."
          ]
        },
        "listen": {
          "server": true,
          "client": true,
          "description": "Adds a listener to the given channel.",
          "param": {
            "1": "channelName",
            "2": "id",
            "3": "callback",
            "channelName": "The name of the channel to listen to.",
            "callback": "The function to run when this channel receives data. It is passed the entity calling, and data sent.",
            "id": "The ID of the callback, used later to remove it."
          }
        }
      },
      "description": "Channels Library for sending data across server->server or client->client instances.",
      "client": true,
      "server": true
    },
    "propprotection": {
      "functions": {
        "1": "isAllowedForEntity",
        "2": "isAllowedForPlayer",
        "isAllowedForEntity": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the given action is permitted against the given entity for the owner of this instance, false otherwise.",
          "param": {
            "1": "ent",
            "2": "accessType",
            "accessType": "The type of access to check (one of propprotection.ACCESS_*).",
            "ent": "The entity to query access against."
          }
        },
        "isAllowedForPlayer": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the given action is permitted against all entities owned by the given player for the owner of this instance, false otherwise.",
          "param": {
            "1": "ply",
            "2": "accessType",
            "accessType": "The type of access to check (one of propprotection.ACCESS_*).",
            "ply": "The player to query access against."
          }
        }
      },
      "description": "Prop protection library.",
      "fields": {
        "1": "ACCESS_DUPLICATOR",
        "2": "ACCESS_GRAVITY_GUN",
        "3": "ACCESS_PHYSGUN",
        "4": "ACCESS_TOOLGUN",
        "5": "ACCESS_USE",
        "ACCESS_TOOLGUN": {
          "description": "Permission to use the toolgun with an entity (excluding the duplicator tool).",
          "server": true
        },
        "ACCESS_USE": {
          "description": "Permission to use an entity (pressing the use key).",
          "server": true
        },
        "ACCESS_GRAVITY_GUN": {
          "description": "Permission to use the gravity gun with an entity.",
          "server": true
        },
        "ACCESS_DUPLICATOR": {
          "description": "Permission to use the duplicator tool with an entity.",
          "server": true
        },
        "ACCESS_PHYSGUN": {
          "description": "Permission to use the physgun with an entity.",
          "server": true
        }
      },
      "server": true
    },
    "ents": {
      "functions": {
        "1": "owner",
        "2": "player",
        "3": "self",
        "self": {
          "ret": "Entity running the code.",
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the entity representing a processor that this script is running on. \nMay be nil"
        },
        "owner": {
          "ret": "Owner of the entity running the code.",
          "returntypes": [
            "Player"
          ],
          "description": "Returns whoever created the entity running the code."
        },
        "player": {
          "ret": "Either the owner (server) or the local player (client)",
          "description": "Same as ents.owner() on the server. On the client, returns the local player",
          "returntypes": [
            "Player"
          ]
        }
      },
      "description": "Entities Library",
      "fields": {
        "1": "COLLISION_GROUP_NONE",
        "2": "COLLISION_GROUP_DEBRIS",
        "3": "COLLISION_GROUP_DEBRIS_TRIGGER",
        "4": "COLLISION_GROUP_INTERACTIVE_DEBRIS",
        "5": "COLLISION_GROUP_INTERACTIVE",
        "6": "COLLISION_GROUP_PLAYER",
        "7": "COLLISION_GROUP_BREAKABLE_GLASS",
        "8": "COLLISION_GROUP_VEHICLE",
        "9": "COLLISION_GROUP_PLAYER_MOVEMENT",
        "10": "COLLISION_GROUP_NPC",
        "11": "COLLISION_GROUP_IN_VEHICLE",
        "12": "COLLISION_GROUP_WEAPON",
        "13": "COLLISION_GROUP_VEHICLE_CLIP",
        "14": "COLLISION_GROUP_PROJECTILE",
        "15": "COLLISION_GROUP_DOOR_BLOCKER",
        "16": "COLLISION_GROUP_PASSABLE_DOOR",
        "17": "COLLISION_GROUP_DISSOLVING",
        "18": "COLLISION_GROUP_PUSHAWAY",
        "19": "COLLISION_GROUP_NPC_ACTOR",
        "20": "COLLISION_GROUP_NPC_SCRIPTED",
        "21": "COLLISION_GROUP_WORLD",
        "22": "EFL_BOT_FROZEN",
        "23": "EFL_CHECK_UNTOUCH",
        "24": "EFL_DIRTY_ABSANGVELOCITY",
        "25": "EFL_DIRTY_ABSTRANSFORM",
        "26": "EFL_DIRTY_ABSVELOCITY",
        "27": "EFL_DIRTY_SHADOWUPDATE",
        "28": "EFL_DIRTY_SPATIAL_PARTITION",
        "29": "EFL_DIRTY_SURROUNDING_COLLISION_BOUNDS",
        "30": "EFL_DONTBLOCKLOS",
        "31": "EFL_DONTWALKON",
        "32": "EFL_DORMANT",
        "33": "EFL_FORCE_CHECK_TRANSMIT",
        "34": "EFL_HAS_PLAYER_CHILD",
        "35": "EFL_IN_SKYBOX",
        "36": "EFL_IS_BEING_LIFTED_BY_BARNACLE",
        "37": "EFL_KEEP_ON_RECREATE_ENTITIES",
        "38": "EFL_KILLME",
        "39": "EFL_NOCLIP_ACTIVE",
        "40": "EFL_NOTIFY",
        "41": "EFL_NO_AUTO_EDICT_ATTACH",
        "42": "EFL_NO_DAMAGE_FORCES",
        "43": "EFL_NO_DISSOLVE",
        "44": "EFL_NO_GAME_PHYSICS_SIMULATION",
        "45": "EFL_NO_MEGAPHYSCANNON_RAGDOLL",
        "46": "EFL_NO_PHYSCANNON_INTERACTION",
        "47": "EFL_NO_ROTORWASH_PUSH",
        "48": "EFL_NO_THINK_FUNCTION",
        "49": "EFL_NO_WATER_VELOCITY_CHANGE",
        "50": "EFL_SERVER_ONLY",
        "51": "EFL_SETTING_UP_BONES",
        "52": "EFL_TOUCHING_FLUID",
        "53": "EFL_USE_PARTITION_WHEN_NOT_SOLID",
        "54": "FL_AIMTARGET",
        "55": "FL_ANIMDUCKING",
        "56": "FL_ATCONTROLS",
        "57": "FL_BASEVELOCITY",
        "58": "FL_CLIENT",
        "59": "FL_CONVEYOR",
        "60": "FL_DISSOLVING",
        "61": "FL_DONTTOUCH",
        "62": "FL_DUCKING",
        "63": "FL_FAKECLIENT",
        "64": "FL_FLY",
        "65": "FL_FROZEN",
        "66": "FL_GODMODE",
        "67": "FL_GRAPHED",
        "68": "FL_GRENADE",
        "69": "FL_INRAIN",
        "70": "FL_INWATER",
        "71": "FL_KILLME",
        "72": "FL_NOTARGET",
        "73": "FL_NPC",
        "74": "FL_OBJECT",
        "75": "FL_ONFIRE",
        "76": "FL_ONGROUND",
        "77": "FL_ONTRAIN",
        "78": "FL_PARTIALGROUND",
        "79": "FL_STATICPROP",
        "80": "FL_STEPMOVEMENT",
        "81": "FL_SWIM",
        "82": "FL_TRANSRAGDOLL",
        "83": "FL_UNBLOCKABLE_BY_PLAYER",
        "84": "FL_WATERJUMP",
        "85": "FL_WORLDBRUSH",
        "86": "NULL_ENTITY",
        "87": "RENDERMODE_TRANSCOLOR",
        "88": "RENDERMODE_TRANSALPHADD",
        "89": "RENDERMODE_TRANSTEXTURE",
        "90": "RENDERMODE_TRANSADD",
        "91": "RENDERMODE_NORMAL",
        "92": "RENDERMODE_GLOW",
        "93": "RENDERMODE_TRANSADDFRAMEBLEND",
        "94": "RENDERMODE_NONE",
        "95": "RENDERMODE_WORLDGLOW",
        "96": "RENDERMODE_ENVIROMENTAL",
        "97": "RENDERMODE_TRANSALPHA",
        "FL_GRENADE": {
          "description": "FL_GRENADE"
        },
        "FL_NPC": {
          "description": "FL_NPC"
        },
        "FL_CONVEYOR": {
          "description": "FL_CONVEYOR"
        },
        "FL_CLIENT": {
          "description": "FL_CLIENT"
        },
        "EFL_DONTWALKON": {
          "description": "EFL_DONTWALKON"
        },
        "FL_DUCKING": {
          "description": "FL_DUCKING"
        },
        "EFL_NO_PHYSCANNON_INTERACTION": {
          "description": "EFL_NO_PHYSCANNON_INTERACTION"
        },
        "EFL_DIRTY_SPATIAL_PARTITION": {
          "description": "EFL_DIRTY_SPATIAL_PARTITION"
        },
        "FL_AIMTARGET": {
          "description": "FL_AIMTARGET"
        },
        "COLLISION_GROUP_IN_VEHICLE": {
          "description": "COLLISION_GROUP_IN_VEHICLE"
        },
        "COLLISION_GROUP_INTERACTIVE": {
          "description": "COLLISION_GROUP_INTERACTIVE"
        },
        "FL_DONTTOUCH": {
          "description": "FL_DONTTOUCH"
        },
        "EFL_CHECK_UNTOUCH": {
          "description": "EFL_CHECK_UNTOUCH"
        },
        "FL_ONFIRE": {
          "description": "FL_ONFIRE"
        },
        "FL_INRAIN": {
          "description": "FL_INRAIN"
        },
        "EFL_USE_PARTITION_WHEN_NOT_SOLID": {
          "description": "EFL_USE_PARTITION_WHEN_NOT_SOLID"
        },
        "EFL_SERVER_ONLY": {
          "description": "EFL_SERVER_ONLY"
        },
        "RENDERMODE_ENVIROMENTAL": {
          "description": "RENDERMODE_ENVIROMENTAL"
        },
        "FL_ONGROUND": {
          "description": "FL_ONGROUND"
        },
        "EFL_DIRTY_ABSVELOCITY": {
          "description": "EFL_DIRTY_ABSVELOCITY"
        },
        "FL_FAKECLIENT": {
          "description": "FL_FAKECLIENT"
        },
        "EFL_KILLME": {
          "description": "EFL_KILLME"
        },
        "COLLISION_GROUP_PROJECTILE": {
          "description": "COLLISION_GROUP_PROJECTILE"
        },
        "COLLISION_GROUP_PUSHAWAY": {
          "description": "COLLISION_GROUP_PUSHAWAY"
        },
        "COLLISION_GROUP_PLAYER": {
          "description": "COLLISION_GROUP_PLAYER"
        },
        "COLLISION_GROUP_DISSOLVING": {
          "description": "COLLISION_GROUP_DISSOLVING"
        },
        "COLLISION_GROUP_PLAYER_MOVEMENT": {
          "description": "COLLISION_GROUP_PLAYER_MOVEMENT"
        },
        "FL_STEPMOVEMENT": {
          "description": "FL_STEPMOVEMENT"
        },
        "FL_FLY": {
          "description": "FL_FLY"
        },
        "COLLISION_GROUP_WEAPON": {
          "description": "COLLISION_GROUP_WEAPON"
        },
        "EFL_TOUCHING_FLUID": {
          "description": "EFL_TOUCHING_FLUID"
        },
        "EFL_DIRTY_ABSANGVELOCITY": {
          "description": "EFL_DIRTY_ABSANGVELOCITY"
        },
        "FL_WATERJUMP": {
          "description": "FL_WATERJUMP"
        },
        "EFL_DIRTY_ABSTRANSFORM": {
          "description": "EFL_DIRTY_ABSTRANSFORM"
        },
        "EFL_SETTING_UP_BONES": {
          "description": "EFL_SETTING_UP_BONES"
        },
        "FL_NOTARGET": {
          "description": "FL_NOTARGET"
        },
        "FL_KILLME": {
          "description": "FL_KILLME"
        },
        "EFL_NO_WATER_VELOCITY_CHANGE": {
          "description": "EFL_NO_WATER_VELOCITY_CHANGE"
        },
        "NULL_ENTITY": {
          "description": "Represents an invalid entity."
        },
        "EFL_NO_ROTORWASH_PUSH": {
          "description": "EFL_NO_ROTORWASH_PUSH"
        },
        "FL_WORLDBRUSH": {
          "description": "FL_WORLDBRUSH"
        },
        "EFL_NOCLIP_ACTIVE": {
          "description": "EFL_NOCLIP_ACTIVE"
        },
        "FL_GODMODE": {
          "description": "FL_GODMODE"
        },
        "EFL_FORCE_CHECK_TRANSMIT": {
          "description": "EFL_FORCE_CHECK_TRANSMIT"
        },
        "EFL_NO_AUTO_EDICT_ATTACH": {
          "description": "EFL_NO_AUTO_EDICT_ATTACH"
        },
        "FL_SWIM": {
          "description": "FL_SWIM"
        },
        "FL_PARTIALGROUND": {
          "description": "FL_PARTIALGROUND"
        },
        "RENDERMODE_TRANSALPHA": {
          "description": "RENDERMODE_TRANSALPHA"
        },
        "COLLISION_GROUP_NPC_ACTOR": {
          "description": "COLLISION_GROUP_NPC_ACTOR"
        },
        "RENDERMODE_NONE": {
          "description": "RENDERMODE_NONE"
        },
        "FL_DISSOLVING": {
          "description": "FL_DISSOLVING"
        },
        "RENDERMODE_GLOW": {
          "description": "RENDERMODE_GLOW"
        },
        "RENDERMODE_TRANSCOLOR": {
          "description": "RENDERMODE_TRANSCOLOR"
        },
        "COLLISION_GROUP_PASSABLE_DOOR": {
          "description": "COLLISION_GROUP_PASSABLE_DOOR"
        },
        "FL_ONTRAIN": {
          "description": "FL_ONTRAIN"
        },
        "RENDERMODE_TRANSTEXTURE": {
          "description": "RENDERMODE_TRANSTEXTURE"
        },
        "FL_FROZEN": {
          "description": "FL_FROZEN"
        },
        "RENDERMODE_NORMAL": {
          "description": "RENDERMODE_NORMAL"
        },
        "FL_UNBLOCKABLE_BY_PLAYER": {
          "description": "FL_UNBLOCKABLE_BY_PLAYER"
        },
        "FL_TRANSRAGDOLL": {
          "description": "FL_TRANSRAGDOLL"
        },
        "FL_STATICPROP": {
          "description": "FL_STATICPROP"
        },
        "COLLISION_GROUP_WORLD": {
          "description": "COLLISION_GROUP_WORLD"
        },
        "RENDERMODE_TRANSADD": {
          "description": "RENDERMODE_TRANSADD"
        },
        "COLLISION_GROUP_NONE": {
          "description": "COLLISION_GROUP_NONE"
        },
        "FL_OBJECT": {
          "description": "FL_OBJECT"
        },
        "COLLISION_GROUP_VEHICLE": {
          "description": "COLLISION_GROUP_VEHICLE"
        },
        "COLLISION_GROUP_INTERACTIVE_DEBRIS": {
          "description": "COLLISION_GROUP_INTERACTIVE_DEBRIS"
        },
        "FL_INWATER": {
          "description": "FL_INWATER"
        },
        "FL_GRAPHED": {
          "description": "FL_GRAPHED"
        },
        "RENDERMODE_TRANSALPHADD": {
          "description": "RENDERMODE_TRANSALPHADD"
        },
        "COLLISION_GROUP_DEBRIS": {
          "description": "COLLISION_GROUP_DEBRIS"
        },
        "COLLISION_GROUP_DEBRIS_TRIGGER": {
          "description": "COLLISION_GROUP_DEBRIS_TRIGGER"
        },
        "RENDERMODE_WORLDGLOW": {
          "description": "RENDERMODE_WORLDGLOW"
        },
        "EFL_NO_DISSOLVE": {
          "description": "EFL_NO_DISSOLVE"
        },
        "EFL_NO_DAMAGE_FORCES": {
          "description": "EFL_NO_DAMAGE_FORCES"
        },
        "EFL_HAS_PLAYER_CHILD": {
          "description": "EFL_HAS_PLAYER_CHILD"
        },
        "RENDERMODE_TRANSADDFRAMEBLEND": {
          "description": "RENDERMODE_TRANSADDFRAMEBLEND"
        },
        "COLLISION_GROUP_VEHICLE_CLIP": {
          "description": "COLLISION_GROUP_VEHICLE_CLIP"
        },
        "COLLISION_GROUP_NPC": {
          "description": "COLLISION_GROUP_NPC"
        },
        "EFL_BOT_FROZEN": {
          "description": "EFL_BOT_FROZEN"
        },
        "EFL_IS_BEING_LIFTED_BY_BARNACLE": {
          "description": "EFL_IS_BEING_LIFTED_BY_BARNACLE"
        },
        "EFL_NO_GAME_PHYSICS_SIMULATION": {
          "description": "EFL_NO_GAME_PHYSICS_SIMULATION"
        },
        "EFL_IN_SKYBOX": {
          "description": "EFL_IN_SKYBOX"
        },
        "FL_BASEVELOCITY": {
          "description": "FL_BASEVELOCITY"
        },
        "FL_ANIMDUCKING": {
          "description": "FL_ANIMDUCKING"
        },
        "EFL_NO_MEGAPHYSCANNON_RAGDOLL": {
          "description": "EFL_NO_MEGAPHYSCANNON_RAGDOLL"
        },
        "EFL_NO_THINK_FUNCTION": {
          "description": "EFL_NO_THINK_FUNCTION"
        },
        "EFL_NOTIFY": {
          "description": "EFL_NOTIFY"
        },
        "COLLISION_GROUP_BREAKABLE_GLASS": {
          "description": "COLLISION_GROUP_BREAKABLE_GLASS"
        },
        "EFL_DIRTY_SHADOWUPDATE": {
          "description": "EFL_DIRTY_SHADOWUPDATE"
        },
        "FL_ATCONTROLS": {
          "description": "FL_ATCONTROLS"
        },
        "COLLISION_GROUP_DOOR_BLOCKER": {
          "description": "COLLISION_GROUP_DOOR_BLOCKER"
        },
        "EFL_DONTBLOCKLOS": {
          "description": "EFL_DONTBLOCKLOS"
        },
        "COLLISION_GROUP_NPC_SCRIPTED": {
          "description": "COLLISION_GROUP_NPC_SCRIPTED"
        },
        "EFL_KEEP_ON_RECREATE_ENTITIES": {
          "description": "EFL_KEEP_ON_RECREATE_ENTITIES"
        },
        "EFL_DORMANT": {
          "description": "EFL_DORMANT"
        },
        "EFL_DIRTY_SURROUNDING_COLLISION_BOUNDS": {
          "description": "EFL_DIRTY_SURROUNDING_COLLISION_BOUNDS"
        }
      },
      "client": true,
      "server": true
    },
    "vgui": {
      "functions": {
        "1": "create",
        "create": {
          "ret": "The created object, or nil if it could not be created (i.e the local player isn't linked or the object doesn't exist).",
          "returntypes": [
            "Panel"
          ],
          "client": true,
          "description": "Creates and returns a VGUI control. Available classes are: \n* AvatarImage \n* DAdjustableModelPanel \n* DAlphaBar \n* DButton \n* DCollapsibleCategory \n* DCategoryList \n* DCheckBox \n* DCheckBoxLabel \n* DColorButton \n* DColorCombo \n* DColorCube \n* DColorMixer \n* DColumnSheet \n* DComboBox \n* DDrawer \n* DFileBrowser \n* DForm \n* DFrame \n* DGrid \n* DHorizontalDivider \n* DHorizontalScroller \n* DHTML - only if the USE_WEB_BROWSER permission has been granted. \n* DIconBrowser \n* DIconLayout \n* DImage \n* DImageButton \n* DLabel \n* DLabelEditable \n* DListView \n* DMenu \n* DMenuBar \n* DModelPanel \n* DNumberScratch \n* DNumberWang \n* DNumPad \n* DNumSlider \n* DPanel \n* DProgress \n* DProperties \n* DPropertySheet \n* DRGBPicker \n* DScrollPanel \n* DTextEntry \n* DTree \n* DVerticalDivider \n* DVScrollBar",
          "param": {
            "1": "class",
            "2": "parent",
            "parent": "Optional parent object.",
            "class": "The class name of the control you want to create."
          }
        }
      },
      "description": "VGUI library. Used to create basic VGUI controls. Only available to HUDs.",
      "fields": {
        "1": "FILL",
        "2": "LEFT",
        "3": "RIGHT",
        "4": "TOP",
        "5": "BOTTOM",
        "6": "NODOCK",
        "FILL": {
          "description": "FILL for docking",
          "client": true
        },
        "BOTTOM": {
          "description": "BOTTOM for docking",
          "client": true
        },
        "RIGHT": {
          "description": "RIGHT for docking",
          "client": true
        },
        "NODOCK": {
          "description": "NODOCK for docking",
          "client": true
        },
        "TOP": {
          "description": "TOP for docking",
          "client": true
        },
        "LEFT": {
          "description": "LEFT for docking",
          "client": true
        }
      },
      "client": true
    },
    "math": {
      "functions": {
        "1": "clamp",
        "2": "randfloat",
        "3": "round",
        "clamp": {
          "ret": "The value clamped between the given minimum and maximum value.",
          "description": "Clamps the given number between the given minimum and maximum value.",
          "returntypes": [
            "number"
          ],
          "param": {
            "1": "value",
            "2": "min",
            "3": "max",
            "max": "The maximum value to clamp the value to.",
            "min": "The minimum value to clamp the value to.",
            "value": "The value to be clamped."
          }
        },
        "round": {
          "ret": "The value rounded to the given number of decimals.",
          "description": "Rounds the given number to the given number of decimal places (rounding half-up).",
          "returntypes": [
            "number"
          ],
          "param": {
            "1": "value",
            "2": "decimals",
            "decimals": "(Optional) The number of decimals to round to (default = 0).",
            "value": "The value to be rounded."
          }
        },
        "randfloat": {
          "ret": "A random floating point number between the given minimum and maximum value.",
          "description": "Returns a random floating point value between the given minimum and maximum values.",
          "returntypes": [
            "number"
          ],
          "param": {
            "1": "min",
            "2": "max",
            "max": "The maximum value.",
            "min": "The minimum value."
          }
        }
      },
      "description": "Lua's (not glua's) math library, plus clamp, round, and randfloat",
      "externaldocs": "http://www.lua.org/manual/5.1/manual.html#5.6"
    },
    "trace": {
      "functions": {
        "1": "computeAimVectorFromScreenPos",
        "2": "getPointContents",
        "3": "intersectRayWithOBB",
        "4": "intersectRayWithPlane",
        "5": "traceEntity",
        "6": "traceHull",
        "7": "traceLine",
        "intersectRayWithOBB": {
          "ret": [
            "The position of the intersection point, or nil if no intersection occurs.",
            "The hit normal of the intersection, or nil if no intersection occurs.",
            "The fraction along the ray at which the intersection occurred (between 0 and 1), or nil if no intersection occurs."
          ],
          "returntypes": [
            [
              "Vector",
              "nil"
            ],
            [
              "Vector",
              "nil"
            ],
            [
              "number",
              "nil"
            ]
          ],
          "description": "Returns the intersection point for the given ray against the given box, in world space. \nIf no intersection occurs, nil will be returned.",
          "param": {
            "1": "rayOrigin",
            "2": "rayDelta",
            "3": "boxOrigin",
            "4": "boxAngles",
            "5": "boxMins",
            "6": "boxMaxs",
            "boxMaxs": "The maximum extents of the box.",
            "boxMins": "The minimum extents of the box.",
            "boxAngles": "The angles of the box.",
            "boxOrigin": "The origin of the box.",
            "rayDelta": "A vector whose direction determines the ray's direction, and whose length determines how far the ray travels.",
            "rayOrigin": "The origin of the ray."
          }
        },
        "computeAimVectorFromScreenPos": {
          "returntypes": [
            "Vector"
          ],
          "paramtypes": {
            "screenHeight": "number",
            "screenWidth": "number",
            "screenY": "number",
            "screenX": "number",
            "viewFOV": "number",
            "viewAngles": "Angle"
          },
          "description": "Returns an aim vector based on the given view and screen parameters. \nThis can be used to project from screen space into a direction in world space.",
          "param": {
            "1": "viewAngles",
            "2": "viewFOV",
            "3": "screenX",
            "4": "screenY",
            "5": "screenWidth",
            "6": "screenHeight",
            "screenHeight": "The height of the screen.",
            "screenWidth": "The width of the screen.",
            "screenY": "The y position on the screen to project from.",
            "screenX": "The x position on the screen to project from.",
            "viewFOV": "The field of view in degrees.",
            "viewAngles": "The view angles in world space."
          }
        },
        "traceLine": {
          "ret": "A table containing the trace results.",
          "returntypes": [
            "TraceResult"
          ],
          "description": "Does a line trace from the given start position to the given end position, stopping on the first surface hit.",
          "param": {
            "1": "start",
            "2": "endPos",
            "3": "filter",
            "4": "mask",
            "5": "ignoreWorld",
            "6": "collisionGroup",
            "collisionGroup": "The collision group(s) to hit (see ents.COLLISION_GROUP_*)",
            "ignoreWorld": "Whether to ignore the world",
            "mask": "Trace mask",
            "start": "Start position",
            "filter": "Entity/array of entities/function taking entity argument to filter",
            "endPos": "End position"
          }
        },
        "traceEntity": {
          "ret": "A table containing the trace results.",
          "returntypes": [
            "TraceResult"
          ],
          "description": "Does a trace using the given entity's (axis-aligned) physics object from the start position to the end position, stopping on the first surface hit.",
          "param": {
            "1": "ent",
            "2": "start",
            "3": "endPos",
            "4": "filter",
            "5": "mask",
            "6": "ignoreWorld",
            "7": "collisionGroup",
            "collisionGroup": "The collision group(s) to hit (see ents.COLLISION_GROUP_*)",
            "ignoreWorld": "Whether to ignore the world",
            "mask": "Trace mask",
            "filter": "Entity/array of entities/function taking entity argument to filter",
            "endPos": "End position",
            "start": "Start position",
            "ent": "The entity to use"
          }
        },
        "traceHull": {
          "ret": "A table containing the trace results.",
          "returntypes": [
            "TraceResult"
          ],
          "description": "Does a swept-AABB trace from the start position to the end position, stopping on the first surface hit.",
          "param": {
            "1": "start",
            "2": "endPos",
            "3": "mins",
            "4": "maxs",
            "5": "filter",
            "6": "mask",
            "7": "ignoreWorld",
            "8": "collisionGroup",
            "collisionGroup": "The collision group(s) to hit (see ents.COLLISION_GROUP_*)",
            "ignoreWorld": "Whether to ignore the world",
            "mask": "Trace mask",
            "filter": "Entity/array of entities/function taking entity argument to filter",
            "maxs": "Upper box corner of the hull",
            "mins": "Lower box corner of the hull",
            "endPos": "End position",
            "start": "Start position"
          }
        },
        "getPointContents": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the trace.CONTENTS_* flags that describe the contents of the given position.",
          "param": {
            "1": "pos",
            "pos": "The position to get the contents flags for."
          }
        },
        "intersectRayWithPlane": {
          "returntypes": [
            [
              "Vector",
              "nil"
            ]
          ],
          "description": "Returns the intersection point for the given ray on the given plane, in world space. \nIf no intersection occurs, nil will be returned.",
          "param": {
            "1": "rayOrigin",
            "2": "rayDir",
            "3": "planePos",
            "4": "planeNormal",
            "planeNormal": "The plane's normal.",
            "planePos": "A position on the plane.",
            "rayDir": "The normalised direction of the ray.",
            "rayOrigin": "The origin of the ray."
          }
        }
      },
      "description": "Provides functions for doing line/AABB traces",
      "fields": {
        "1": "MAT_ANTLION",
        "2": "MAT_BLOODYFLESH",
        "3": "MAT_CONCRETE",
        "4": "MAT_DIRT",
        "5": "MAT_EGGSHELL",
        "6": "MAT_FLESH",
        "7": "MAT_GRATE",
        "8": "MAT_ALIENFLESH",
        "9": "MAT_CLIP",
        "10": "MAT_SNOW",
        "11": "MAT_PLASTIC",
        "12": "MAT_METAL",
        "13": "MAT_SAND",
        "14": "MAT_FOLIAGE",
        "15": "MAT_COMPUTER",
        "16": "MAT_SLOSH",
        "17": "MAT_TILE",
        "18": "MAT_GRASS",
        "19": "MAT_VENT",
        "20": "MAT_WOOD",
        "21": "MAT_DEFAULT",
        "22": "MAT_GLASS",
        "23": "MAT_WARPSHIELD",
        "24": "HITGROUP_RIGHTARM",
        "25": "HITGROUP_GEAR",
        "26": "HITGROUP_GENERIC",
        "27": "HITGROUP_STOMACH",
        "28": "HITGROUP_RIGHTLEG",
        "29": "HITGROUP_LEFTLEG",
        "30": "HITGROUP_HEAD",
        "31": "HITGROUP_LEFTARM",
        "32": "HITGROUP_CHEST",
        "33": "MASK_OPAQUE_AND_NPCS",
        "34": "MASK_SOLID",
        "35": "MASK_PLAYERSOLID",
        "36": "MASK_OPAQUE",
        "37": "MASK_SHOT_HULL",
        "38": "MASK_ALL",
        "39": "MASK_VISIBLE",
        "40": "MASK_NPCWORLDSTATIC",
        "41": "MASK_DEADSOLID",
        "42": "MASK_SPLITAREAPORTAL",
        "43": "MASK_CURRENT",
        "44": "MASK_BLOCKLOS_AND_NPCS",
        "45": "MASK_NPCSOLID",
        "46": "MASK_SOLID_BRUSHONLY",
        "47": "MASK_VISIBLE_AND_NPCS",
        "48": "MASK_SHOT",
        "49": "MASK_NPCSOLID_BRUSHONLY",
        "50": "MASK_PLAYERSOLID_BRUSHONLY",
        "51": "MASK_SHOT_PORTAL",
        "52": "MASK_WATER",
        "53": "MASK_BLOCKLOS",
        "54": "CONTENTS_CURRENT_270",
        "55": "CONTENTS_DETAIL",
        "56": "CONTENTS_IGNORE_NODRAW_OPAQUE",
        "57": "CONTENTS_BLOCKLOS",
        "58": "CONTENTS_GRATE",
        "59": "CONTENTS_CURRENT_0",
        "60": "CONTENTS_AREAPORTAL",
        "61": "CONTENTS_DEBRIS",
        "62": "CONTENTS_MONSTERCLIP",
        "63": "CONTENTS_SLIME",
        "64": "CONTENTS_WINDOW",
        "65": "CONTENTS_LADDER",
        "66": "CONTENTS_CURRENT_180",
        "67": "CONTENTS_TRANSLUCENT",
        "68": "CONTENTS_EMPTY",
        "69": "CONTENTS_TEAM2",
        "70": "CONTENTS_CURRENT_UP",
        "71": "CONTENTS_TESTFOGVOLUME",
        "72": "CONTENTS_TEAM1",
        "73": "CONTENTS_AUX",
        "74": "CONTENTS_ORIGIN",
        "75": "CONTENTS_TEAM3",
        "76": "CONTENTS_WATER",
        "77": "CONTENTS_MOVEABLE",
        "78": "CONTENTS_PLAYERCLIP",
        "79": "CONTENTS_SOLID",
        "80": "CONTENTS_CURRENT_DOWN",
        "81": "CONTENTS_HITBOX",
        "82": "CONTENTS_MONSTER",
        "83": "CONTENTS_CURRENT_90",
        "84": "CONTENTS_OPAQUE",
        "85": "CONTENTS_TEAM4",
        "86": "SURF_BUMPLIGHT",
        "87": "SURF_HINT",
        "88": "SURF_HITBOX",
        "89": "SURF_LIGHT",
        "90": "SURF_NOCHOP",
        "91": "SURF_NODECALS",
        "92": "SURF_NODRAW",
        "93": "SURF_NOLIGHT",
        "94": "SURF_NOPORTAL",
        "95": "SURF_NOSHADOWS",
        "96": "SURF_SKIP",
        "97": "SURF_SKY",
        "98": "SURF_SKY2D",
        "99": "SURF_TRANS",
        "100": "SURF_TRIGGER",
        "101": "SURF_WARP",
        "102": "DISPSURF_BUILDABLE",
        "103": "DISPSURF_SURFACE",
        "104": "DISPSURF_SURFPROP1",
        "105": "DISPSURF_SURFPROP2",
        "106": "DISPSURF_WALKABLE",
        "MASK_DEADSOLID": {
          "description": "MASK_DEADSOLID"
        },
        "MASK_BLOCKLOS": {
          "description": "MASK_BLOCKLOS"
        },
        "CONTENTS_EMPTY": {
          "description": "CONTENTS_EMPTY"
        },
        "MASK_OPAQUE": {
          "description": "MASK_OPAQUE"
        },
        "CONTENTS_IGNORE_NODRAW_OPAQUE": {
          "description": "CONTENTS_IGNORE_NODRAW_OPAQUE"
        },
        "MASK_VISIBLE": {
          "description": "MASK_VISIBLE"
        },
        "HITGROUP_LEFTLEG": {
          "description": "HITGROUP_LEFTLEG"
        },
        "CONTENTS_DETAIL": {
          "description": "CONTENTS_DETAIL"
        },
        "HITGROUP_RIGHTARM": {
          "description": "HITGROUP_RIGHTARM"
        },
        "CONTENTS_CURRENT_DOWN": {
          "description": "CONTENTS_CURRENT_DOWN"
        },
        "CONTENTS_OPAQUE": {
          "description": "CONTENTS_OPAQUE"
        },
        "MAT_TILE": {
          "description": "MAT_TILE"
        },
        "MAT_FOLIAGE": {
          "description": "MAT_FOLIAGE"
        },
        "MASK_VISIBLE_AND_NPCS": {
          "description": "MASK_VISIBLE_AND_NPCS"
        },
        "MASK_SHOT": {
          "description": "MASK_SHOT"
        },
        "MAT_COMPUTER": {
          "description": "MAT_COMPUTER"
        },
        "CONTENTS_TEAM3": {
          "description": "CONTENTS_TEAM3"
        },
        "MASK_SPLITAREAPORTAL": {
          "description": "MASK_SPLITAREAPORTAL"
        },
        "CONTENTS_CURRENT_UP": {
          "description": "CONTENTS_CURRENT_UP"
        },
        "SURF_TRIGGER": {
          "description": "SURF_TRIGGER"
        },
        "MAT_CONCRETE": {
          "description": "MAT_CONCRETE"
        },
        "MAT_CLIP": {
          "description": "MAT_CLIP"
        },
        "MAT_WOOD": {
          "description": "MAT_WOOD"
        },
        "MAT_DIRT": {
          "description": "MAT_DIRT"
        },
        "MASK_NPCSOLID_BRUSHONLY": {
          "description": "MASK_NPCSOLID_BRUSHONLY"
        },
        "MAT_DEFAULT": {
          "description": "MAT_DEFAULT"
        },
        "CONTENTS_DEBRIS": {
          "description": "CONTENTS_DEBRIS"
        },
        "DISPSURF_SURFPROP1": {
          "description": "DISPSURF_SURFPROP1"
        },
        "MASK_SHOT_PORTAL": {
          "description": "MASK_SHOT_PORTAL"
        },
        "SURF_TRANS": {
          "description": "SURF_TRANS"
        },
        "DISPSURF_SURFACE": {
          "description": "DISPSURF_SURFACE"
        },
        "HITGROUP_STOMACH": {
          "description": "HITGROUP_STOMACH"
        },
        "MAT_SLOSH": {
          "description": "MAT_SLOSH"
        },
        "CONTENTS_PLAYERCLIP": {
          "description": "CONTENTS_PLAYERCLIP"
        },
        "SURF_NOPORTAL": {
          "description": "SURF_NOPORTAL"
        },
        "CONTENTS_WINDOW": {
          "description": "CONTENTS_WINDOW"
        },
        "DISPSURF_SURFPROP2": {
          "description": "DISPSURF_SURFPROP2"
        },
        "MASK_NPCWORLDSTATIC": {
          "description": "MASK_NPCWORLDSTATIC"
        },
        "DISPSURF_BUILDABLE": {
          "description": "DISPSURF_BUILDABLE"
        },
        "SURF_WARP": {
          "description": "SURF_WARP"
        },
        "MASK_OPAQUE_AND_NPCS": {
          "description": "MASK_OPAQUE_AND_NPCS"
        },
        "SURF_NODRAW": {
          "description": "SURF_NODRAW"
        },
        "CONTENTS_CURRENT_270": {
          "description": "CONTENTS_CURRENT_270"
        },
        "HITGROUP_LEFTARM": {
          "description": "HITGROUP_LEFTARM"
        },
        "CONTENTS_MONSTERCLIP": {
          "description": "CONTENTS_MONSTERCLIP"
        },
        "MAT_WARPSHIELD": {
          "description": "MAT_WARPSHIELD"
        },
        "MASK_WATER": {
          "description": "MASK_WATER"
        },
        "MAT_ANTLION": {
          "description": "MAT_ANTLION"
        },
        "SURF_NODECALS": {
          "description": "SURF_NODECALS"
        },
        "CONTENTS_TEAM4": {
          "description": "CONTENTS_TEAM4"
        },
        "HITGROUP_CHEST": {
          "description": "HITGROUP_CHEST"
        },
        "SURF_NOSHADOWS": {
          "description": "SURF_NOSHADOWS"
        },
        "CONTENTS_AREAPORTAL": {
          "description": "CONTENTS_AREAPORTAL"
        },
        "SURF_NOLIGHT": {
          "description": "SURF_NOLIGHT"
        },
        "SURF_NOCHOP": {
          "description": "SURF_NOCHOP"
        },
        "HITGROUP_GENERIC": {
          "description": "HITGROUP_GENERIC"
        },
        "MAT_METAL": {
          "description": "MAT_METAL"
        },
        "HITGROUP_GEAR": {
          "description": "HITGROUP_GEAR"
        },
        "SURF_LIGHT": {
          "description": "SURF_LIGHT"
        },
        "MAT_VENT": {
          "description": "MAT_VENT"
        },
        "MAT_PLASTIC": {
          "description": "MAT_PLASTIC"
        },
        "SURF_HITBOX": {
          "description": "SURF_HITBOX"
        },
        "CONTENTS_CURRENT_180": {
          "description": "CONTENTS_CURRENT_180"
        },
        "HITGROUP_RIGHTLEG": {
          "description": "HITGROUP_RIGHTLEG"
        },
        "SURF_SKY2D": {
          "description": "SURF_SKY2D"
        },
        "CONTENTS_HITBOX": {
          "description": "CONTENTS_HITBOX"
        },
        "MAT_FLESH": {
          "description": "MAT_FLESH"
        },
        "SURF_SKIP": {
          "description": "SURF_SKIP"
        },
        "HITGROUP_HEAD": {
          "description": "HITGROUP_HEAD"
        },
        "CONTENTS_MONSTER": {
          "description": "CONTENTS_MONSTER"
        },
        "MAT_GLASS": {
          "description": "MAT_GLASS"
        },
        "SURF_BUMPLIGHT": {
          "description": "SURF_BUMPLIGHT"
        },
        "CONTENTS_LADDER": {
          "description": "CONTENTS_LADDER"
        },
        "MASK_ALL": {
          "description": "MASK_ALL"
        },
        "CONTENTS_ORIGIN": {
          "description": "CONTENTS_ORIGIN"
        },
        "CONTENTS_TEAM2": {
          "description": "CONTENTS_TEAM2"
        },
        "CONTENTS_WATER": {
          "description": "CONTENTS_WATER"
        },
        "CONTENTS_GRATE": {
          "description": "CONTENTS_GRATE"
        },
        "MASK_NPCSOLID": {
          "description": "MASK_NPCSOLID"
        },
        "CONTENTS_MOVEABLE": {
          "description": "CONTENTS_MOVEABLE"
        },
        "CONTENTS_TRANSLUCENT": {
          "description": "CONTENTS_TRANSLUCENT"
        },
        "CONTENTS_TEAM1": {
          "description": "CONTENTS_TEAM1"
        },
        "CONTENTS_TESTFOGVOLUME": {
          "description": "CONTENTS_TESTFOGVOLUME"
        },
        "CONTENTS_SOLID": {
          "description": "CONTENTS_SOLID"
        },
        "MAT_BLOODYFLESH": {
          "description": "MAT_BLOODYFLESH"
        },
        "MAT_SAND": {
          "description": "MAT_SAND"
        },
        "CONTENTS_SLIME": {
          "description": "CONTENTS_SLIME"
        },
        "CONTENTS_CURRENT_0": {
          "description": "CONTENTS_CURRENT_0"
        },
        "MASK_PLAYERSOLID": {
          "description": "MASK_PLAYERSOLID"
        },
        "DISPSURF_WALKABLE": {
          "description": "DISPSURF_WALKABLE"
        },
        "MASK_BLOCKLOS_AND_NPCS": {
          "description": "MASK_BLOCKLOS_AND_NPCS"
        },
        "MASK_PLAYERSOLID_BRUSHONLY": {
          "description": "MASK_PLAYERSOLID_BRUSHONLY"
        },
        "CONTENTS_BLOCKLOS": {
          "description": "CONTENTS_BLOCKLOS"
        },
        "MASK_SOLID_BRUSHONLY": {
          "description": "MASK_SOLID_BRUSHONLY"
        },
        "MAT_EGGSHELL": {
          "description": "MAT_EGGSHELL"
        },
        "CONTENTS_CURRENT_90": {
          "description": "CONTENTS_CURRENT_90"
        },
        "CONTENTS_AUX": {
          "description": "CONTENTS_AUX"
        },
        "MASK_CURRENT": {
          "description": "MASK_CURRENT"
        },
        "SURF_SKY": {
          "description": "SURF_SKY"
        },
        "MAT_ALIENFLESH": {
          "description": "MAT_ALIENFLESH"
        },
        "MAT_GRASS": {
          "description": "MAT_GRASS"
        },
        "MAT_SNOW": {
          "description": "MAT_SNOW"
        },
        "MASK_SOLID": {
          "description": "MASK_SOLID"
        },
        "SURF_HINT": {
          "description": "SURF_HINT"
        },
        "MASK_SHOT_HULL": {
          "description": "MASK_SHOT_HULL"
        },
        "MAT_GRATE": {
          "description": "MAT_GRATE"
        }
      },
      "client": true,
      "server": true
    },
    "mesh": {
      "functions": {
        "1": "advanceVertex",
        "2": "generate",
        "3": "writeColor",
        "4": "writeNormal",
        "5": "writePosition",
        "6": "writeQuadFromPlane",
        "7": "writeQuadFromVertices",
        "8": "writeTexCoord",
        "9": "writeUserData",
        "writeTexCoord": {
          "client": true,
          "description": "Sets the texture co-ordinates of the current vertex.",
          "param": {
            "1": "stage",
            "2": "u",
            "3": "v",
            "v": "The v co-ordinate.",
            "u": "The u co-ordinate.",
            "stage": "The stage to write the co-ordinates to. Stage 0 is the main texture, stages 1 and 2 are used for lightmaps."
          }
        },
        "generate": {
          "usage": "-- Generates a 64x64 white rectangle at (0, 0) \nlocal function GenerateMesh() \n\tmesh.writeQuadFromPlane( Vector( 32, 32, 0 ), Vector( 0, 0, -1 ), 64, 64 ) \nend \n-- In a render hook, call mesh.generate to draw the mesh dynamically. \n-- Alternatively, pass an IMesh to store the mesh data to be drawn later. \nhook.add( \"render\", \"mesh\", function() \n\trender.clear( 0, 0, 0, 255 ) \n\tmesh.generate( mesh.MATERIAL_QUADS, 1, GenerateMesh ) \nend )",
          "client": true,
          "description": "Generates a mesh, either writing to the given mesh object, or otherwise drawing the result directly. \nWriting to an IMesh can be done outside a rendering hook.",
          "param": {
            "1": "primitiveType",
            "2": "primitiveCount",
            "3": "generatorFunc",
            "4": "meshInstance",
            "meshInstance": "An optional IMesh object to write the mesh values to.",
            "generatorFunc": "A function that, when called, should write the mesh.",
            "primitiveCount": "The number of primitives that will be drawn.",
            "primitiveType": "The type of primitives to draw (mesh.MATERIAL_*)."
          }
        },
        "writeQuadFromVertices": {
          "client": true,
          "description": "Writes 4 vertices to the mesh, all with white colour.",
          "param": {
            "1": "vertex1",
            "2": "vertex2",
            "3": "vertex3",
            "4": "vertex4",
            "vertex4": "The bottom-left corner.",
            "vertex3": "The bottom-right corner.",
            "vertex2": "The top-right corner.",
            "vertex1": "The top-left corner."
          }
        },
        "writeColor": {
          "client": true,
          "description": "Sets the colour of the current vertex.",
          "param": {
            "1": "r",
            "2": "g",
            "3": "b",
            "4": "a",
            "a": "The alpha value (0-255).",
            "b": "The blue value (0-255).",
            "g": "The green value (0-255).",
            "r": "The red value (0-255)."
          }
        },
        "writeQuadFromPlane": {
          "client": true,
          "description": "Writes 4 vertices to the mesh based on the given plane and size, all with white colour.",
          "param": {
            "1": "position",
            "2": "normal",
            "3": "width",
            "4": "height",
            "height": "The height of the quad.",
            "width": "The width of the quad.",
            "normal": "The plane's normal.",
            "position": "The centre point for the quad."
          }
        },
        "advanceVertex": {
          "client": true,
          "description": "Advances the current mesh to the next vertex, committing any written data for the current vertex."
        },
        "writeNormal": {
          "client": true,
          "description": "Sets the normal of the current vertex (used for lighting).",
          "param": {
            "1": "normal",
            "normal": "The normal vector to write."
          }
        },
        "writeUserData": {
          "client": true,
          "description": "Sets the user data for the current vertex. This is used to define the tangent.",
          "param": {
            "1": "tangentX",
            "2": "tangentY",
            "3": "tangentZ",
            "4": "tangentHandedness",
            "tangentHandedness": "The handedness of the tangent vector (either -1 or 1).",
            "tangentZ": "The z component of the tangent vector.",
            "tangentY": "The y component of the tangent vector.",
            "tangentX": "The x component of the tangent vector."
          }
        },
        "writePosition": {
          "client": true,
          "description": "Sets the position of the current vertex.",
          "param": {
            "1": "pos",
            "pos": "The position to write."
          }
        }
      },
      "description": "Mesh library to facilitate drawing dynamic meshes.",
      "fields": {
        "1": "MATERIAL_TRIANGLE_STRIP",
        "2": "MATERIAL_TRIANGLES",
        "3": "MATERIAL_POLYGON",
        "4": "MATERIAL_LINE_LOOP",
        "5": "MATERIAL_LINES",
        "6": "MATERIAL_LINE_STRIP",
        "7": "MATERIAL_QUADS",
        "MATERIAL_TRIANGLE_STRIP": {
          "description": "MATERIAL_TRIANGLE_STRIP",
          "client": true
        },
        "MATERIAL_LINE_LOOP": {
          "description": "MATERIAL_LINE_LOOP",
          "client": true
        },
        "MATERIAL_POLYGON": {
          "description": "MATERIAL_POLYGON",
          "client": true
        },
        "MATERIAL_TRIANGLES": {
          "description": "MATERIAL_TRIANGLES",
          "client": true
        },
        "MATERIAL_QUADS": {
          "description": "MATERIAL_QUADS",
          "client": true
        },
        "MATERIAL_LINE_STRIP": {
          "description": "MATERIAL_LINE_STRIP",
          "client": true
        },
        "MATERIAL_LINES": {
          "description": "MATERIAL_LINES",
          "client": true
        }
      },
      "client": true
    },
    "rendertarget": {
      "functions": {
        "1": "create",
        "2": "createWithSize",
        "3": "getMaxRTCount",
        "4": "getRemainingRTCount",
        "getRemainingRTCount": {
          "ret": "The number of RTs that can still be created.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Provides the remaining number of RTs that may be created."
        },
        "getMaxRTCount": {
          "ret": "The maximum number of RTs that may be created.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Provides the maximum number of RTs that may be created. This applies at the player level."
        },
        "create": {
          "ret": "The render target, or nil if no further render targets can be created.",
          "returntypes": [
            [
              "RenderTarget",
              "nil"
            ]
          ],
          "client": true,
          "description": "Requests a new render target. These are limited to a fixed amount per player.",
          "param": {
            "1": "highRes",
            "2": "w",
            "3": "h",
            "highRes": "When no W/H is given: if true, the RT is the \"highres\" resolution. If false it is the standard screen size.",
            "h": "(Optional) This sets a custom height. Must be a power of 2, or it will error.",
            "w": "(Optional) This sets a custom width. Must be a power of 2, or it will error."
          }
        },
        "createWithSize": {
          "ret": "The render target, or nil if no further render targets can be created.",
          "returntypes": [
            [
              "RenderTarget",
              "nil"
            ]
          ],
          "client": true,
          "description": "Requests a new render target with the given dimensions.",
          "param": {
            "1": "width",
            "2": "height",
            "height": "The height of the texture. Must be a power of 2.",
            "width": "The width of the texture. Must be a power of 2."
          }
        }
      },
      "description": "Render target library. Use it to create a render target texture object to draw to.",
      "client": true
    },
    "timer": {
      "functions": {
        "1": "adjust",
        "2": "canCreate",
        "3": "create",
        "4": "exists",
        "5": "getCount",
        "6": "getMax",
        "7": "pause",
        "8": "remove",
        "9": "repsLeft",
        "10": "simple",
        "11": "start",
        "12": "stop",
        "13": "timeLeft",
        "14": "unpause",
        "simple": {
          "description": "Creates a simple timer, has no name, can't be stopped, paused, or destroyed.",
          "param": {
            "1": "delay",
            "2": "func",
            "func": "The function to call when the timer is fired.",
            "delay": "The time, in second, to set the timer to."
          }
        },
        "getMax": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the maximum permitted number of active timers."
        },
        "adjust": {
          "ret": "True if the adjustment succeeded.",
          "returntypes": [
            "boolean"
          ],
          "description": "Adjusts an existing timer",
          "param": {
            "1": "name",
            "2": "delay",
            "3": "reps",
            "4": "func",
            "func": "The new function to call when the timer is fired.",
            "reps": "The new repititions of the timer. 0 = infinte.",
            "delay": "The new delay value to use",
            "name": "The timer name"
          }
        },
        "exists": {
          "ret": "True if the timer exists, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given timer exists.",
          "param": {
            "1": "name",
            "name": "Name of the timer to check."
          }
        },
        "create": {
          "description": "Creates a timer",
          "param": {
            "1": "name",
            "2": "delay",
            "3": "reps",
            "4": "func",
            "func": "The function to call when the timer is fired.",
            "reps": "The repititions of the timer. 0 = infinte.",
            "delay": "The time, in seconds, to set the timer to.",
            "name": "The timer name"
          }
        },
        "timeLeft": {
          "ret": "Time in seconds until the timer next executes.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the time left before the timer next executes its function.",
          "param": [
            "name"
          ]
        },
        "repsLeft": {
          "ret": "Number of repetitions left.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the number of repetitions left before the timer is destroyed.",
          "param": [
            "name"
          ]
        },
        "remove": {
          "description": "Removes a timer",
          "param": {
            "1": "name",
            "name": "Timer name"
          }
        },
        "canCreate": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether a new timer can be created without exceeding the quota."
        },
        "unpause": {
          "ret": "True if the timer exists and was paused, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Unpauses an existing timer",
          "param": {
            "1": "name",
            "name": "The timer name"
          }
        },
        "start": {
          "ret": "True if the timer exists and was stopped, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Starts an existing timer",
          "param": {
            "1": "name",
            "name": "The timer Name"
          }
        },
        "getCount": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the number of timers currently active."
        },
        "pause": {
          "ret": "True if the timer exists and was not paused, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Pauses an existing timer",
          "param": {
            "1": "name",
            "name": "The timer name"
          }
        },
        "stop": {
          "ret": "True if the timer exists and was running, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Stops an existing timer",
          "param": {
            "1": "name",
            "name": "The timer name"
          }
        }
      },
      "description": "Deals with timers.",
      "client": true,
      "server": true
    },
    "emoji": {
      "functions": {
        "1": "canDraw",
        "2": "draw",
        "3": "getList",
        "draw": {
          "client": true,
          "description": "Draws the given emoji at the given position and with the given width and height.",
          "param": {
            "1": "emojiName",
            "2": "x",
            "3": "y",
            "4": "w",
            "5": "h",
            "y": "The y co-ordinate to draw the emoji at.",
            "h": "The height to apply to the drawn emoji.",
            "w": "The width to apply to the drawn emoji.",
            "x": "The x co-ordinate to draw the emoji at.",
            "emojiName": "The name of the emoji to draw. If an invalid name is given, nothing will be rendered."
          }
        },
        "getList": {
          "returntypes": [
            "table<number,string>"
          ],
          "client": true,
          "description": "Returns a list of all available emoji names."
        },
        "canDraw": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns true if the given emoji name is valid and can be drawn. False otherwise.",
          "param": {
            "1": "emojiName",
            "emojiName": "The name of the emoji to check."
          }
        }
      },
      "description": "Emoji library, used to draw emoji.",
      "client": true
    },
    "starfall": {
      "functions": {
        "1": "getAuthor",
        "2": "getLibraries",
        "3": "getMainFileName",
        "4": "getName",
        "5": "getScripts",
        "6": "getTypeDef",
        "7": "isInstanceOf",
        "8": "isSpawnedFromDuplicator",
        "9": "setName",
        "10": "showOverlay",
        "getLibraries": {
          "ret": "A table containing the names of all available libraries.",
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Gets a list of all library names."
        },
        "isInstanceOf": {
          "ret": "True if the given object is, or inherits from the given type.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given object is an instance of the given type. \nThat is, if the given object either is the given type, or inherits from it.",
          "param": {
            "1": "object",
            "2": "type",
            "type": "The name of the type to check for.",
            "object": "The object to check."
          }
        },
        "getTypeDef": {
          "ret": "If the type exists, then a table which you can add methods to. Otherwise nil.",
          "returntypes": [
            "table"
          ],
          "usage": "-- Get the \"Player\" type. \nlocal Player = starfall.getTypeDef( \"Player\" ) \n \n-- Add a new method to check if the player's an ally. \nfunction Player:isFactionAlly() \n\treturn faction.isAlly( self ) \nend \n \n-- The new method's ready and can be used on any player object now! \nprint( ents.owner():isFactionAlly() ) -- True if you're in a faction.",
          "description": "Returns a table which you can add new methods for the given type to. \nNote that native types (Angle, Color, Vector) cannot be extended.",
          "param": {
            "1": "name",
            "name": "The name of the type you want to extend, e.g \"Entity\"."
          }
        },
        "getAuthor": {
          "ret": "The entity's Starfall author.",
          "returntypes": [
            "string"
          ],
          "description": "Provides the author of the given entity's instance.",
          "param": {
            "1": "starfallEntity",
            "starfallEntity": "(Optional) The entity to get the author of. If not provided, the entity executing this function will be used."
          }
        },
        "getName": {
          "ret": "The entity's Starfall name.",
          "returntypes": [
            "string"
          ],
          "description": "Provides the current name of the given entity's instance.",
          "param": {
            "1": "starfallEntity",
            "starfallEntity": "(Optional) The entity to get the name of. If not provided, the entity executing this function will be used."
          }
        },
        "showOverlay": {
          "client": true,
          "description": "Sets whether to show the overlay with the chip name, CPU time etc.",
          "param": {
            "1": "show",
            "show": "Whether to show the overlay."
          }
        },
        "setName": {
          "description": "Changes the name of the running chip.",
          "param": {
            "1": "name",
            "name": "The name to use."
          }
        },
        "isSpawnedFromDuplicator": {
          "ret": "True if the current instance's entity was spawned from a duplicator.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the current instance's entity spawned from a duplicator."
        },
        "getMainFileName": {
          "ret": "The main file's name.",
          "returntypes": [
            "string"
          ],
          "description": "Provides the name of the main file used to load the running script."
        },
        "getScripts": {
          "ret": "Table of filepath -> function pairs.",
          "returntypes": [
            "table<string,function>"
          ],
          "usage": "-- This snippet loads all script files. \nlocal Scripts = starfall.getScripts() \nfor FilePath, CompiledScript in pairs( Scripts ) do \n\t-- If you want to only load those from a certain folder, check FilePath starts with the folder path. \n\t-- Calling the CompiledScript function loads the script file. \n\tCompiledScript() \nend",
          "description": "Returns every included script file in a table of filepath -> function pairs. \nCall a function to run the file in the same way as dofile()."
        }
      },
      "description": "Starfall library. Used for introspection of the running instance."
    },
    "sounds": {
      "functions": {
        "1": "create",
        "2": "duration",
        "3": "emitEntity",
        "4": "emitWorld",
        "5": "exists",
        "6": "playFile",
        "7": "playURL",
        "8": "stop",
        "emitEntity": {
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Plays a sound from an entity. Quick alternative to sounds.create if you don't need the extra bit of control. \nRequires the PLAY_CLIENT_SOUNDS permission when used on the client side.",
          "param": {
            "1": "entity",
            "2": "path",
            "3": "soundLevel",
            "4": "pitch",
            "pitch": "(Optional) Pitch percent, from 0 to 255.",
            "soundLevel": "(Optional) The sound level (in decibels), between 10 and 511.",
            "path": "The name of the sound to emit (either a file name, or a sound script name).",
            "entity": "The entity to emit the sound from."
          }
        },
        "playFile": {
          "client": true,
          "description": "Plays a file from the given file path using IGModAudioChannel. \nThis has a few distinct advantages over traditional sounds, including FFT data, playback rate adjusting, time seeking and more. \nRequires the PLAY_CLIENT_SOUNDS permission.",
          "param": {
            "1": "path",
            "2": "flags",
            "3": "callback",
            "path": "The filepath to the sound you want to play.",
            "callback": "Function to run when the audio channel is ready to play. Receives the channel, and if an error occurred, an error ID and error name.",
            "flags": "Space separated flags. Any of: \"3d\", \"mono\", \"noplay\", \"noblock\"."
          }
        },
        "exists": {
          "ret": "True if the given sound path exists, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Checks if the given sound path exists.",
          "param": {
            "1": "path",
            "path": "The path to check."
          }
        },
        "stop": {
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Stops a sound started by emitEntity() on the given entity. Note that this only works for sound scripts. \nRequires the PLAY_CLIENT_SOUNDS permission when used on the client side.",
          "param": {
            "1": "entity",
            "2": "scriptName",
            "scriptName": "The name of the sound script to stop (that was previously started with emitEntity()).",
            "entity": "The entity to stop the sound on."
          }
        },
        "emitWorld": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Plays a sound from a fixed point in the world.",
          "param": {
            "1": "origin",
            "2": "path",
            "3": "soundLevel",
            "4": "pitch",
            "pitch": "(Optional) Pitch percent, from 0 to 255.",
            "soundLevel": "(Optional) The sound level (in decibels), between 10 and 511.",
            "path": "Filepath to the sound file.",
            "origin": "The position in the world to emit the sound from."
          }
        },
        "duration": {
          "ret": "The duration of the sound (in seconds).",
          "returntypes": [
            "number"
          ],
          "description": "Returns the duration of the sound in seconds. Only works on .wav files, \nand there are other issues as well.",
          "param": {
            "1": "path",
            "path": "The file path to get the duration for."
          }
        },
        "create": {
          "ret": "The sound object. Keep this around to ensure it isn't GC'd (and thus stopped) \nbefore it is done playing.",
          "returntypes": [
            "Sound"
          ],
          "description": "Creates a sound and attaches it to an entity. You need to do sound:play() before the sound will play however. \nRequires the PLAY_CLIENT_SOUNDS permission when used on the client side.",
          "param": {
            "1": "entity",
            "2": "path",
            "path": "Filepath to the sound file.",
            "entity": "Entity playing the sound"
          }
        },
        "playURL": {
          "client": true,
          "description": "Plays a sound from the given URL. Requires the PLAY_URL_SOUNDS permission.",
          "param": {
            "1": "url",
            "2": "flags",
            "3": "callback",
            "callback": "Function to run when the audio channel is ready to play. Receives the channel, and if an error occurred, an error ID and error name.",
            "url": "The URL pointing at a valid sound file or stream.",
            "flags": "Space separated flags. Any of: \"3d\", \"mono\", \"noplay\", \"noblock\"."
          }
        }
      },
      "description": "Sound functions. Plays and manipulates sounds, optionally \nattaching them to an entity.",
      "fields": {
        "1": "GMOD_CHANNEL_STOPPED",
        "2": "GMOD_CHANNEL_PLAYING",
        "3": "GMOD_CHANNEL_PAUSED",
        "4": "GMOD_CHANNEL_STALLED",
        "5": "FFT_256",
        "6": "FFT_512",
        "7": "FFT_1024",
        "8": "FFT_2048",
        "9": "FFT_4096",
        "10": "FFT_8192",
        "11": "FFT_16384",
        "12": "FFT_32768",
        "FFT_256": {
          "description": "FFT_256"
        },
        "FFT_8192": {
          "description": "FFT_8192"
        },
        "FFT_16384": {
          "description": "FFT_16384"
        },
        "GMOD_CHANNEL_PAUSED": {
          "description": "GMOD_CHANNEL_PAUSED"
        },
        "GMOD_CHANNEL_STOPPED": {
          "description": "GMOD_CHANNEL_STOPPED"
        },
        "GMOD_CHANNEL_PLAYING": {
          "description": "GMOD_CHANNEL_PLAYING"
        },
        "FFT_4096": {
          "description": "FFT_4096"
        },
        "FFT_1024": {
          "description": "FFT_1024"
        },
        "GMOD_CHANNEL_STALLED": {
          "description": "GMOD_CHANNEL_STALLED"
        },
        "FFT_512": {
          "description": "FFT_512"
        },
        "FFT_2048": {
          "description": "FFT_2048"
        },
        "FFT_32768": {
          "description": "FFT_32768"
        }
      }
    },
    "von": {
      "functions": {
        "1": "deserialize",
        "2": "serialize",
        "deserialize": {
          "ret": "The vON data as a table, or nil if it was not valid vON.",
          "returntypes": [
            "table"
          ],
          "description": "Deserialises a vON encoded string. Returns the deserialised table.",
          "param": {
            "1": "string",
            "string": "A string of vON encoded data."
          }
        },
        "serialize": {
          "ret": "A vON string representing the table.",
          "returntypes": [
            "string"
          ],
          "description": "Serialises a table using vON. Returns the serialised string.",
          "param": {
            "1": "table",
            "table": "The table to be serialised."
          }
        }
      },
      "description": "VON library.",
      "client": true,
      "server": true
    },
    "quaternion": {
      "functions": {
        "1": "New",
        "2": "abs",
        "3": "conj",
        "4": "exp",
        "5": "fromAngles",
        "6": "fromAxis",
        "7": "fromComponents",
        "8": "fromEntity",
        "9": "fromNumber",
        "10": "fromNumberAndVector",
        "11": "fromVector",
        "12": "inv",
        "13": "log",
        "14": "qMod",
        "15": "qRotation",
        "16": "qRotationAxis",
        "17": "qi",
        "18": "qj",
        "19": "qk",
        "20": "rotationAngle",
        "21": "rotationAxis",
        "22": "rotationVector",
        "23": "slerp",
        "24": "vec",
        "conj": {
          "ret": "The conjugate of the given quaternion.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns the conjugate of q.",
          "param": {
            "1": "q",
            "q": "The quaternion to get the conjugate of."
          }
        },
        "log": {
          "ret": "The natural logarithm of the given quaternion.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns the natural logarithm of q.",
          "param": {
            "1": "q",
            "q": "The quaternion to apply the natural logarithm to."
          }
        },
        "fromAngles": {
          "ret": "A quaternion representing the given angles.",
          "description": "Creates a quaternion representing the given angles.",
          "returntypes": [
            "Quaternion"
          ],
          "param": {
            "1": "angles",
            "angles": "The angles to represent."
          }
        },
        "exp": {
          "ret": "e raised to the power of the given quaternion.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns Euler's constant e raised to the power q.",
          "param": {
            "1": "q",
            "q": "The quaternion to raise e to the power of."
          }
        },
        "slerp": {
          "ret": "A quaternion that is between q0 and q1, spherically interpolated based on the value of t.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Performs spherical interpolation between q0 and q1. Returns q0 for t = 0, q1 for t = 1.",
          "param": {
            "1": "q0",
            "2": "q1",
            "3": "t",
            "t": "The fraction between the 2 quaternions (between 0 and 1).",
            "q1": "The target quaternion.",
            "q0": "The starting quaternion."
          }
        },
        "fromNumber": {
          "ret": "A quaternion whose real part is equal to the given value, with no imaginary parts.",
          "description": "Creates a quaternion with real part equal to the given number.",
          "returntypes": [
            "Quaternion"
          ],
          "param": {
            "1": "real",
            "real": "The real part."
          }
        },
        "fromNumberAndVector": {
          "ret": "A quaternion whose real part is the given number, and imginary parts are taken from the given vector (i, j, k).",
          "description": "Creates a quaternion whose real part is the given number, and whose imaginary parts are taken from the given vector.",
          "returntypes": [
            "Quaternion"
          ],
          "param": {
            "1": "real",
            "2": "imaginaryParts",
            "imaginaryParts": "The imaginary parts as a Vector.",
            "real": "The real part."
          }
        },
        "fromVector": {
          "ret": "A quaternion whose real part is 0, and imginary parts are taken from the given vector (i, j, k).",
          "description": "Creates a quaternion with imaginary parts set from the given vector.",
          "returntypes": [
            "Quaternion"
          ],
          "param": {
            "1": "imaginaryParts",
            "imaginaryParts": "The imaginary parts as a Vector."
          }
        },
        "qMod": {
          "ret": "A new quaternion with a normalised angle.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Changes quaternion q so that the represented rotation is by an angle between 0 and 180 degrees.",
          "param": {
            "1": "q",
            "q": "The quaternion to normalise."
          }
        },
        "New": {
          "ret": "A new quaternion whose values depend on the provided input.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Creates a new Quaternion given a variety of inputs",
          "param": {
            "1": "...",
            "...": "A series of arguments which lead to valid generation of a quaternion. \nAcceptable inputs are: \n- A single number for the real part. \n- 4 numbers for the real and 3 imaginary parts. \n- A vector which populates the imaginary parts. \n- An angle object. \n- A number and a vector to populate the real and imaginary parts. \n- 2 vectors to populate with the angle of the cross product between them. \n- An entity which populates using the entity's angles."
          }
        },
        "fromComponents": {
          "ret": "A quaternion with the given components.",
          "description": "Creates a quaternion from the given components.",
          "returntypes": [
            "Quaternion"
          ],
          "param": {
            "1": "real",
            "2": "i",
            "3": "j",
            "4": "k",
            "i": "The i component.",
            "k": "The k component.",
            "j": "The j component.",
            "real": "The real part."
          }
        },
        "qk": {
          "ret": "A quaternion whose k component is n and all others are 0.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns Quaternion n * k",
          "param": {
            "1": "n",
            "n": "The value of the k component."
          }
        },
        "qj": {
          "ret": "A quaternion whose j component is n and all others are 0.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns Quaternion n * j",
          "param": {
            "1": "n",
            "n": "The value of the j component."
          }
        },
        "abs": {
          "ret": "The absolute value of the given quaternion.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the absolute value of q.",
          "param": {
            "1": "q",
            "q": "The quaternion to get the absolute value of."
          }
        },
        "rotationAxis": {
          "ret": "The axis of rotation.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the axis of rotation.",
          "param": {
            "1": "q",
            "q": "The quaternion to extract the rotation axis from."
          }
        },
        "qi": {
          "ret": "A quaternion whose i component is n and all others are 0.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns Quaternion n * i",
          "param": {
            "1": "n",
            "n": "The value of the i component."
          }
        },
        "inv": {
          "ret": "The inverse of the given quaternion.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns the inverse of q.",
          "param": {
            "1": "q",
            "q": "The quaternion to get the inverse of."
          }
        },
        "fromAxis": {
          "ret": "A quaternion representing the world angles of the basis' forward direction, accounting for roll.",
          "description": "Creates a quaternion representing the angles expressed by the given basis vectors.",
          "returntypes": [
            "Quaternion"
          ],
          "param": {
            "1": "forward",
            "2": "up",
            "up": "The up direction of the basis.",
            "forward": "The forward direction of the basis."
          }
        },
        "rotationVector": {
          "ret": "A vector representing the rotation vector of the given quaternion.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the rotation vector represented by the given quaternion, where the magnitude is the angle of rotation in degress.",
          "param": {
            "1": "q",
            "q": "The quaternion to extract the rotation vector from."
          }
        },
        "rotationAngle": {
          "ret": "The angle of rotation represented by the given quaternion, in degrees.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the angle of rotation in degrees.",
          "param": {
            "1": "q",
            "q": "The quaternion to extract the rotation angle from."
          }
        },
        "qRotation": {
          "ret": "A quaternion that, when applied to a vector, rotates it by the given direction and magnitude in degrees.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Constructs a quaternion from the rotation vector rotVec. \nVector direction is axis of rotation, magnitude is angle in degrees.",
          "param": {
            "1": "rotVec",
            "rotVec": "The rotation vector to be represented as a quaternion."
          }
        },
        "qRotationAxis": {
          "ret": "A quaternion that, when applied to a vector, rotates it around the given axis by the given angle in degrees.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns a quaternion for rotation about the given axis by the given angle.",
          "param": {
            "1": "axis",
            "2": "ang",
            "ang": "The magntidue of rotation (in degrees).",
            "axis": "The axis of rotation."
          }
        },
        "vec": {
          "ret": "A vector whose components are the i, j, k components of the quaternion.",
          "returntypes": [
            "Vector"
          ],
          "description": "Converts q to a vector by dropping the real component.",
          "param": {
            "1": "q",
            "q": "The quaternion to extract the imaginary parts from."
          }
        },
        "fromEntity": {
          "ret": "A quaternion representing the angles of the given entity.",
          "description": "Creates a quaternion representing the angles of the given entity.",
          "returntypes": [
            "Quaternion"
          ],
          "param": {
            "1": "entity",
            "entity": "The entity whose angles should be used."
          }
        }
      },
      "description": "Quaternion library.",
      "client": true,
      "server": true
    },
    "builtin": {
      "description": "Built in values. These can be found in the global table.",
      "functions": {
        "1": "Angle",
        "2": "CRC",
        "3": "Color",
        "4": "GetTypeDef",
        "5": "HSVToColor",
        "6": "IsValid",
        "7": "Material",
        "8": "Matrix",
        "9": "Mesh",
        "10": "Quaternion",
        "11": "Vector",
        "12": "assert",
        "13": "compileString",
        "14": "cpuAverage",
        "15": "cpuMax",
        "16": "cpuTime",
        "17": "doAll",
        "18": "dofile",
        "19": "error",
        "20": "getLibraries",
        "21": "getScripts",
        "22": "getfenv",
        "23": "getmetatable",
        "24": "hint",
        "25": "ipairs",
        "26": "load",
        "27": "loadstring",
        "28": "localToWorld",
        "29": "next",
        "30": "opsMax",
        "31": "opsUsed",
        "32": "pairs",
        "33": "pcall",
        "34": "print",
        "35": "printColor",
        "36": "printConsole",
        "37": "rawequal",
        "38": "rawget",
        "39": "rawset",
        "40": "require",
        "41": "requireAll",
        "42": "select",
        "43": "setName",
        "44": "setfenv",
        "45": "setmetatable",
        "46": "showOverlay",
        "47": "tonumber",
        "48": "tostring",
        "49": "type",
        "50": "unpack",
        "51": "worldToLocal",
        "52": "xpcall",
        "printConsole": {
          "description": "Prints a message to your console. Limited to 254 characters on the server.",
          "param": [
            "..."
          ]
        },
        "xpcall": {
          "ret": [
            "true if execution succeeded without error, false otherwise.",
            "If execution failed, the error message. Otherwise, all returned values from the function."
          ],
          "returntypes": [
            "boolean",
            "Any..."
          ],
          "usage": "local function ErrorHandler( Error ) \n\tprint( \"Failed with error:\", Error ) \nend \nlocal function MyAwesomeFunc( ... ) \n\tprint( \"Thanks for\", ... ) \nend \nlocal Success, Err = xpcall( MyAwesomeFunc, ErrorHandler, \"cake\", \"cookies\", \"milk\" )",
          "description": "Runs the given function and calls the given callback function on error.",
          "param": {
            "1": "func",
            "2": "callback",
            "3": "...",
            "...": "Arguments to pass to Func when calling.",
            "callback": "Function to run on error. Is passed the errror.",
            "func": "Function to run."
          }
        },
        "compileString": {
          "ret": "Compiled function, or nil and an error string if there's a syntax error.",
          "description": "Compiles the given string and returns it as a function, or nil and a string if there is a syntax error.",
          "deprecated": "Use load.",
          "returntypes": [
            "function",
            "string"
          ],
          "param": {
            "1": "code",
            "2": "name",
            "3": "env",
            "env": "(Optional) Environment to assign to the chunk.",
            "name": "(Optional) Name to assign to the chunk.",
            "code": "Lua code string to compile."
          }
        },
        "cpuAverage": {
          "ret": "Current average CPU time in seconds.",
          "returntypes": [
            "number"
          ],
          "description": "Gets the average CPU time spent running used for the average quota."
        },
        "Vector": {
          "ret": "A new vector object with the given initial components.",
          "description": "Creates a new vector object. Omitting the components will default them to 0.",
          "returntypes": [
            "Vector"
          ],
          "param": {
            "1": "x",
            "2": "y",
            "3": "z",
            "y": "Initial value of the y component.",
            "x": "Initial value of the x component.",
            "z": "Initial value of the z component."
          }
        },
        "unpack": {
          "ret": "A value per entry in the table unpacked.",
          "description": "Unpacks the values in the given table into individual return values.",
          "returntypes": [
            "Any..."
          ],
          "param": {
            "1": "table",
            "2": "index",
            "3": "endIndex",
            "endIndex": "(Optional) The index to finish unpacking at. Defaults to #table.",
            "index": "(Optional) The index to start unpacking from. Defaults to 1.",
            "table": "Table to unpack into a vararg."
          }
        },
        "require": {
          "ret": "The return value of the executed file, cached if it has already been required.",
          "description": "Runs an --@include'd script and caches the result. \nWorks pretty much like standard Lua require()",
          "param": {
            "1": "file",
            "file": "The filename to execute, must have been included."
          }
        },
        "getfenv": {
          "ret": "Environment table of the current function.",
          "returntypes": [
            "table"
          ],
          "description": "Gets the current function environment."
        },
        "GetTypeDef": {
          "ret": "If the type exists, then a table which you can add methods to. Otherwise nil.",
          "deprecated": "Use starfall.getTypeDef() instead.",
          "returntypes": [
            "table"
          ],
          "description": "Returns a table which you can add new methods for the given type to.",
          "param": {
            "1": "name",
            "name": "The name of the type you want to extend, e.g \"Entity\"."
          }
        },
        "next": {
          "ret": [
            "The next key after the one provided.",
            "The value at the next key."
          ],
          "description": "Provides the next key-value pair in the given table. Note that the meaning of next has no guaranteed order.",
          "returntypes": [
            "%1=table<1>",
            "%1=table<2>"
          ],
          "param": {
            "1": "table",
            "2": "key",
            "key": "(Optional) The key to start at.",
            "table": "Table to get the next key-value pair of."
          }
        },
        "assert": {
          "ret": "The condition value provided, if it is not false-y.",
          "returntypes": [
            "%1"
          ],
          "description": "Throws an error if the condition parameter is not truthy. Returns the condition parameter otherwise.",
          "param": {
            "1": "condition",
            "2": "msg",
            "condition": "Condition that evaluates to true on success, and false-y on failure.",
            "msg": "Error value to throw if the condition value is false-y."
          }
        },
        "tonumber": {
          "ret": "The object as a number, or nil if it cannot be converted.",
          "description": "Converts the given value into its number representation.",
          "returntypes": [
            "number"
          ],
          "param": {
            "1": "object",
            "object": "Object to be converted to a number."
          }
        },
        "showOverlay": {
          "deprecated": "Use starfall.showOverlay() instead.",
          "client": true,
          "description": "Sets whether to show the overlay with the chip name, CPU time etc.",
          "param": {
            "1": "show",
            "show": "Whether to show the overlay."
          }
        },
        "localToWorld": {
          "description": "Converts a local space vector into a world space vector.",
          "returntypes": [
            "Vector",
            "Angle"
          ],
          "param": {
            "1": "localPos",
            "2": "localAng",
            "3": "originPos",
            "4": "originAng",
            "originPos": "Co-ordinate system origin.",
            "originAng": "Angles the system translates from.",
            "localPos": "Local position.",
            "localAng": "Local angle."
          }
        },
        "rawequal": {
          "ret": "True if both values are equal, ignoring __eq. False otherwise.",
          "description": "Determines if two values are equal without using either value's __eq metamethod.",
          "returntypes": [
            "boolean"
          ],
          "param": {
            "1": "v1",
            "2": "v2",
            "v2": "Second value to compare.",
            "v1": "First value to compare."
          }
        },
        "IsValid": {
          "ret": "True if the object is \"valid\", false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the passed in value is not nil, has an \"isValid\" method and that method returns true.",
          "param": {
            "1": "object",
            "object": "The object to check for validity."
          }
        },
        "load": {
          "ret": "Compiled function, or nil and an error string if there's a syntax error.",
          "description": "Compiles the given string and returns it as a function, or nil and a string if there is a syntax error.",
          "returntypes": [
            "function",
            "string"
          ],
          "param": {
            "1": "code",
            "2": "name",
            "3": "env",
            "env": "(Optional) Environment to assign to the chunk.",
            "name": "(Optional) Name to assign to the chunk.",
            "code": "Lua code string to compile."
          }
        },
        "Mesh": {
          "ret": "New IMesh.",
          "returntypes": [
            "IMesh"
          ],
          "client": true,
          "description": "Creates a new IMesh object to hold static mesh data.",
          "param": {
            "1": "materialHint",
            "materialHint": "(Optional) An IMaterial that the mesh will be used with. Provides a hint for the mesh's internal format."
          }
        },
        "getmetatable": {
          "ret": "The metatable assigned to the given metatable, or nil if it does not have one.",
          "returntypes": [
            "table"
          ],
          "description": "Retrieves the metatable of the given table.",
          "param": {
            "1": "table",
            "table": "Table to get the metatable of."
          }
        },
        "HSVToColor": {
          "ret": "A new Color object with values converted into RGB from HSV.",
          "deprecated": "Use Color.fromHSV() instead.",
          "returntypes": [
            "Color"
          ],
          "description": "Returns a colour object from the given HSV values",
          "param": {
            "1": "h",
            "2": "s",
            "3": "v",
            "4": "a",
            "a": "(Optional) Alpha value, defaults to 255.",
            "v": "Value, 0 - 1",
            "s": "Saturation, 0 - 1",
            "h": "Hue, 0 - 1"
          }
        },
        "getLibraries": {
          "ret": "A table containing the names of all available libraries.",
          "deprecated": "Use starfall.getLibraries() instead.",
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Gets a list of all libraries"
        },
        "Quaternion": {
          "ret": "A quaternion with the given components.",
          "description": "Creates a quaternion from the given components.",
          "returntypes": [
            "Quaternion"
          ],
          "param": {
            "1": "real",
            "2": "i",
            "3": "j",
            "4": "k",
            "i": "The i component.",
            "k": "The k component.",
            "j": "The j component.",
            "real": "The real part."
          }
        },
        "dofile": {
          "ret": "The return value of the executed file, not cached.",
          "description": "Runs an --@include'd file and returns the result. \nPretty much like standard Lua dofile()",
          "param": {
            "1": "file",
            "file": "The filename to execute, must have been included."
          }
        },
        "CRC": {
          "ret": "The CRC32 value as a string.",
          "returntypes": [
            "string"
          ],
          "description": "Returns a CRC32 value of the given string.",
          "param": {
            "1": "string",
            "string": "The string to compute the CRC32 value for."
          }
        },
        "Color": {
          "ret": "A new colour object with r, g, b, a fields.",
          "description": "Provides a new colour object. All values should be between 0 and 255.",
          "returntypes": [
            "Color"
          ],
          "param": {
            "1": "r",
            "2": "g",
            "3": "b",
            "4": "a",
            "a": "(Optional) Initial alpha value, defaults to 255.",
            "b": "Initial blue value.",
            "g": "Initial green value.",
            "r": "Initial red value."
          }
        },
        "rawset": {
          "description": "Sets a value on the given table without triggering __newindex. \nThis does not work on library tables or locked types.",
          "param": {
            "1": "table",
            "2": "key",
            "3": "value",
            "value": "The value to write.",
            "key": "The key to write to.",
            "table": "the table to set the value on."
          }
        },
        "opsMax": {
          "deprecated": "Ops no longer affect performance quotas.",
          "description": "Gets the ops hard quota"
        },
        "tostring": {
          "ret": "The object as a string, never nil.",
          "description": "Converts the given value into its string representation.",
          "returntypes": [
            "string"
          ],
          "param": {
            "1": "object",
            "object": "Object to be converted to a string."
          }
        },
        "doAll": {
          "description": "Runs every file you included. \nBe careful with files that only belong on the server/client, it won't discriminate."
        },
        "Angle": {
          "ret": "A new angle object with the given initial components.",
          "description": "Creates a new angle object. Omitting the components will default them to 0.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "p",
            "2": "y",
            "3": "r",
            "y": "Initial value of the yaw component.",
            "p": "Initial value of the pitch component.",
            "r": "Initial value of the roll component."
          }
        },
        "cpuTime": {
          "ret": "Current execution CPU time in seconds.",
          "returntypes": [
            "number"
          ],
          "description": "Gets the amount of time spent running so far."
        },
        "cpuMax": {
          "ret": "Quota in seconds.",
          "returntypes": [
            "number"
          ],
          "description": "Gets the CPU time hard quota"
        },
        "ipairs": {
          "description": "Provides a sequential iterator for tables.",
          "returntypes": [
            "function<number,%1=table<2>>"
          ],
          "param": {
            "1": "table",
            "table": "Table to iterate in order starting at index 1."
          }
        },
        "Material": {
          "ret": "New IMaterial, or nil if the given path is invalid.",
          "returntypes": [
            [
              "IMaterial",
              "nil"
            ]
          ],
          "usage": "-- Load a PNG material, setting the \"noclamp\" and \"smooth\" parameters. \nlocal WaveMaterial = Material( \"vgui/wave.png\", \"noclamp smooth\" )",
          "client": true,
          "description": "Returns a new IMaterial from the given path. \nNote that materials with a shader that is not UnlitGeneric will not render correctly in 2D contexts like screens and \nHUDs. For such materials, use render.getTextureID( path ) to get an unlit version.",
          "param": {
            "1": "path",
            "2": "option",
            "option": "If a PNG file, then any combination (separated by spaces) of: \n- vertexlitgeneric \n- unlitgeneric \n- nocull \n- alphatest \n- mips \n- noclamp \n- smooth",
            "path": "The path to the material (excluding materials/)."
          }
        },
        "pcall": {
          "ret": [
            "true if execution succeeded without error, false otherwise.",
            "If execution failed, the error message. Otherwise, all returned values from the function."
          ],
          "returntypes": [
            "boolean",
            "Any..."
          ],
          "usage": "local function MyAwesomeFunc( ... ) \n\tprint( \"Thanks for\", ... ) \nend \nlocal Success, Err = pcall( MyAwesomeFunc, \"cake\", \"cookies\", \"milk\" )",
          "description": "Runs the given function and catches any errors. Returns true, return values on success, false, error on fail.",
          "param": {
            "1": "func",
            "2": "...",
            "...": "Arguments to pass to Func when calling.",
            "func": "Function to run."
          }
        },
        "hint": {
          "description": "Shows a gamemode hint to the chip owner.",
          "param": {
            "1": "message",
            "2": "type",
            "3": "duration",
            "message": "The string message to display.",
            "duration": "How long to show the message for.",
            "type": "The type of message, one of NOTIFY_GENERIC, NOTIFY_ERROR or NOTIFY_HINT."
          }
        },
        "opsUsed": {
          "deprecated": "Ops no longer affect performance quotas.",
          "description": "Gets the amount of ops used so far"
        },
        "Matrix": {
          "ret": "A new VMatrix object with the given initial values or otherwise the identity matrix.",
          "returntypes": [
            "VMatrix"
          ],
          "usage": "local Values = { \n\t{ 1, 0, 0, 4 }, \n\t{ 0, 2, 0, 5 }, \n\t{ 0, 0, 3, 6 }, \n\t{ 0, 0, 0, 1 } \n} \nlocal NewMatrix = Matrix( Values )",
          "description": "Creates a new VMatrix.",
          "param": {
            "1": "data",
            "data": "(Optional) A 4x4 table of values to initialise the matrix with."
          }
        },
        "printColor": {
          "usage": "printColor( Color( 255, 0, 0 ), \"This text is in red! \", \n\tColor( 255, 255, 255 ), \"This text is in white!\" )",
          "description": "Prints a message to the chip owner's chat in colour.",
          "param": [
            "..."
          ]
        },
        "print": {
          "description": "Prints a message to the player's chat. Limited to 254 characters on the server.",
          "param": [
            "..."
          ]
        },
        "select": {
          "ret": "The values starting at the given index until the end of the vararg, or the size of the vararg if \"#\" was the index.",
          "description": "Selects values from a vararg.",
          "returntypes": [
            [
              "number",
              "Any..."
            ]
          ],
          "param": {
            "1": "index",
            "2": "vararg",
            "index": "Index to start at, or \"#\" to get the size of the vararg.",
            "vararg": "Vararg to retrieve value/size from."
          }
        },
        "type": {
          "ret": "The type name for the given object, e.g. \"string\", \"number\" etc.",
          "description": "Provides the name of the type of the given object.",
          "returntypes": [
            "string"
          ],
          "param": {
            "1": "value",
            "value": "Value to retrieve the type of."
          }
        },
        "setmetatable": {
          "ret": "The passed in table.",
          "description": "Sets a metatable on the given table, providing its metatable is not locked.",
          "returntypes": [
            "table"
          ],
          "param": {
            "1": "table",
            "2": "metatable",
            "metatable": "Table to set as the metatable.",
            "table": "Table to assign the metatable of."
          }
        },
        "rawget": {
          "ret": "The value stored on the table, ignoring the __index metamethod.",
          "returntypes": [
            "%1=table<2>"
          ],
          "description": "Retrives a value from the given table without inspecting __index. \nThis does not work on library tables or locked types.",
          "param": {
            "1": "table",
            "2": "key",
            "key": "The key to get from the table.",
            "table": "The table to get the value from."
          }
        },
        "loadstring": {
          "ret": "Compiled function, or nil and an error string if there's a syntax error.",
          "description": "Compiles the given string and returns it as a function, or nil and a string if there is a syntax error.",
          "deprecated": "Use load.",
          "returntypes": [
            "function",
            "string"
          ],
          "param": {
            "1": "code",
            "2": "name",
            "3": "env",
            "env": "(Optional) Environment to assign to the chunk.",
            "name": "(Optional) Name to assign to the chunk.",
            "code": "Lua code string to compile."
          }
        },
        "getScripts": {
          "ret": "Table of filepath -> function pairs.",
          "deprecated": "Use starfall.getScripts() instead.",
          "returntypes": [
            "table<string,function>"
          ],
          "description": "Returns every included script file in a table of filepath -> function pairs. \nCall a function to run the file in the same way as dofile()."
        },
        "setName": {
          "deprecated": "Use starfall.setName() instead.",
          "description": "Changes the name of the chip.",
          "param": {
            "1": "name",
            "name": "The name to use."
          }
        },
        "setfenv": {
          "usage": "local FEnv = { Cake = \"great!\", print = print } \nlocal function MyAwesomeFunc() \n\tprint( Cake ) \nend \nsetfenv( MyAwesomeFunc, FEnv ) \nMyAwesomeFunc() --Prints \"great!\"",
          "description": "Sets the function environment for the given function. \nEssentially changes the global scope to the table you pass in.",
          "param": {
            "1": "func",
            "2": "table",
            "table": "The function environment table to set.",
            "func": "The function to set the environment for."
          }
        },
        "requireAll": {
          "description": "Requires every file you included that has not already been run. \nBe careful with files that only belong on the server/client, it won't discriminate."
        },
        "worldToLocal": {
          "description": "Converts a world space vector into a local space vector.",
          "returntypes": [
            "Vector",
            "Angle"
          ],
          "param": {
            "1": "position",
            "2": "angle",
            "3": "newSystemOrigin",
            "4": "newSystemAngles",
            "newSystemOrigin": "System origin.",
            "angle": "World angle.",
            "newSystemAngles": "System angles.",
            "position": "World position."
          }
        },
        "error": {
          "description": "Throws an error.",
          "param": {
            "1": "message",
            "2": "level",
            "level": "The level offset.",
            "message": "The error message/object."
          }
        },
        "pairs": {
          "description": "Provides an iterator that visits every key-value pair in the table once, with no guarantee for the order in which they are visited.",
          "returntypes": [
            "function<%1=table<1>,%1=table<2>>"
          ],
          "param": {
            "1": "table",
            "table": "Table to iterate."
          }
        }
      },
      "fields": {
        "1": "CLIENT",
        "2": "SERVER",
        "3": "NOTIFY_GENERIC",
        "4": "NOTIFY_ERROR",
        "5": "NOTIFY_HINT",
        "CLIENT": {
          "description": "Constant that denotes whether the code is executed on the client."
        },
        "SERVER": {
          "description": "Constant that denotes whether the code is executed on the server."
        },
        "NOTIFY_HINT": {
          "description": "NOTIFY_HINT for hint()"
        },
        "NOTIFY_GENERIC": {
          "description": "NOTIFY_GENERIC for hint()"
        },
        "NOTIFY_ERROR": {
          "description": "NOTIFY_ERROR for hint()"
        }
      },
      "docname": "_G",
      "client": true,
      "server": true
    },
    "effects": {
      "functions": {
        "1": "attachParticle",
        "2": "createEffect",
        "3": "effectData",
        "4": "finishParticle",
        "attachParticle": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Attaches a particle to an entity.",
          "param": {
            "1": "name",
            "2": "ent",
            "ent": "The entity to attach it to.",
            "name": "The name of the particle."
          }
        },
        "createEffect": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Creates the given effect with the given effect data object.",
          "param": {
            "1": "name",
            "2": "data",
            "3": "allowOverride",
            "4": "ignorePrediction",
            "ignorePrediction": "Set to true if calling on your player.",
            "allowOverride": "If true, then Lua effects with the same name as engine effects override the engine version.",
            "data": "The effect data object that's set up with the information you want the effect to have.",
            "name": "The effect's class name."
          }
        },
        "finishParticle": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Removes a particle from an entity.",
          "param": {
            "1": "ent",
            "ent": "Entity to remove the particle from."
          }
        },
        "effectData": {
          "server": true,
          "returntypes": [
            "Effect"
          ],
          "description": "Returns an effect data object for use in createEffect."
        }
      },
      "description": "Effects library for creating effects and particles.",
      "server": true
    },
    "profiler": {
      "functions": {
        "1": "pop",
        "2": "push",
        "3": "swap",
        "pop": {
          "description": "Pops a profiler state."
        },
        "push": {
          "description": "Pushes a new profiler state. Execution time will be measured from this point until popping.",
          "param": {
            "1": "name",
            "name": "The name of the new state."
          }
        },
        "swap": {
          "description": "Performs a pop and a push simultaneously, without discarding the starting time of the last state. \nThus, the new state starts from the old state's ending time and the old state stops here.",
          "param": {
            "1": "name",
            "name": "The name of the new state."
          }
        }
      },
      "description": "Profiler library for recording execution time.",
      "client": true,
      "server": true
    },
    "coroutine": {
      "functions": {
        "1": "create",
        "2": "resume",
        "3": "running",
        "4": "status",
        "5": "wait",
        "6": "wrap",
        "7": "yield",
        "resume": {
          "returntypes": [
            "boolean",
            "Any..."
          ],
          "description": "Resumes a given coroutine.",
          "param": {
            "1": "thread",
            "2": "...",
            "thread": "Coroutine to resume."
          }
        },
        "yield": {
          "returntypes": [
            "Any..."
          ],
          "description": "Yields the current coroutine, halting it in place ready for the next resume.",
          "param": [
            "..."
          ]
        },
        "running": {
          "returntypes": [
            "thread"
          ],
          "description": "Returns the current running coroutine, or nil if none is running."
        },
        "status": {
          "ret": "Status of coroutine.",
          "returntypes": [
            "string"
          ],
          "description": "Gets the status of a given coroutine. Either 'suspended', 'running', 'normal' or 'dead'.",
          "param": {
            "1": "thread",
            "thread": "Coroutine to check."
          }
        },
        "wrap": {
          "ret": "Function that resumes the coroutine when run.",
          "returntypes": [
            "function"
          ],
          "description": "Returns a function that, when run, resumes the coroutine representing the given function.",
          "param": {
            "1": "func",
            "func": "Function to run inside the coroutine."
          }
        },
        "create": {
          "ret": "Coroutine object representing the given function.",
          "returntypes": [
            "thread"
          ],
          "description": "Creates and returns a coroutine thread object from the given function.",
          "param": {
            "1": "func",
            "func": "Function to run inside the coroutine."
          }
        },
        "wait": {
          "description": "Yields the current coroutine and will continue to yield when called until the given time has elapsed. \nThis does not resume the coroutine for you after the given time.",
          "param": {
            "1": "time",
            "time": "The time in seconds to yield for."
          }
        }
      },
      "description": "Coroutine library. Allows for co-operative threading.",
      "client": true,
      "server": true
    },
    "files": {
      "functions": {
        "1": "append",
        "2": "delete",
        "3": "exists",
        "4": "getMaxNumFiles",
        "5": "getMaxSize",
        "6": "isAvailable",
        "7": "list",
        "8": "modifiedTime",
        "9": "read",
        "10": "rename",
        "11": "size",
        "12": "write",
        "delete": {
          "ret": [
            "True if successful, false if error",
            "Error message if applicable"
          ],
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Deletes a file",
          "param": {
            "1": "fileName",
            "fileName": "The name of the file to be deleted."
          }
        },
        "write": {
          "ret": [
            "True if OK, false if error.",
            "Error message if applicable."
          ],
          "deprecated": "in favour of io.open/io.output.",
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Writes to a file, overwriting any existing content.",
          "param": {
            "1": "fileName",
            "2": "data",
            "data": "String data to write.",
            "fileName": "Name of the file to write data to."
          }
        },
        "getMaxNumFiles": {
          "ret": "The maximum number of files that can be saved.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the current limit on the number of files saved."
        },
        "getMaxSize": {
          "ret": "The maximum number of bytes a file can contain.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the maximum file size."
        },
        "modifiedTime": {
          "returntypes": [
            "number"
          ],
          "paramtypes": {
            "fileName": "string"
          },
          "description": "Returns the time at which the given file was last modified (as a Unix timestamp in seconds i.e. relative to os.time()).",
          "param": {
            "1": "fileName",
            "fileName": "The name of the file to get the last modified time of."
          }
        },
        "read": {
          "ret": [
            "Contents, or nil if error.",
            "Error message if applicable."
          ],
          "deprecated": "in favour of io.open/io.input.",
          "returntypes": [
            [
              "string",
              "nil"
            ],
            "string"
          ],
          "description": "Reads a file from path.",
          "param": {
            "1": "fileName",
            "fileName": "Name of the file to read."
          }
        },
        "exists": {
          "ret": "True if exists, false if not.",
          "returntypes": [
            "boolean"
          ],
          "description": "Checks if a file exists.",
          "param": {
            "1": "fileName",
            "fileName": "The name of the file to check."
          }
        },
        "list": {
          "ret": "A table containing every file currently saved in the instance owner's script data folder.",
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Returns a table of all saved files. \nCan only be used on the server, or on the chip owner's client."
        },
        "append": {
          "ret": [
            "True if the file was appended, false otherwise.",
            "Error message if applicable."
          ],
          "deprecated": "in favour of io.open.",
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Appends a string to the end of a file.",
          "param": {
            "1": "fileName",
            "2": "data",
            "data": "String that will be appended to the file.",
            "fileName": "Name of the file to append to."
          }
        },
        "isAvailable": {
          "ret": "True if file operations are available, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Indicates whether file operations are available or not. \nIf running on the client, file operations are only available when executing on the chip owner's client."
        },
        "rename": {
          "ret": [
            "True if successful, false if error.",
            "If the operation failed, an error message explaining the failure."
          ],
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Renames a file.",
          "param": {
            "1": "oldName",
            "2": "newName",
            "newName": "The new name to give the file.",
            "oldName": "The name of the existing file to be renamed."
          }
        },
        "size": {
          "returntypes": [
            "number"
          ],
          "paramtypes": {
            "fileName": "string"
          },
          "description": "Returns the size of the given file. Note that non-existent files return a value of 0.",
          "param": {
            "1": "fileName",
            "fileName": "The name of the file to get the size of."
          }
        }
      },
      "description": "File functions. Allows for basic creating and editing text files.",
      "client": true,
      "server": true
    },
    "faction": {
      "functions": {
        "1": "getAlliedMembers",
        "2": "getFaction",
        "3": "getFactionDetails",
        "4": "getFactions",
        "5": "getOnlineMembers",
        "6": "getOnlinePlayers",
        "7": "isAlly",
        "8": "isEnemy",
        "getAlliedMembers": {
          "ret": "An array of all player entities online for the chip owner's alliance.",
          "server": true,
          "returntypes": [
            "table<number,Player>"
          ],
          "description": "Gets all online alliance members of the SF instance owner's alliance."
        },
        "getFactions": {
          "ret": "An array of all faction names.",
          "server": true,
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Gets the list of all factions."
        },
        "isAlly": {
          "ret": "True if an ally, false if not.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Determines if the given player is allied with the SF instance's owner.",
          "param": {
            "1": "ply",
            "ply": "The player to check."
          }
        },
        "getOnlinePlayers": {
          "ret": "Table of all online players.",
          "server": true,
          "returntypes": [
            "table<number,Player>"
          ],
          "description": "Gets all online players in a given faction.",
          "param": {
            "1": "faction",
            "faction": "Name of the faction."
          }
        },
        "getFaction": {
          "ret": "The name of the faction they belong to, or \"\" if they do not belong to one.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets the faction the given player belongs to.",
          "param": {
            "1": "ply",
            "ply": "The player to get the faction of."
          }
        },
        "getFactionDetails": {
          "ret": "Table with fields: Name, Tag, TagColour, LeaderID, Public.",
          "server": true,
          "returntypes": [
            "Faction"
          ],
          "description": "Returns an information table about the given faction.",
          "param": {
            "1": "faction",
            "faction": "Name of the faction."
          }
        },
        "isEnemy": {
          "ret": "True if an enemy, false if not.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Determines if the given player is an enemy of the SF instance's owner.",
          "param": {
            "1": "ply",
            "ply": "The player to check."
          }
        },
        "getOnlineMembers": {
          "ret": "An array of all player entities online for the chip owner's faction.",
          "server": true,
          "returntypes": [
            "table<number,Player>"
          ],
          "description": "Gets all online members of the SF instance owner's faction."
        }
      },
      "description": "Factions library for interfacing with the server's faction system.",
      "server": true
    },
    "input": {
      "functions": {
        "1": "getKeyCode",
        "2": "getKeyName",
        "3": "isButtonDown",
        "4": "isControlDown",
        "5": "isKeyDown",
        "6": "isMouseDown",
        "7": "isShiftDown",
        "8": "lookupBinding",
        "9": "lookupKeyBinding",
        "lookupKeyBinding": {
          "ret": "The binding set for the given key, if present. Otherwise nil.",
          "returntypes": [
            [
              "string",
              "nil"
            ]
          ],
          "client": true,
          "description": "Returns the binding assigned to the given key code.",
          "param": {
            "1": "keyCode",
            "keyCode": "The key code to lookup (one of input.KEY_* or input.MOUSE_*)."
          }
        },
        "lookupBinding": {
          "ret": "The string name of the key the given bind is first bound to.",
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Returns the name of the key that the given bind is first bound to.",
          "param": {
            "1": "bind",
            "bind": "The bind to lookup, e.g +forward."
          }
        },
        "getKeyName": {
          "ret": "A string representing the name of the given key.",
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Returns the name of the given key enum.",
          "param": {
            "1": "key",
            "key": "The input.KEY_ enum you want the name of."
          }
        },
        "getKeyCode": {
          "ret": "The key code for the given name (one of input.KEY_* or input.MOUSE_*) or -1 if the given name is invalid.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the key code for the given key name. This is the opposite of input.getKeyName().",
          "param": {
            "1": "keyName",
            "keyName": "The name of the key (e.g. \"e\" or \"shift\")."
          }
        },
        "isShiftDown": {
          "ret": "True if the shift key is down.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the shift key is down."
        },
        "isKeyDown": {
          "ret": "True if the given keyboard key is down.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the given keyboard key is down.",
          "param": {
            "1": "key",
            "key": "The input.KEY_ enum you want to check."
          }
        },
        "isMouseDown": {
          "ret": "True if the given mouse button is down.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the given mouse button is down.",
          "param": {
            "1": "mouseButton",
            "mouseButton": "The input.MOUSE_ enum you want to check."
          }
        },
        "isControlDown": {
          "ret": "True if the ctrl key is down.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the ctrl key is down."
        },
        "isButtonDown": {
          "ret": "True if the given key is down.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the given keyboard key or mouse button is down.",
          "param": {
            "1": "key",
            "key": "The input.KEY_ or MOUSE_ enum you want to check."
          }
        }
      },
      "description": "Input library, for dealing with keyboard/mouse input on the client.",
      "fields": {
        "1": "KEY_0",
        "2": "KEY_1",
        "3": "KEY_2",
        "4": "KEY_3",
        "5": "KEY_4",
        "6": "KEY_5",
        "7": "KEY_6",
        "8": "KEY_7",
        "9": "KEY_8",
        "10": "KEY_9",
        "11": "KEY_A",
        "12": "KEY_APOSTROPHE",
        "13": "KEY_APP",
        "14": "KEY_B",
        "15": "KEY_BACKQUOTE",
        "16": "KEY_BACKSLASH",
        "17": "KEY_BACKSPACE",
        "18": "KEY_BREAK",
        "19": "KEY_C",
        "20": "KEY_CAPSLOCK",
        "21": "KEY_CAPSLOCKTOGGLE",
        "22": "KEY_COMMA",
        "23": "KEY_COUNT",
        "24": "KEY_D",
        "25": "KEY_DELETE",
        "26": "KEY_DOWN",
        "27": "KEY_E",
        "28": "KEY_END",
        "29": "KEY_ENTER",
        "30": "KEY_EQUAL",
        "31": "KEY_ESCAPE",
        "32": "KEY_F",
        "33": "KEY_F1",
        "34": "KEY_F10",
        "35": "KEY_F11",
        "36": "KEY_F12",
        "37": "KEY_F2",
        "38": "KEY_F3",
        "39": "KEY_F4",
        "40": "KEY_F5",
        "41": "KEY_F6",
        "42": "KEY_F7",
        "43": "KEY_F8",
        "44": "KEY_F9",
        "45": "KEY_FIRST",
        "46": "KEY_G",
        "47": "KEY_H",
        "48": "KEY_HOME",
        "49": "KEY_I",
        "50": "KEY_INSERT",
        "51": "KEY_J",
        "52": "KEY_K",
        "53": "KEY_L",
        "54": "KEY_LALT",
        "55": "KEY_LAST",
        "56": "KEY_LBRACKET",
        "57": "KEY_LCONTROL",
        "58": "KEY_LEFT",
        "59": "KEY_LSHIFT",
        "60": "KEY_LWIN",
        "61": "KEY_M",
        "62": "KEY_MINUS",
        "63": "KEY_N",
        "64": "KEY_NONE",
        "65": "KEY_NUMLOCK",
        "66": "KEY_NUMLOCKTOGGLE",
        "67": "KEY_O",
        "68": "KEY_P",
        "69": "KEY_PAD_0",
        "70": "KEY_PAD_1",
        "71": "KEY_PAD_2",
        "72": "KEY_PAD_3",
        "73": "KEY_PAD_4",
        "74": "KEY_PAD_5",
        "75": "KEY_PAD_6",
        "76": "KEY_PAD_7",
        "77": "KEY_PAD_8",
        "78": "KEY_PAD_9",
        "79": "KEY_PAD_DECIMAL",
        "80": "KEY_PAD_DIVIDE",
        "81": "KEY_PAD_ENTER",
        "82": "KEY_PAD_MINUS",
        "83": "KEY_PAD_MULTIPLY",
        "84": "KEY_PAD_PLUS",
        "85": "KEY_PAGEDOWN",
        "86": "KEY_PAGEUP",
        "87": "KEY_PERIOD",
        "88": "KEY_Q",
        "89": "KEY_R",
        "90": "KEY_RALT",
        "91": "KEY_RBRACKET",
        "92": "KEY_RCONTROL",
        "93": "KEY_RIGHT",
        "94": "KEY_RSHIFT",
        "95": "KEY_RWIN",
        "96": "KEY_S",
        "97": "KEY_SCROLLLOCK",
        "98": "KEY_SCROLLLOCKTOGGLE",
        "99": "KEY_SEMICOLON",
        "100": "KEY_SLASH",
        "101": "KEY_SPACE",
        "102": "KEY_T",
        "103": "KEY_TAB",
        "104": "KEY_U",
        "105": "KEY_UP",
        "106": "KEY_V",
        "107": "KEY_W",
        "108": "KEY_X",
        "109": "KEY_XBUTTON_A",
        "110": "KEY_XBUTTON_B",
        "111": "KEY_XBUTTON_BACK",
        "112": "KEY_XBUTTON_DOWN",
        "113": "KEY_XBUTTON_LEFT",
        "114": "KEY_XBUTTON_LEFT_SHOULDER",
        "115": "KEY_XBUTTON_LTRIGGER",
        "116": "KEY_XBUTTON_RIGHT",
        "117": "KEY_XBUTTON_RIGHT_SHOULDER",
        "118": "KEY_XBUTTON_RTRIGGER",
        "119": "KEY_XBUTTON_START",
        "120": "KEY_XBUTTON_STICK1",
        "121": "KEY_XBUTTON_STICK2",
        "122": "KEY_XBUTTON_UP",
        "123": "KEY_XBUTTON_X",
        "124": "KEY_XBUTTON_Y",
        "125": "KEY_XSTICK1_DOWN",
        "126": "KEY_XSTICK1_LEFT",
        "127": "KEY_XSTICK1_RIGHT",
        "128": "KEY_XSTICK1_UP",
        "129": "KEY_XSTICK2_DOWN",
        "130": "KEY_XSTICK2_LEFT",
        "131": "KEY_XSTICK2_RIGHT",
        "132": "KEY_XSTICK2_UP",
        "133": "KEY_Y",
        "134": "KEY_Z",
        "135": "IN_ALT1",
        "136": "IN_ALT2",
        "137": "IN_ATTACK",
        "138": "IN_ATTACK2",
        "139": "IN_BACK",
        "140": "IN_BULLRUSH",
        "141": "IN_CANCEL",
        "142": "IN_DUCK",
        "143": "IN_FORWARD",
        "144": "IN_GRENADE1",
        "145": "IN_GRENADE2",
        "146": "IN_JUMP",
        "147": "IN_LEFT",
        "148": "IN_MOVELEFT",
        "149": "IN_MOVERIGHT",
        "150": "IN_RELOAD",
        "151": "IN_RIGHT",
        "152": "IN_RUN",
        "153": "IN_SCORE",
        "154": "IN_SPEED",
        "155": "IN_USE",
        "156": "IN_WALK",
        "157": "IN_WEAPON1",
        "158": "IN_WEAPON2",
        "159": "IN_ZOOM",
        "160": "MOUSE_4",
        "161": "MOUSE_5",
        "162": "MOUSE_COUNT",
        "163": "MOUSE_FIRST",
        "164": "MOUSE_LAST",
        "165": "MOUSE_LEFT",
        "166": "MOUSE_MIDDLE",
        "167": "MOUSE_RIGHT",
        "168": "MOUSE_WHEEL_DOWN",
        "169": "MOUSE_WHEEL_UP",
        "KEY_BACKSLASH": {
          "description": "KEY_BACKSLASH"
        },
        "KEY_LEFT": {
          "description": "KEY_LEFT"
        },
        "KEY_XBUTTON_STICK2": {
          "description": "KEY_XBUTTON_STICK2"
        },
        "KEY_PAD_5": {
          "description": "KEY_PAD_5"
        },
        "IN_LEFT": {
          "description": "IN_LEFT"
        },
        "KEY_LAST": {
          "description": "KEY_LAST"
        },
        "IN_RIGHT": {
          "description": "IN_RIGHT"
        },
        "KEY_SEMICOLON": {
          "description": "KEY_SEMICOLON"
        },
        "KEY_PAGEUP": {
          "description": "KEY_PAGEUP"
        },
        "KEY_4": {
          "description": "KEY_4"
        },
        "KEY_F1": {
          "description": "KEY_F1"
        },
        "IN_ZOOM": {
          "description": "IN_ZOOM"
        },
        "KEY_LWIN": {
          "description": "KEY_LWIN"
        },
        "IN_RUN": {
          "description": "IN_RUN"
        },
        "KEY_RCONTROL": {
          "description": "KEY_RCONTROL"
        },
        "MOUSE_WHEEL_DOWN": {
          "description": "MOUSE_WHEEL_DOWN"
        },
        "KEY_PAD_DIVIDE": {
          "description": "KEY_PAD_DIVIDE"
        },
        "KEY_PAD_6": {
          "description": "KEY_PAD_6"
        },
        "KEY_TAB": {
          "description": "KEY_TAB"
        },
        "KEY_6": {
          "description": "KEY_6"
        },
        "IN_WALK": {
          "description": "IN_WALK"
        },
        "KEY_NUMLOCKTOGGLE": {
          "description": "KEY_NUMLOCKTOGGLE"
        },
        "KEY_Q": {
          "description": "KEY_Q"
        },
        "KEY_COUNT": {
          "description": "KEY_COUNT"
        },
        "KEY_RWIN": {
          "description": "KEY_RWIN"
        },
        "KEY_SCROLLLOCK": {
          "description": "KEY_SCROLLLOCK"
        },
        "KEY_O": {
          "description": "KEY_O"
        },
        "KEY_NUMLOCK": {
          "description": "KEY_NUMLOCK"
        },
        "KEY_XBUTTON_BACK": {
          "description": "KEY_XBUTTON_BACK"
        },
        "KEY_F9": {
          "description": "KEY_F9"
        },
        "IN_CANCEL": {
          "description": "IN_CANCEL"
        },
        "KEY_C": {
          "description": "KEY_C"
        },
        "KEY_BREAK": {
          "description": "KEY_BREAK"
        },
        "KEY_XBUTTON_A": {
          "description": "KEY_XBUTTON_A"
        },
        "KEY_BACKQUOTE": {
          "description": "KEY_BACKQUOTE"
        },
        "KEY_PAD_8": {
          "description": "KEY_PAD_8"
        },
        "KEY_L": {
          "description": "KEY_L"
        },
        "KEY_LALT": {
          "description": "KEY_LALT"
        },
        "KEY_XSTICK2_LEFT": {
          "description": "KEY_XSTICK2_LEFT"
        },
        "KEY_PAD_PLUS": {
          "description": "KEY_PAD_PLUS"
        },
        "KEY_LBRACKET": {
          "description": "KEY_LBRACKET"
        },
        "KEY_3": {
          "description": "KEY_3"
        },
        "KEY_PAD_2": {
          "description": "KEY_PAD_2"
        },
        "KEY_XBUTTON_B": {
          "description": "KEY_XBUTTON_B"
        },
        "KEY_XBUTTON_START": {
          "description": "KEY_XBUTTON_START"
        },
        "IN_GRENADE2": {
          "description": "IN_GRENADE2"
        },
        "MOUSE_5": {
          "description": "MOUSE_5"
        },
        "KEY_XBUTTON_RIGHT_SHOULDER": {
          "description": "KEY_XBUTTON_RIGHT_SHOULDER"
        },
        "KEY_HOME": {
          "description": "KEY_HOME"
        },
        "KEY_PAD_3": {
          "description": "KEY_PAD_3"
        },
        "KEY_SLASH": {
          "description": "KEY_SLASH"
        },
        "KEY_P": {
          "description": "KEY_P"
        },
        "KEY_XBUTTON_LTRIGGER": {
          "description": "KEY_XBUTTON_LTRIGGER"
        },
        "KEY_INSERT": {
          "description": "KEY_INSERT"
        },
        "KEY_PAD_DECIMAL": {
          "description": "KEY_PAD_DECIMAL"
        },
        "KEY_RIGHT": {
          "description": "KEY_RIGHT"
        },
        "KEY_XBUTTON_LEFT_SHOULDER": {
          "description": "KEY_XBUTTON_LEFT_SHOULDER"
        },
        "IN_USE": {
          "description": "IN_USE"
        },
        "KEY_PAD_MINUS": {
          "description": "KEY_PAD_MINUS"
        },
        "KEY_0": {
          "description": "KEY_0"
        },
        "IN_RELOAD": {
          "description": "IN_RELOAD"
        },
        "KEY_XBUTTON_RIGHT": {
          "description": "KEY_XBUTTON_RIGHT"
        },
        "KEY_E": {
          "description": "KEY_E"
        },
        "IN_FORWARD": {
          "description": "IN_FORWARD"
        },
        "KEY_XBUTTON_RTRIGGER": {
          "description": "KEY_XBUTTON_RTRIGGER"
        },
        "MOUSE_MIDDLE": {
          "description": "MOUSE_MIDDLE"
        },
        "KEY_B": {
          "description": "KEY_B"
        },
        "KEY_DELETE": {
          "description": "KEY_DELETE"
        },
        "KEY_PAD_0": {
          "description": "KEY_PAD_0"
        },
        "KEY_F3": {
          "description": "KEY_F3"
        },
        "KEY_COMMA": {
          "description": "KEY_COMMA"
        },
        "KEY_XBUTTON_LEFT": {
          "description": "KEY_XBUTTON_LEFT"
        },
        "MOUSE_FIRST": {
          "description": "MOUSE_FIRST"
        },
        "KEY_PAGEDOWN": {
          "description": "KEY_PAGEDOWN"
        },
        "KEY_PAD_4": {
          "description": "KEY_PAD_4"
        },
        "MOUSE_WHEEL_UP": {
          "description": "MOUSE_WHEEL_UP"
        },
        "IN_BACK": {
          "description": "IN_BACK"
        },
        "MOUSE_RIGHT": {
          "description": "MOUSE_RIGHT"
        },
        "MOUSE_LEFT": {
          "description": "MOUSE_LEFT"
        },
        "KEY_BACKSPACE": {
          "description": "KEY_BACKSPACE"
        },
        "KEY_U": {
          "description": "KEY_U"
        },
        "KEY_PAD_ENTER": {
          "description": "KEY_PAD_ENTER"
        },
        "KEY_F11": {
          "description": "KEY_F11"
        },
        "IN_SCORE": {
          "description": "IN_SCORE"
        },
        "MOUSE_LAST": {
          "description": "MOUSE_LAST"
        },
        "KEY_7": {
          "description": "KEY_7"
        },
        "MOUSE_COUNT": {
          "description": "MOUSE_COUNT"
        },
        "KEY_MINUS": {
          "description": "KEY_MINUS"
        },
        "KEY_T": {
          "description": "KEY_T"
        },
        "IN_WEAPON2": {
          "description": "IN_WEAPON2"
        },
        "KEY_A": {
          "description": "KEY_A"
        },
        "KEY_CAPSLOCK": {
          "description": "KEY_CAPSLOCK"
        },
        "KEY_K": {
          "description": "KEY_K"
        },
        "KEY_F12": {
          "description": "KEY_F12"
        },
        "IN_MOVERIGHT": {
          "description": "IN_MOVERIGHT"
        },
        "IN_MOVELEFT": {
          "description": "IN_MOVELEFT"
        },
        "IN_JUMP": {
          "description": "IN_JUMP"
        },
        "KEY_EQUAL": {
          "description": "KEY_EQUAL"
        },
        "IN_GRENADE1": {
          "description": "IN_GRENADE1"
        },
        "IN_DUCK": {
          "description": "IN_DUCK"
        },
        "KEY_RSHIFT": {
          "description": "KEY_RSHIFT"
        },
        "KEY_XSTICK1_DOWN": {
          "description": "KEY_XSTICK1_DOWN"
        },
        "IN_BULLRUSH": {
          "description": "IN_BULLRUSH"
        },
        "KEY_LCONTROL": {
          "description": "KEY_LCONTROL"
        },
        "KEY_F8": {
          "description": "KEY_F8"
        },
        "KEY_8": {
          "description": "KEY_8"
        },
        "KEY_F6": {
          "description": "KEY_F6"
        },
        "IN_ATTACK": {
          "description": "IN_ATTACK"
        },
        "KEY_9": {
          "description": "KEY_9"
        },
        "IN_ALT2": {
          "description": "IN_ALT2"
        },
        "IN_ALT1": {
          "description": "IN_ALT1"
        },
        "KEY_APP": {
          "description": "KEY_APP"
        },
        "KEY_PERIOD": {
          "description": "KEY_PERIOD"
        },
        "KEY_XSTICK1_RIGHT": {
          "description": "KEY_XSTICK1_RIGHT"
        },
        "KEY_2": {
          "description": "KEY_2"
        },
        "KEY_PAD_MULTIPLY": {
          "description": "KEY_PAD_MULTIPLY"
        },
        "KEY_1": {
          "description": "KEY_1"
        },
        "KEY_Y": {
          "description": "KEY_Y"
        },
        "KEY_XSTICK2_UP": {
          "description": "KEY_XSTICK2_UP"
        },
        "KEY_XSTICK2_RIGHT": {
          "description": "KEY_XSTICK2_RIGHT"
        },
        "IN_SPEED": {
          "description": "IN_SPEED"
        },
        "KEY_XSTICK1_UP": {
          "description": "KEY_XSTICK1_UP"
        },
        "KEY_XBUTTON_Y": {
          "description": "KEY_XBUTTON_Y"
        },
        "KEY_Z": {
          "description": "KEY_Z"
        },
        "KEY_M": {
          "description": "KEY_M"
        },
        "KEY_XSTICK1_LEFT": {
          "description": "KEY_XSTICK1_LEFT"
        },
        "KEY_XBUTTON_X": {
          "description": "KEY_XBUTTON_X"
        },
        "IN_WEAPON1": {
          "description": "IN_WEAPON1"
        },
        "KEY_RALT": {
          "description": "KEY_RALT"
        },
        "KEY_APOSTROPHE": {
          "description": "KEY_APOSTROPHE"
        },
        "IN_ATTACK2": {
          "description": "IN_ATTACK2"
        },
        "KEY_I": {
          "description": "KEY_I"
        },
        "KEY_F10": {
          "description": "KEY_F10"
        },
        "KEY_XBUTTON_UP": {
          "description": "KEY_XBUTTON_UP"
        },
        "KEY_SPACE": {
          "description": "KEY_SPACE"
        },
        "KEY_ENTER": {
          "description": "KEY_ENTER"
        },
        "KEY_XBUTTON_STICK1": {
          "description": "KEY_XBUTTON_STICK1"
        },
        "KEY_N": {
          "description": "KEY_N"
        },
        "KEY_V": {
          "description": "KEY_V"
        },
        "KEY_LSHIFT": {
          "description": "KEY_LSHIFT"
        },
        "KEY_XBUTTON_DOWN": {
          "description": "KEY_XBUTTON_DOWN"
        },
        "KEY_RBRACKET": {
          "description": "KEY_RBRACKET"
        },
        "KEY_D": {
          "description": "KEY_D"
        },
        "KEY_F7": {
          "description": "KEY_F7"
        },
        "KEY_SCROLLLOCKTOGGLE": {
          "description": "KEY_SCROLLLOCKTOGGLE"
        },
        "KEY_5": {
          "description": "KEY_5"
        },
        "KEY_X": {
          "description": "KEY_X"
        },
        "KEY_NONE": {
          "description": "KEY_NONE"
        },
        "KEY_H": {
          "description": "KEY_H"
        },
        "KEY_PAD_7": {
          "description": "KEY_PAD_7"
        },
        "KEY_UP": {
          "description": "KEY_UP"
        },
        "KEY_PAD_9": {
          "description": "KEY_PAD_9"
        },
        "MOUSE_4": {
          "description": "MOUSE_4"
        },
        "KEY_J": {
          "description": "KEY_J"
        },
        "KEY_W": {
          "description": "KEY_W"
        },
        "KEY_END": {
          "description": "KEY_END"
        },
        "KEY_XSTICK2_DOWN": {
          "description": "KEY_XSTICK2_DOWN"
        },
        "KEY_R": {
          "description": "KEY_R"
        },
        "KEY_PAD_1": {
          "description": "KEY_PAD_1"
        },
        "KEY_F": {
          "description": "KEY_F"
        },
        "KEY_F2": {
          "description": "KEY_F2"
        },
        "KEY_F4": {
          "description": "KEY_F4"
        },
        "KEY_DOWN": {
          "description": "KEY_DOWN"
        },
        "KEY_S": {
          "description": "KEY_S"
        },
        "KEY_G": {
          "description": "KEY_G"
        },
        "KEY_F5": {
          "description": "KEY_F5"
        },
        "KEY_CAPSLOCKTOGGLE": {
          "description": "KEY_CAPSLOCKTOGGLE"
        },
        "KEY_ESCAPE": {
          "description": "KEY_ESCAPE"
        },
        "KEY_FIRST": {
          "description": "KEY_FIRST"
        }
      },
      "client": true
    },
    "io": {
      "functions": {
        "1": "close",
        "2": "flush",
        "3": "input",
        "4": "lines",
        "5": "open",
        "6": "output",
        "7": "read",
        "8": "type",
        "9": "write",
        "type": {
          "ret": "For an open file, \"file\", for a closed file \"closed file\". Anything else returns nil.",
          "returntypes": [
            "string"
          ],
          "description": "Returns the type of the file.",
          "param": {
            "1": "file",
            "file": "File object."
          }
        },
        "write": {
          "description": "Same as io.output():write( ... ).",
          "param": {
            "1": "...",
            "...": "Data to write."
          }
        },
        "close": {
          "description": "Closes a file.",
          "param": {
            "1": "file",
            "file": "If nil, closes the default output file. Otherwise closes the passed in file."
          }
        },
        "flush": {
          "description": "Flushes the default output file."
        },
        "open": {
          "ret": [
            "Opened file or nil on failure.",
            "The error message if the file failed to open."
          ],
          "returntypes": [
            "File",
            "string"
          ],
          "description": "Opens a file.",
          "param": {
            "1": "filePath",
            "2": "mode",
            "mode": "The mode to open the file with. \nPossible values are: \n\"r\" - text read mode, \n\"w\" - text write mode, \n\"a\" - text append mode, \n\"rb\" - binary read mode, \n\"wb\" - binary write mode, \n\"ab\" - binary append mode. \nNote that these are not the same as standard Lua, blame Garry.",
            "filePath": "The file name in your files directory. Must be a .txt file and cannot be in a sub-directory."
          }
        },
        "output": {
          "ret": "The default output file.",
          "returntypes": [
            "File"
          ],
          "description": "Opens a new file as the default output file in \"w\" mode, or returns the currently opened file.",
          "param": {
            "1": "file",
            "file": "Either nil to return the currently opened output file, \na file object to set as the default output file, or a file name to open."
          }
        },
        "read": {
          "returntypes": [
            "string..."
          ],
          "description": "Reads from the default input file, same as io.input():read( ... ).",
          "param": [
            "..."
          ]
        },
        "input": {
          "ret": "The default input file.",
          "returntypes": [
            "File"
          ],
          "description": "Opens a new file as the default input file in \"r\" mode, or returns the currently opened file.",
          "param": {
            "1": "file",
            "file": "Either nil to return the currently opened input file, \na file object to set as the default input file, or a file name to open."
          }
        },
        "lines": {
          "returntypes": [
            "function"
          ],
          "description": "Same as io.input():lines( ... ), but closes the file at the end of the iteration.",
          "param": {
            "1": "fileName",
            "2": "...",
            "...": "Iterator arguments.",
            "fileName": "File name to open."
          }
        }
      },
      "description": "IO library, for advanced Lua style file manipulation.",
      "client": true,
      "server": true
    },
    "util": {
      "functions": {
        "1": "isFirstTimePredicted",
        "2": "isInWorld",
        "isFirstTimePredicted": {
          "ret": "True if the current event call is the first prediction.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the current event is being called for the first time. \nOnly has meaning inside predicted events, such as \"playerbuttondown\"."
        },
        "isInWorld": {
          "ret": "True if the given position is inside the world, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the given position is inside the world boundaries.",
          "param": {
            "1": "pos",
            "pos": "The position vector to check."
          }
        }
      },
      "description": "Utility library. \nContains functions that don't belong anywhere else."
    },
    "holograms": {
      "functions": {
        "1": "addHalo",
        "2": "canSpawn",
        "3": "create",
        "4": "getAll",
        "5": "getGlobalCount",
        "6": "getInstanceCount",
        "7": "getQuota",
        "8": "removeAll",
        "getAll": {
          "ret": "An array of all holograms spawned for the current instance.",
          "returntypes": [
            "table<number,Hologram>"
          ],
          "description": "Returns a table containing all hologram entities belonging to the current instance. \nThis is shared, you can get all holograms on the client here too."
        },
        "canSpawn": {
          "ret": "True if you can spawn holograms, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the number of holograms spawned by the instance's owner is less then the max."
        },
        "getQuota": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the maximum number of holograms you can spawn across all Starfall instances."
        },
        "removeAll": {
          "server": true,
          "description": "Removes all spawned holograms of the current instance."
        },
        "getInstanceCount": {
          "ret": "Number of spawned holograms under this instance.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets the number of spawned holograms for the current instance."
        },
        "create": {
          "ret": "The hologram entity.",
          "server": true,
          "returntypes": [
            "Hologram"
          ],
          "description": "Creates a hologram.",
          "param": {
            "1": "pos",
            "2": "ang",
            "3": "model",
            "4": "scale",
            "scale": "(Optional) The initial scale of the hologram. Defaults to 1.",
            "model": "(Optional) The initial model path to use for the given hologram.",
            "ang": "The initial angles to give the hologram.",
            "pos": "The initial position to give the hologram."
          }
        },
        "addHalo": {
          "ret": "A table with the following editable fields (case-insensitive): \n- Color \n- BlurX \n- BlurY \n- DrawPasses \n- Additive \n- IgnoreZ \nEditing any of these values will update the halo for all the holograms passed in originally.",
          "returntypes": [
            "Halo"
          ],
          "usage": "-- Adds a very blurry yellow halo around the first hologram in holograms.getAll() \n-- Note that halos are persistent until you call Hologram:removeHalo(). \n-- Note also that additive should really be always true, otherwise you'll get an odd looking halo. \nlocal Holos = holograms.getAll() \nholograms.addHalo( Holos[ 1 ], Color( 255, 255, 0 ), 10, 10, 1, true, false ) \n \n-- Alternatively, you can also add halos to multiple holograms at once. \n-- This will add a sharp red halo to all holograms the chip has spawned. \nlocal HaloParameters = holograms.addHalo( Holos, Color( 255, 0, 0 ), 1, 1, 1, true, false ) \n-- After 1 second, make the halos draw through walls, and increase the blur. \ntimer.simple( 1, function() \n\tHaloParameters.IgnoreZ = true \n\tHaloParameters.BlurX = 5 \n\tHaloParameters.BlurY = 5 \nend )",
          "client": true,
          "description": "Adds a halo to all the passed in holograms. A hologram can only have a single halo at a time. \nHalo rendering requires the permission DRAW_HALOS.",
          "param": {
            "1": "holos",
            "2": "colour",
            "3": "blurX",
            "4": "blurY",
            "5": "drawPasses",
            "6": "additive",
            "7": "ignoreZ",
            "ignoreZ": "(Optional, default false) Whether the halo should be occluded by objects in the way or not.",
            "additive": "(Optional, default true) Whether the halo should be additively rendered.",
            "drawPasses": "(Optional, default 1) The amount of passes to make when drawing the halo. A higher value reduces blur. Clamped between 1 and 3.",
            "blurY": "(Optional, default 2) The amount to blur vertically, clamped between 0 and 10.",
            "blurX": "(Optional, default 2) The amount to blur horizontally, clamped between 0 and 10.",
            "colour": "The colour of the halo.",
            "holos": "A single hologram or an array of holograms to have a halo added to."
          }
        },
        "getGlobalCount": {
          "ret": "The total number of holograms spawned by the instance's owner.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets the number of spawned holograms across all the instance owner's chips."
        }
      },
      "description": "Library for creating and manipulating physics-less models AKA \"Holograms\".",
      "client": true,
      "server": true
    }
  },
  "tables": {
    "1": "AttachmentData",
    "2": "ClippingPlane",
    "3": "Environment",
    "4": "Faction",
    "5": "Font",
    "6": "Halo",
    "7": "LocalLight",
    "8": "MeshVertex",
    "9": "PhysEnvSettings",
    "10": "PosAngData",
    "11": "ScreenInfo",
    "12": "ToScreenData",
    "13": "TraceResult",
    "14": "Vertex",
    "LocalLight": {
      "client": true,
      "description": "A local light definition to be used with render.setLocalModelLights().",
      "field": {
        "1": "type",
        "2": "color",
        "3": "pos",
        "4": "dir",
        "5": "range",
        "6": "angularFalloff",
        "7": "innerAngle",
        "8": "outerAngle",
        "9": "fiftyPercentDistance",
        "10": "zeroPercentDistance",
        "11": "quadraticFalloff",
        "12": "linearFalloff",
        "13": "constantFalloff",
        "type": {
          "type": "number",
          "desc": "The type of light to apply (one of render.MATERIAL_LIGHT_*, default = render.MATERIAL_LIGHT_POINT)."
        },
        "dir": {
          "type": "Vector",
          "desc": "The direction the light is pointing (applicable to directional and spot lights only)."
        },
        "color": {
          "type": "Vector",
          "desc": "The colour of the light (x = red, y = green, z = blue). Larger values increase the brightness."
        },
        "innerAngle": {
          "type": "number",
          "desc": "The inner cone angle for spot lights, in degrees (default = 45)."
        },
        "range": {
          "type": "number",
          "desc": "The maximum range of the light source. This does not control attenuation, it merely sets a cutoff point. The default value of 0 is infinite range."
        },
        "fiftyPercentDistance": {
          "type": "number",
          "desc": "The distance from the light's position at which the light will be at 50% brightness."
        },
        "linearFalloff": {
          "type": "number",
          "desc": "If the distance values are not supplied, this provides the linear term of the falloff (default = 0)."
        },
        "angularFalloff": {
          "type": "number",
          "desc": "The angular falloff exponent for spot lights. Higher values result in a sharper transition between the inner and outer cone (default = 5)."
        },
        "zeroPercentDistance": {
          "type": "number",
          "desc": "The distance from the light's position at which the light will fade out entirely."
        },
        "outerAngle": {
          "type": "number",
          "desc": "The outer cone angle for spot lights, in degrees (default = 45)."
        },
        "quadraticFalloff": {
          "type": "number",
          "desc": "If the distance values are not supplied, this provides the quadratic term of the falloff (default = 0)."
        },
        "constantFalloff": {
          "type": "number",
          "desc": "If the distance values are not supplied, this provides the constant term of the falloff (default = 1)."
        },
        "pos": {
          "type": "Vector",
          "desc": "The position of the light in world space."
        }
      }
    },
    "TraceResult": {
      "description": "Trace result structure.",
      "field": {
        "1": "Entity",
        "2": "Fraction",
        "3": "FractionLeftSolid",
        "4": "Hit",
        "5": "HitBox",
        "6": "HitGroup",
        "7": "HitNoDraw",
        "8": "HitNonWorld",
        "9": "HitNormal",
        "10": "HitPos",
        "11": "HitSky",
        "12": "HitTexture",
        "13": "HitWorld",
        "14": "MatType",
        "15": "Normal",
        "16": "PhysicsBone",
        "17": "StartPos",
        "18": "SurfaceProps",
        "19": "StartSolid",
        "20": "AllSolid",
        "21": "SurfaceFlags",
        "22": "DispFlags",
        "23": "Contents",
        "FractionLeftSolid": {
          "type": "number",
          "desc": "Given the trace started inside a solid object, this is how far along the ray (0-1) the trace left the solid object."
        },
        "Contents": {
          "type": "number",
          "desc": "The contents flags of the hit surface (see trace.CONTENTS_*)."
        },
        "AllSolid": {
          "type": "boolean",
          "desc": "Whether the trace is entirely inside a solid object."
        },
        "HitNonWorld": {
          "type": "boolean",
          "desc": "Whether the trace hit something that is not part of the world."
        },
        "Fraction": {
          "type": "number",
          "desc": "How far along the trace ray the hit occurred, from 0-1."
        },
        "HitTexture": {
          "type": "string",
          "desc": "The name of the texture the trace hit."
        },
        "Entity": {
          "type": "Entity",
          "desc": "The entity that the trace hit."
        },
        "HitNoDraw": {
          "type": "boolean",
          "desc": "Whether the trace hit a no-draw brush."
        },
        "Normal": {
          "type": "Vector",
          "desc": "The direction vector of the trace as a normalised vector."
        },
        "HitPos": {
          "type": "Vector",
          "desc": "The position the trace hit."
        },
        "StartSolid": {
          "type": "boolean",
          "desc": "Whether the trace started inside a solid object."
        },
        "HitWorld": {
          "type": "boolean",
          "desc": "Whether the trace hit the world."
        },
        "DispFlags": {
          "type": "number",
          "desc": "The displacement flags of the this surface (see trace.DISPSURF_*)."
        },
        "SurfaceFlags": {
          "type": "number",
          "desc": "The surface flags of the hit surface (see trace.SURF_*)."
        },
        "HitNormal": {
          "type": "Vector",
          "desc": "The normal to the trace's impact position."
        },
        "MatType": {
          "type": "number",
          "desc": "The type of material the trace hit."
        },
        "SurfaceProps": {
          "type": "number",
          "desc": "The surface property hit."
        },
        "PhysicsBone": {
          "type": "number",
          "desc": "The physics bone ID that was hit."
        },
        "Hit": {
          "type": "boolean",
          "desc": "Whether the trace hit an obstacle."
        },
        "HitSky": {
          "type": "boolean",
          "desc": "Whether the trace hit the skybox."
        },
        "HitGroup": {
          "type": "number",
          "desc": "The hit group the trace hit."
        },
        "StartPos": {
          "type": "Vector",
          "desc": "The starting position of the trace."
        },
        "HitBox": {
          "type": "number",
          "desc": "The hit box ID the trace hit."
        }
      }
    },
    "MeshVertex": {
      "description": "Mesh vertex structure used by IMesh:buildFromTriangles().",
      "field": {
        "1": "pos",
        "2": "normal",
        "3": "color",
        "4": "userdata",
        "5": "u",
        "6": "v",
        "7": "tangent",
        "8": "binormal",
        "normal": {
          "type": "Vector",
          "desc": "(Optional) The normal of the vertex, used to calculate lighting."
        },
        "binormal": {
          "type": "Vector",
          "desc": "(Optional) The binormal of the vertex (not used by VertexLitGeneric materials)."
        },
        "userdata": {
          "type": "table<number,number>",
          "desc": "(Optional) Tangent data for VertexLitGeneric materials (x, y, z, handedness)."
        },
        "tangent": {
          "type": "Vector",
          "desc": "(Optional) The tangent of the vertex (not used by VertexLitGeneric materials)."
        },
        "color": {
          "type": "Color",
          "desc": "(Optional) The colour to assign to the vertex (for $vertexcolor/$vertexalpha materials)."
        },
        "v": {
          "type": "number",
          "desc": "The v co-ordinate of the vertex."
        },
        "u": {
          "type": "number",
          "desc": "The u co-ordinate of the vertex."
        },
        "pos": {
          "type": "Vector",
          "desc": "The position of the vertex."
        }
      },
      "client": true
    },
    "Halo": {
      "client": true,
      "description": "Halo definition.",
      "field": {
        "1": "Color",
        "2": "BlurX",
        "3": "BlurY",
        "4": "DrawPasses",
        "5": "Additive",
        "6": "IgnoreZ",
        "DrawPasses": {
          "type": "number",
          "desc": "The number of iterations to draw the halo."
        },
        "IgnoreZ": {
          "type": "boolean",
          "desc": "Whether the halo should be visible through other objects or not."
        },
        "Color": {
          "type": "Color",
          "desc": "The colour of the halo."
        },
        "BlurX": {
          "type": "number",
          "desc": "How much to blur along the x-axis."
        },
        "BlurY": {
          "type": "number",
          "desc": "How much to blur along the y-axis."
        },
        "Additive": {
          "type": "boolean",
          "desc": "Whether the halo should be drawn additively or not."
        }
      }
    },
    "Environment": {
      "description": "Environment information",
      "field": {
        "1": "name",
        "2": "gravity",
        "3": "temperature",
        "4": "air",
        "5": "Entity",
        "6": "radius",
        "air": {
          "type": "table<string,number>",
          "desc": "A table containing percentage levels of various gasses, summing to 100."
        },
        "temperature": {
          "type": "number",
          "desc": "The current temperature, in Kelvin."
        },
        "name": {
          "type": "string",
          "desc": "Name of the environment, if it has one."
        },
        "Entity": {
          "type": "Entity",
          "desc": "The entity that is responsible for the environment."
        },
        "gravity": {
          "type": "number",
          "desc": "Relative gravity, 1 indicates standard gravity."
        },
        "radius": {
          "type": "number",
          "desc": "The radius that the environment encompasses, if the environment is a planet."
        }
      },
      "server": true
    },
    "Faction": {
      "description": "Faction details.",
      "field": {
        "1": "Name",
        "2": "Tag",
        "3": "TagColour",
        "4": "LeaderID",
        "5": "Public",
        "Name": {
          "type": "string",
          "desc": "The name of the faction."
        },
        "LeaderID": {
          "type": "string",
          "desc": "The SteamID of the faction leader."
        },
        "TagColour": {
          "type": "Color",
          "desc": "The colour of the faction's tag."
        },
        "Public": {
          "type": "boolean",
          "desc": "Whether the faction is public or not."
        },
        "Tag": {
          "type": "string",
          "desc": "The tag of the faction."
        }
      },
      "server": true
    },
    "ScreenInfo": {
      "client": true,
      "description": "Screen information",
      "field": {
        "1": "Name",
        "2": "offset",
        "3": "RS",
        "4": "RatioX",
        "5": "x1",
        "6": "x2",
        "7": "y1",
        "8": "y2",
        "9": "z",
        "10": "rot",
        "offset": {
          "type": "Vector",
          "desc": "Offset of screen from prop"
        },
        "x2": {
          "type": "number",
          "desc": "Corner of screen in local co-ordinates (relative to offset)"
        },
        "y2": {
          "type": "number",
          "desc": "Corner of screen in local co-ordinates (relative to offset)"
        },
        "y1": {
          "type": "number",
          "desc": "Corner of screen in local co-ordinates (relative to offset)"
        },
        "RS": {
          "type": "number",
          "desc": "Resolution/scale"
        },
        "Name": {
          "type": "string",
          "desc": "Pretty name of model"
        },
        "z": {
          "type": "number",
          "desc": "Screen plane offset in local co-ordinates (relative to offset)"
        },
        "RatioX": {
          "type": "number",
          "desc": "Inverted Aspect ratio (height divided by width)"
        },
        "rot": {
          "type": "Angle",
          "desc": "Screen rotation"
        },
        "x1": {
          "type": "number",
          "desc": "Corner of screen in local co-ordinates (relative to offset)"
        }
      }
    },
    "Font": {
      "client": true,
      "description": "Font parameters used when creating fonts.",
      "field": {
        "1": "font",
        "2": "size",
        "3": "weight",
        "4": "blursize",
        "5": "antialias",
        "6": "underline",
        "7": "italic",
        "8": "strikeout",
        "9": "symbol",
        "10": "shadow",
        "11": "additive",
        "12": "outline",
        "13": "extended",
        "outline": {
          "type": "boolean",
          "desc": "Whether to add an outline to the font (default is false)."
        },
        "shadow": {
          "type": "boolean",
          "desc": "Whether to add a shadow to the font (default is false)."
        },
        "extended": {
          "type": "boolean",
          "desc": "Whether the font can be used to display characters outside the Latin-1 range. Code points past 0xFFFF are not supported (default is true)."
        },
        "symbol": {
          "type": "boolean",
          "desc": "Required when using a symbol font such as Wingdings (default is false)."
        },
        "underline": {
          "type": "boolean",
          "desc": "Whether to add an underline to the font (default is false)."
        },
        "strikeout": {
          "type": "boolean",
          "desc": "Whether to strikeout the font (default is false)."
        },
        "font": {
          "type": "string",
          "desc": "The name of the font to use (e.g. \"Arial\", \"Tahoma\", default is \"Arial\")."
        },
        "additive": {
          "type": "boolean",
          "desc": "Whether the font should render additively or not (default is false)."
        },
        "weight": {
          "type": "number",
          "desc": "The weight of the font (how thick it is, minimum of 100, default is 500)."
        },
        "italic": {
          "type": "boolean",
          "desc": "Whether the font is italic or not (note that fonts that are already italic do not need this, default is false)."
        },
        "antialias": {
          "type": "boolean",
          "desc": "Whether to anti-alias the text, which smooths/blurs the edges (default is true)."
        },
        "blursize": {
          "type": "number",
          "desc": "The strength of blurring to apply (between 0 and 10, default is 0)."
        },
        "size": {
          "type": "number",
          "desc": "The size of the font in pixels (between 4 and 255, default is 13)."
        }
      }
    },
    "Vertex": {
      "description": "Vertex format",
      "field": {
        "1": "x",
        "2": "y",
        "3": "u",
        "4": "v",
        "y": {
          "type": "number",
          "desc": "Y co-ordinate"
        },
        "x": {
          "type": "number",
          "desc": "X co-ordinate"
        },
        "u": {
          "type": "number",
          "desc": "U co-ordinate (optional, default is 0)"
        },
        "v": {
          "type": "number",
          "desc": "V co-ordinate (optional, default is 0)"
        }
      },
      "client": true
    },
    "AttachmentData": {
      "description": "Attachment data.",
      "field": {
        "1": "id",
        "2": "name",
        "id": {
          "type": "number",
          "desc": "The ID of the attachment."
        },
        "name": {
          "type": "string",
          "desc": "The name of the attachment."
        }
      }
    },
    "ToScreenData": {
      "client": true,
      "description": "Data indicating screen position of a world position.",
      "field": {
        "1": "x",
        "2": "y",
        "3": "visible",
        "y": {
          "type": "number",
          "desc": "The y position on the screen."
        },
        "x": {
          "type": "number",
          "desc": "The x position on the screen."
        },
        "visible": {
          "type": "boolean",
          "desc": "Whether the position is visible or not."
        }
      }
    },
    "PosAngData": {
      "description": "Position and angle data.",
      "field": {
        "1": "Pos",
        "2": "Ang",
        "Ang": {
          "type": "Angle",
          "desc": "The angles."
        },
        "Pos": {
          "type": "Vector",
          "desc": "The position."
        }
      }
    },
    "PhysEnvSettings": {
      "description": "Physics environment settings.",
      "field": {
        "1": "LookAheadTimeObjectsVsObject",
        "2": "LookAheadTimeObjectsVsWorld",
        "3": "MaxAngularVelocity",
        "4": "MaxCollisionChecksPerTimestep",
        "5": "MaxCollisionsPerObjectPerTimestep",
        "6": "MaxFrictionMass",
        "7": "MaxVelocity",
        "8": "MinFrictionMass",
        "LookAheadTimeObjectsVsObject": {
          "type": "number",
          "desc": "Maximum amount of seconds to precalculate collisions with objects."
        },
        "MaxCollisionChecksPerTimestep": {
          "type": "number",
          "desc": "Maximum collision checks per tick."
        },
        "MaxFrictionMass": {
          "type": "number",
          "desc": "Maximum mass of an object to be affected by friction."
        },
        "LookAheadTimeObjectsVsWorld": {
          "type": "number",
          "desc": "Maximum amount of seconds to precalculate collisions with world."
        },
        "MaxVelocity": {
          "type": "number",
          "desc": "Maximum speed of an object."
        },
        "MaxCollisionsPerObjectPerTimestep": {
          "type": "number",
          "desc": "Maximum collision per object per tick."
        },
        "MinFrictionMass": {
          "type": "number",
          "desc": "Minimum mass of an object to be affected by friction."
        },
        "MaxAngularVelocity": {
          "type": "number",
          "desc": "Maximum angular rotation per second."
        }
      }
    },
    "ClippingPlane": {
      "description": "Clipping plane.",
      "field": {
        "1": "Normal",
        "2": "Origin",
        "Normal": {
          "type": "Vector",
          "desc": "The plane's normal vector (local to the entity)."
        },
        "Origin": {
          "type": "Vector",
          "desc": "The plane's origin (local to the entity)."
        }
      }
    }
  },
  "classes": {
    "1": "Angle",
    "2": "ClientsideModel",
    "3": "Color",
    "4": "Effect",
    "5": "Entity",
    "6": "File",
    "7": "Hologram",
    "8": "IGModAudioChannel",
    "9": "IMaterial",
    "10": "IMesh",
    "11": "NPC",
    "12": "Panel",
    "13": "PhysObj",
    "14": "Player",
    "15": "Quaternion",
    "16": "RenderTarget",
    "17": "Shield",
    "18": "ShipCore",
    "19": "Shuttle",
    "20": "Sound",
    "21": "Stargate",
    "22": "VMatrix",
    "23": "Vector",
    "24": "Vehicle",
    "25": "Weapon",
    "26": "Wirelink",
    "IGModAudioChannel": {
      "description": "IGModAudioChannel",
      "client": true,
      "methods": {
        "1": "enableLooping",
        "2": "fft",
        "3": "get3DCone",
        "4": "get3DFadeDistance",
        "5": "getAverageBitRate",
        "6": "getBitsPerSample",
        "7": "getFileName",
        "8": "getLength",
        "9": "getLevel",
        "10": "getPan",
        "11": "getPlaybackRate",
        "12": "getPos",
        "13": "getSamplingRate",
        "14": "getState",
        "15": "getTime",
        "16": "getVolume",
        "17": "is3D",
        "18": "isBlockStreamed",
        "19": "isLooping",
        "20": "isValid",
        "21": "pause",
        "22": "play",
        "23": "set3DCone",
        "24": "set3DEnabled",
        "25": "set3DFadeDistance",
        "26": "setPan",
        "27": "setPlaybackRate",
        "28": "setPos",
        "29": "setTime",
        "30": "setVolume",
        "31": "stop",
        "getPlaybackRate": {
          "ret": "Playback rate, 1 is normal speed.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the playback rate of the sound."
        },
        "getVolume": {
          "ret": "Volume.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the current volume of the sound. Value is between 0 and 1."
        },
        "getLevel": {
          "ret": [
            "Left sound level.",
            "Right sound level."
          ],
          "returntypes": [
            "number",
            "number"
          ],
          "client": true,
          "description": "Gets the level of the sound for the left and right channels. Values are between 0 and 1."
        },
        "isLooping": {
          "ret": "True if looping, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the sound is looping."
        },
        "getFileName": {
          "ret": "File name.",
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Gets the file name of the sound."
        },
        "get3DCone": {
          "ret": "Inner angle, outer angle and outer volume.",
          "returntypes": [
            "number",
            "number"
          ],
          "client": true,
          "description": "Gets the 3D cone paramters for the sound."
        },
        "stop": {
          "client": true,
          "description": "Stops the sound from playing, next time you call :play() it will restart from the beginning."
        },
        "is3D": {
          "ret": "True if 3D, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the sound is 3D."
        },
        "getLength": {
          "ret": "Length of the sound.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the length of the sound."
        },
        "get3DFadeDistance": {
          "ret": "Min distance, max distance.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the 3D fade distance for the sound."
        },
        "setVolume": {
          "client": true,
          "description": "Sets the volume of the sound.",
          "param": {
            "1": "volume",
            "volume": "The volume to set, value is a multiplier (0 = muted, 1 = 100%, 2 = 200% etc.)"
          }
        },
        "setTime": {
          "client": true,
          "description": "Sets the time of the sound. You must have set 'noblock' in the flags for the sound.",
          "param": {
            "1": "time",
            "time": "The time in the sound to jump to."
          }
        },
        "setPos": {
          "client": true,
          "description": "Sets the position of the sound.",
          "param": {
            "1": "pos",
            "2": "dir",
            "dir": "Optional direction to play the sound towards. Leave nil to have no direction.",
            "pos": "The position in the world to place the sound."
          }
        },
        "getTime": {
          "ret": "Current time of the sound.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the current time the sound is at."
        },
        "setPlaybackRate": {
          "client": true,
          "description": "Sets the playback rate for the sound.",
          "param": {
            "1": "rate",
            "rate": "Playback rate, 1 is normal speed, 0.5 is half speed etc."
          }
        },
        "setPan": {
          "client": true,
          "description": "Sets the panning of the channel.",
          "param": {
            "1": "panning",
            "panning": "The panning to use as a number, with -1 being left, 0 centre, and 1 right."
          }
        },
        "isValid": {
          "ret": "True if valid, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the sound channel is valid for use."
        },
        "set3DFadeDistance": {
          "client": true,
          "description": "Sets the 3D fade distance for the sound.",
          "param": {
            "1": "min",
            "2": "max",
            "max": "Past this distance the sound stops fading.",
            "min": "Min distance from the sound to start fading."
          }
        },
        "set3DEnabled": {
          "client": true,
          "description": "Sets whether 3D playback is enabled.",
          "param": {
            "1": "enabled",
            "enabled": "Whether 3D playback should be enabled or not."
          }
        },
        "getPan": {
          "ret": "The panning of the channel, with -1 being left, 0 centre, and 1 right.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the current panning of the channel."
        },
        "getPos": {
          "ret": "Position vector of the sound.",
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Gets the position of the sound."
        },
        "getState": {
          "ret": "State enum (one of sounds.GMOD_CHANNEL_*).",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the state of the sound as an enum."
        },
        "set3DCone": {
          "client": true,
          "description": "Sets the 3D cone for the sound. For all parameters, -1 leaves it at its current value.",
          "param": {
            "1": "innerAng",
            "2": "outerAng",
            "3": "outerVolume",
            "outerVolume": "The volume outside the projection cone. Range is 0 (silent) to 1 (same as inside cone).",
            "outerAng": "The outer angle. Range is 0 (no cone) to 360 (sphere).",
            "innerAng": "The inner angle. Range is 0 (no cone) to 360 (sphere)."
          }
        },
        "play": {
          "client": true,
          "description": "Resumes or starts the sound playback depending on if it was paused or stopped."
        },
        "getBitsPerSample": {
          "ret": "Bits per sample.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the bits per sample for the file. Does not work for mp3 or ogg files."
        },
        "getSamplingRate": {
          "ret": "Sampling rate.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the sampling rate of the sound in MHz. Should always be 44100."
        },
        "isBlockStreamed": {
          "ret": "True if block streamed, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the sound is block streamed."
        },
        "enableLooping": {
          "client": true,
          "description": "Enables/disables looping. Only works on noblock channels.",
          "param": {
            "1": "enable",
            "enable": "Should looping be enabled?"
          }
        },
        "fft": {
          "ret": "The number of levels put into the table.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Outputs FFT data to the Output table.",
          "param": {
            "1": "output",
            "2": "type",
            "type": "The type of FFT data to put into it. One of the sounds.FFT_* enums.",
            "output": "The table to place the FFT data into."
          }
        },
        "pause": {
          "client": true,
          "description": "Pauses the sound playback."
        },
        "getAverageBitRate": {
          "ret": "Bit rate.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the current average bit rate of the sound."
        }
      }
    },
    "Quaternion": {
      "operators": {
        "1": "unm_Quaternion_nil",
        "2": "add_Quaternion_Quaternion",
        "3": "add_Quaternion_number",
        "4": "sub_Quaternion_number",
        "5": "sub_number_Quaternion",
        "6": "mul_Quaternion_number",
        "7": "mul_Quaternion_Quaternion",
        "8": "mul_Quaternion_Vector",
        "9": "div_Quaternion_number",
        "10": "div_number_Quaternion",
        "11": "div_Quaternion_Quaternion",
        "12": "pow_Quaternion_number",
        "13": "pow_number_Quaternion",
        "14": "eq_Quaternion_Quaternion",
        "div_Quaternion_number": {
          "ret": "A new quaternion whose components are the original's divided by the given number.",
          "description": "Divides the components of the given quaternion by the given number.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "number",
          "commutative": false
        },
        "mul_Quaternion_Vector": {
          "ret": "A new quaternion whose components are the Hamilton product of the original quaternion and the vector, \nwhere the vector is taken to be a quaternion with real part 0 and imaginary parts equal to the vector's values.",
          "description": "Multiplies a quaternion with a vector, this operation is NOT commutative.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "Vector"
        },
        "sub_number_Quaternion": {
          "ret": "A new quaternion whose real part is the number minus the quaternions real part, and the rest of the components negated.",
          "description": "Takes the given quaternion's values away from the given number.",
          "lhs": "number",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "Quaternion",
          "commutative": false
        },
        "add_Quaternion_Quaternion": {
          "ret": "A new quaternion whose values are the sum of those in the given quaternions.",
          "description": "Adds the given quaternions.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "Quaternion"
        },
        "eq_Quaternion_Quaternion": {
          "ret": "True if the given quaternions are equal accounting for minute floating point error.",
          "description": "Equality is considered to be the component-wise differences all being less than a small delta value (1e-7).",
          "lhs": "Quaternion",
          "returntypes": [
            "boolean"
          ],
          "rhs": "Quaternion"
        },
        "div_Quaternion_Quaternion": {
          "ret": "A new quaternion that is the result of multiplying the left quaternion by the inverse of the right.",
          "description": "Multiplies the left quaternion by the inverse of the right quaternion.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "Quaternion",
          "commutative": false
        },
        "pow_Quaternion_number": {
          "ret": "A new quaternion that is the result of raising the left quaternion to the given power.",
          "description": "Exponentiates the left quaternion by the given value.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "number",
          "commutative": false
        },
        "pow_number_Quaternion": {
          "ret": "A new quaternion that is the result of raising the number to the power of the quaternion.",
          "description": "Exponentiates the number by the given quaternion.",
          "lhs": "number",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "Quaternion",
          "commutative": false
        },
        "div_number_Quaternion": {
          "ret": "A new quaternion that is the result of multiplying the inverse of the right hand quaternion by the given number.",
          "description": "Multiplies the inverse of the quaternion by the given number.",
          "lhs": "number",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "Quaternion",
          "commutative": false
        },
        "mul_Quaternion_number": {
          "ret": "A new quaternion whose components are the original's multiplied by the given number.",
          "description": "Multiplies the given quaternion's components by the given number.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "number"
        },
        "add_Quaternion_number": {
          "ret": "A new quaternion whose real part is the original's plus the number. The other components are unchanged.",
          "description": "Adds the given number to the real part of the given quaternion.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "number"
        },
        "mul_Quaternion_Quaternion": {
          "ret": "A new quaternion whose components are the Hamilton product of the originals.",
          "description": "Multiplies two quaternions, this operation is NOT commutative.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "Quaternion"
        },
        "unm_Quaternion_nil": {
          "ret": "A new quaternion whose values are all the negation of the original's.",
          "description": "Negates the given quaternion.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ]
        },
        "sub_Quaternion_number": {
          "ret": "A new quaternion whose real part is the original's minus the number. The other components are unchanged.",
          "description": "Subtracts the given number from the real part of the given quaternion.",
          "lhs": "Quaternion",
          "returntypes": [
            "Quaternion"
          ],
          "rhs": "number",
          "commutative": false
        }
      },
      "description": "Quaternion",
      "methods": {
        "1": "abs",
        "2": "conj",
        "3": "exp",
        "4": "forward",
        "5": "inv",
        "6": "mod",
        "7": "right",
        "8": "setUnpacked",
        "9": "unpack",
        "10": "up",
        "setUnpacked": {
          "ret": "The quaternion.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Sets the values of the quaternion.",
          "param": {
            "1": "real",
            "2": "i",
            "3": "j",
            "4": "k",
            "i": "The i component value to set.",
            "k": "The k component value to set.",
            "j": "The j component value to set.",
            "real": "The real part to set."
          }
        },
        "exp": {
          "ret": "e raised to the power of the given quaternion.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns Euler's constant e raised to the power of the quaternion."
        },
        "abs": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the absolute value of the quaternion."
        },
        "right": {
          "ret": "Right vector.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns a vector pointing right, relative to the rotation represented by the quaternion."
        },
        "inv": {
          "ret": "The inverse of this quaternion as a new quaternion.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns the inverse of the quaternion."
        },
        "mod": {
          "ret": "A new quaternion with a normalised angle.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Changes the quaternion so that the represented rotation is by an angle between 0 and 180 degrees."
        },
        "unpack": {
          "ret": [
            "The real part.",
            "The i component.",
            "The j component.",
            "The k component."
          ],
          "description": "Returns the 4 components of the quaternion."
        },
        "forward": {
          "ret": "Forward vector.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns a vector pointing forward, relative to the rotation represented by the quaternion."
        },
        "up": {
          "ret": "Up vector.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns a vector pointing up, relative to the rotation represented by the quaternion."
        },
        "conj": {
          "ret": "The conjugate of this quaternion as a new quaternion.",
          "returntypes": [
            "Quaternion"
          ],
          "description": "Returns the conjugate of the quaternion."
        }
      }
    },
    "ClientsideModel": {
      "supertype": "Entity",
      "description": "ClientsideModel",
      "client": true,
      "methods": {
        "1": "drawModel",
        "2": "getModelScale",
        "3": "getRenderMatrix",
        "4": "getScaleVector",
        "5": "remove",
        "6": "setAng",
        "7": "setAnim",
        "8": "setBodygroup",
        "9": "setLOD",
        "10": "setMaterial",
        "11": "setModel",
        "12": "setModelScale",
        "13": "setPos",
        "14": "setRenderMatrix",
        "15": "setRenderMode",
        "16": "setScaleVector",
        "17": "setSkin",
        "18": "setSubMaterial",
        "getScaleVector": {
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Returns the current scaling vector applied to the clientside model."
        },
        "setModelScale": {
          "client": true,
          "description": "Sets the model scale of the given clientside model.",
          "param": {
            "1": "scale",
            "2": "deltaTime",
            "deltaTime": "The time to take when scaling.",
            "scale": "The scale value."
          }
        },
        "setSubMaterial": {
          "client": true,
          "description": "Sets the sub-material at the given index on the clientside model.",
          "param": {
            "1": "index",
            "2": "mat",
            "mat": "Material path.",
            "index": "Sub-material index."
          }
        },
        "setMaterial": {
          "client": true,
          "description": "Sets the material of the clientside model.",
          "param": {
            "1": "mat",
            "mat": "Material path to set."
          }
        },
        "getModelScale": {
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the current model scale of the clientside model (as set by setModelScale())."
        },
        "setPos": {
          "client": true,
          "description": "Sets the clientside model's position for rendering.",
          "param": {
            "1": "vec",
            "vec": "Position in the current 3D world to render at."
          }
        },
        "setAng": {
          "client": true,
          "description": "Sets the clientside model's angles for rendering.",
          "param": {
            "1": "ang",
            "ang": "Angles in the current 3D world to render with."
          }
        },
        "drawModel": {
          "client": true,
          "description": "Draws the model at the clientside model's position and angles."
        },
        "setModel": {
          "client": true,
          "description": "Sets the clientside model's model path.",
          "param": {
            "1": "model",
            "model": "Model path to use."
          }
        },
        "setSkin": {
          "client": true,
          "description": "Sets the skin to use on the clientside model.",
          "param": {
            "1": "skin",
            "skin": "Skin index to use."
          }
        },
        "getRenderMatrix": {
          "returntypes": [
            [
              "VMatrix",
              "nil"
            ]
          ],
          "client": true,
          "description": "Returns the current rendering matrix for the given clientside model, if it has one."
        },
        "setLOD": {
          "client": true,
          "description": "Sets the level of detail for the clientside model.",
          "param": {
            "1": "level",
            "level": "A number between 0 and 8 for fixed quality (0 being highest quality), or -1 for automatic based on distance."
          }
        },
        "remove": {
          "client": true,
          "description": "Removes the clientside model. Call this if you don't need it anymore. \nAttempting to use it again will fail."
        },
        "setRenderMatrix": {
          "client": true,
          "description": "Sets the rendering matrix for the given clientside model.",
          "param": {
            "1": "matrix",
            "matrix": "The matrix to apply to this model when rendering, or nil to reset it."
          }
        },
        "setAnim": {
          "client": true,
          "description": "Animates the given clientside model.",
          "param": {
            "1": "anim",
            "2": "frame",
            "3": "rate",
            "rate": "Rate to play animation.",
            "frame": "Frame to start at.",
            "anim": "Animation enum."
          }
        },
        "setBodygroup": {
          "client": true,
          "description": "Sets the given bodygroup.",
          "param": {
            "1": "id",
            "2": "subID",
            "subID": "Sub ID to use.",
            "id": "Body group ID."
          }
        },
        "setRenderMode": {
          "client": true,
          "description": "Sets the render mode of the clientside model.",
          "param": {
            "1": "renderMode",
            "renderMode": "Rendering mode, from ents.RENDERMODE_*"
          }
        },
        "setScaleVector": {
          "client": true,
          "description": "Sets the scale vector of the given clientside model.",
          "param": {
            "1": "scaleVec",
            "scaleVec": "The vector scale to apply."
          }
        }
      }
    },
    "Hologram": {
      "description": "Holograms",
      "methods": {
        "1": "disableShading",
        "2": "followBone",
        "3": "getBoneAngles",
        "4": "getBoneOffset",
        "5": "getBoneScale",
        "6": "getDTVar",
        "7": "getFlexes",
        "8": "getScale",
        "9": "isBoneJiggle",
        "10": "remove",
        "11": "removeHalo",
        "12": "setAngVel",
        "13": "setAnim",
        "14": "setBoneAngles",
        "15": "setBoneJiggle",
        "16": "setBoneOffset",
        "17": "setBoneScale",
        "18": "setClip",
        "19": "setDTVar",
        "20": "setDrawTranslucent",
        "21": "setFlexScale",
        "22": "setFlexWeight",
        "23": "setLOD",
        "24": "setMaterialOverride",
        "25": "setModel",
        "26": "setNoDraw",
        "27": "setParent",
        "28": "setPose",
        "29": "setRenderFX",
        "30": "setRenderMesh",
        "31": "setScale",
        "32": "setVel",
        "getDTVar": {
          "ret": "The current value of the DTVar.",
          "description": "Gets the value of the given DTVar. \nFor the index: Float and Vector are between 1 and 31, Entity is between 1 and 30, Bool is between 1 and 29, String is between 1 and 4, all others are between 1 and 32.",
          "param": {
            "1": "type",
            "2": "index",
            "index": "The index of the DTVar.",
            "type": "The type of variable. Valid types are: Angle, Bool, Entity, Int, Float, String, Vector"
          }
        },
        "setPose": {
          "description": "Sets the pose parameter on the given hologram.",
          "param": {
            "1": "pose",
            "2": "value",
            "value": "Number value for the parameter.",
            "pose": "String pose parameter."
          }
        },
        "setAngVel": {
          "server": true,
          "description": "Sets the hologram's angular velocity.",
          "param": {
            "1": "angularVelocity",
            "angularVelocity": "Angular velocity (as an Angle object)."
          }
        },
        "setFlexWeight": {
          "description": "Sets the weight (value) of a flex.",
          "param": {
            "1": "flexid",
            "2": "weight",
            "flexid": "The index of the flex.",
            "weight": "The weight to set."
          }
        },
        "setBoneAngles": {
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the angles of the given hologram's bone.",
          "param": {
            "1": "bone",
            "2": "angles",
            "angles": "The angles (relative to the bone) to apply.",
            "bone": "Bone index or string name."
          }
        },
        "getScale": {
          "ret": "The scale assigned to the hologram (may be a vector or number).",
          "returntypes": [
            [
              "Vector",
              "number"
            ]
          ],
          "description": "Gets the current scale of the hologram."
        },
        "getBoneAngles": {
          "returntypes": [
            "Angle"
          ],
          "description": "Returns the angles value for the given bone.",
          "param": {
            "1": "bone",
            "bone": "Bone index or string name."
          }
        },
        "disableShading": {
          "description": "Disables or enables shading on a hologram.",
          "param": {
            "1": "shade",
            "shade": "Whether to suppress shading on the hologram."
          }
        },
        "setDTVar": {
          "server": true,
          "description": "Sets a DataTable variable on the hologram. These are automatically synced between the server and the client. \nFor the index: Float and Vector are between 1 and 31, Entity is between 1 and 30, Bool is between 1 and 29, String is between 1 and 4, all others are between 1 and 32. \nFor entities, use ents.NULL_ENTITY to reset the value.",
          "param": {
            "1": "type",
            "2": "index",
            "3": "value",
            "type": "The type of variable. Valid types are: Angle, Bool, Entity, Int, Float, String, Vector",
            "value": "The value to set.",
            "index": "The index of the DTVar."
          }
        },
        "removeHalo": {
          "ret": "True if the hologram had a halo which has been removed, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Removes the halo from the hologram, if it has one."
        },
        "getBoneScale": {
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the scale value for the given bone.",
          "param": {
            "1": "bone",
            "bone": "Bone index or string name."
          }
        },
        "setVel": {
          "server": true,
          "description": "Sets the hologram's linear velocity.",
          "param": {
            "1": "velocity",
            "velocity": "Velocity vector."
          }
        },
        "setRenderFX": {
          "server": true,
          "description": "Sets the render FX for the hologram.",
          "param": {
            "1": "effect",
            "effect": "Effect index."
          }
        },
        "setFlexScale": {
          "server": true,
          "description": "Sets the scale of all flexes of a hologram",
          "param": {
            "1": "scale",
            "scale": "Number scale value."
          }
        },
        "setBoneJiggle": {
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets whether the given bone has jiggle enabled or not.",
          "param": {
            "1": "bone",
            "2": "enabled",
            "enabled": "True if the bone's jiggle should be enabled, false otherwise.",
            "bone": "Bone index or string name."
          }
        },
        "setClip": {
          "description": "Updates a clip plane, which cuts the hologram's visuals.",
          "param": {
            "1": "index",
            "2": "enabled",
            "3": "origin",
            "4": "normal",
            "5": "islocal",
            "normal": "The normal pointing outwards from the clipping plane.",
            "index": "The unique index value, must be a number between 1 and 16.",
            "origin": "The position of the clipping plane.",
            "islocal": "Whether the clipping plane's position should be in local space or not.",
            "enabled": "Whether to enable or disable the clipping plane."
          }
        },
        "setParent": {
          "server": true,
          "description": "Parents this hologram to the specified entity.",
          "param": {
            "1": "parent",
            "2": "attachment",
            "attachment": "Optional attachment name to attach to.",
            "parent": "The parent entity to attach to."
          }
        },
        "setScale": {
          "server": true,
          "description": "Sets the hologram scale, either a vector or a number.",
          "param": {
            "1": "scale",
            "scale": "Either a number scale, or a vector scale."
          }
        },
        "getFlexes": {
          "returntypes": [
            "table<string,number>"
          ],
          "description": "Returns a table of flexname -> flexid pairs for use in flex functions. \nThese IDs become invalid when the hologram's model changes."
        },
        "remove": {
          "server": true,
          "description": "Removes the hologram from the world. It cannot be used again after this operation."
        },
        "setNoDraw": {
          "description": "Sets whether the hologram should be flagged as not drawing, which leaves it invisible.",
          "param": {
            "1": "noDraw",
            "noDraw": "Whether the hologram should be flagged not to draw."
          }
        },
        "setBoneScale": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the scale of a bone.",
          "param": {
            "1": "bone",
            "2": "scale",
            "scale": "Vector scale value.",
            "bone": "Bone index or string name."
          }
        },
        "setModel": {
          "server": true,
          "description": "Sets the model of the hologram.",
          "param": {
            "1": "model",
            "model": "Model path."
          }
        },
        "setBoneOffset": {
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the position of the given hologram's bone.",
          "param": {
            "1": "bone",
            "2": "offset",
            "offset": "The offset (relative to the bone) to apply.",
            "bone": "Bone index or string name."
          }
        },
        "setMaterialOverride": {
          "ret": [
            "True if setting the material override succeeded, false otherwise.",
            "If the operation failed, the reason why."
          ],
          "returntypes": [
            "boolean",
            "string"
          ],
          "client": true,
          "description": "Sets the material to use to override the hologram's networked material name. This can be used to set a render target \nas the material for a hologram, which combined with setRenderMesh can allow for procedurally generated models. \nNote that setting a render target as the material requires the USE_RENDER_TARGET_MATERIALS_WITH_HOLOGRAMS permission.",
          "param": {
            "1": "mat",
            "mat": "The material instance (IMaterial or RenderTarget) to apply. Pass nil to remove the override."
          }
        },
        "setRenderMesh": {
          "ret": [
            "True if setting the mesh succeeded, false otherwise.",
            "If the operation failed, the reason why."
          ],
          "returntypes": [
            "boolean",
            "string"
          ],
          "client": true,
          "description": "Sets a mesh to be used as the hologram's model. \nThis will override the hologram's original model. Note that a material must be set, either on the server or by using setMaterialOverride(), otherwise the mesh will render as a wireframe. \nMake sure to set the original model to one with an idle sequence that has no rotation, otherwise the mesh will not render correctly. One such model is \"models/error.mdl\". \nNote that this requires the DRAW_MESH_HOLOGRAMS permission.",
          "param": {
            "1": "mesh",
            "mesh": "The IMesh to use as the hologram's model. Pass nil to remove the mesh."
          }
        },
        "setLOD": {
          "ret": [
            "True if setting the LOD succeeded, false otherwise.",
            "If the operation failed, the reason why."
          ],
          "returntypes": [
            "boolean",
            "string"
          ],
          "client": true,
          "description": "Sets the level of detail for the given hologram.",
          "param": {
            "1": "level",
            "level": "A number between 0 and 8 for fixed quality (0 being highest quality), or -1 for automatic based on distance."
          }
        },
        "getBoneOffset": {
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the offset value for the given bone.",
          "param": {
            "1": "bone",
            "bone": "Bone index or string name."
          }
        },
        "setAnim": {
          "description": "Sets the animation for the given hologram.",
          "param": {
            "1": "anim",
            "2": "cycle",
            "3": "rate",
            "rate": "Playback rate. Default is 1.",
            "cycle": "How far through the animation to start (between 0 and 1). Default is 0.",
            "anim": "Animation ENUM."
          }
        },
        "setDrawTranslucent": {
          "server": true,
          "description": "Sets whether the hologram should be forced to draw in the translucent render pass. \nNote that this occurs automatically if the hologram's alpha drops below 255.",
          "param": {
            "1": "drawTranslucent",
            "drawTranslucent": "Boolean indicating whether to draw in the translucent pass."
          }
        },
        "isBoneJiggle": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns the jiggle value for the given bone.",
          "param": {
            "1": "bone",
            "bone": "Bone index or string name."
          }
        },
        "followBone": {
          "server": true,
          "description": "Parents this hologram to the specified entity's bone.",
          "param": {
            "1": "parent",
            "2": "boneID",
            "boneID": "The ID of the bone to attach to.",
            "parent": "The parent entity to attach to."
          }
        }
      }
    },
    "Color": {
      "description": "Colours in RGB space. \nThis is a direct binding to the GLua colour type.",
      "operators": {
        "1": "add_Color_Color",
        "2": "sub_Color_Color",
        "3": "mul_Color_number",
        "4": "div_Color_number",
        "add_Color_Color": {
          "ret": "A new colour whose values are the sum of those in the given colours.",
          "description": "Adds the given colour values field-by-field (including alpha).",
          "lhs": "Color",
          "returntypes": [
            "Color"
          ],
          "rhs": "Color"
        },
        "div_Color_number": {
          "ret": "A new colour whose values are divided by the given number.",
          "description": "Divides the given colour's RGBA values by the given number.",
          "lhs": "Color",
          "returntypes": [
            "Color"
          ],
          "rhs": "number",
          "commutative": false
        },
        "mul_Color_number": {
          "ret": "A new colour whose values are multiplied by the given number.",
          "description": "Multiplies the given colour's RGBA values by the given number.",
          "lhs": "Color",
          "returntypes": [
            "Color"
          ],
          "rhs": "number"
        },
        "sub_Color_Color": {
          "ret": "A new colour whose values are the second colour's values subtracted from the first.",
          "description": "Subtracts the second colour's values from the first field-by-field (including alpha).",
          "lhs": "Color",
          "returntypes": [
            "Color"
          ],
          "rhs": "Color"
        }
      },
      "methods": {
        "1": "SetUnpacked",
        "2": "ToHSL",
        "3": "ToHSV",
        "4": "ToNormalizedHSV",
        "5": "ToTable",
        "6": "ToVector",
        "7": "Unpack",
        "SetUnpacked": {
          "description": "Sets the RGBA components of the colour.",
          "param": {
            "1": "r",
            "2": "g",
            "3": "b",
            "4": "a",
            "a": "The alpha value to set.",
            "b": "The blue value to set.",
            "g": "The green value to set.",
            "r": "The red value to set."
          }
        },
        "ToTable": {
          "description": "Returns the colour as an (r, g, b, a) array.",
          "returntypes": [
            "table<number,number>"
          ]
        },
        "Unpack": {
          "ret": [
            "The red value.",
            "The green value.",
            "The blue value.",
            "The alpha value."
          ],
          "description": "Returns the components of the colour.",
          "returntypes": [
            "number",
            "number",
            "number",
            "number"
          ]
        },
        "ToVector": {
          "description": "Returns the RGB values as a Vector, with each component normalised to be between 0 and 1.",
          "returntypes": [
            "Vector"
          ]
        },
        "ToHSV": {
          "ret": [
            "The hue of the colour in degrees between 0 and 360.",
            "The saturation of the colour between 0 and 1.",
            "The value of the colour between 0 and 1."
          ],
          "description": "Returns the colour in HSV space.",
          "returntypes": [
            "number",
            "number",
            "number"
          ]
        },
        "ToNormalizedHSV": {
          "ret": [
            "The hue of the colour between 0 and 1.",
            "The saturation of the colour between 0 and 1.",
            "The value of the colour between 0 and 1."
          ],
          "description": "Returns the colour in HSV space, normalising the hue to between 0 and 1.",
          "returntypes": [
            "number",
            "number",
            "number"
          ]
        },
        "ToHSL": {
          "ret": [
            "The hue of the colour in degrees between 0 and 360.",
            "The saturation of the colour between 0 and 1.",
            "The lightness of the colour between 0 and 1."
          ],
          "description": "Returns the colour in HSL space.",
          "returntypes": [
            "number",
            "number",
            "number"
          ]
        }
      },
      "client": true,
      "server": true
    },
    "IMaterial": {
      "description": "IMaterial",
      "client": true,
      "methods": {
        "1": "getColor",
        "2": "getFloat",
        "3": "getInt",
        "4": "getMatrix",
        "5": "getName",
        "6": "getShader",
        "7": "getString",
        "8": "getVector",
        "9": "getVectorLinear",
        "10": "height",
        "11": "isError",
        "12": "width",
        "getMatrix": {
          "ret": "VMatrix value at the given key.",
          "returntypes": [
            "VMatrix"
          ],
          "client": true,
          "description": "Gets the given VMatrix material parameter.",
          "param": {
            "1": "param",
            "param": "The string key to read."
          }
        },
        "isError": {
          "ret": "True if the material invalid.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the material has not loaded correctly (i.e doesn't exist)."
        },
        "getName": {
          "ret": "String path of the material.",
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Gets the path of the material."
        },
        "getString": {
          "ret": "String value at the given key.",
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Gets the given string material parameter.",
          "param": {
            "1": "param",
            "param": "The string key to read."
          }
        },
        "getVectorLinear": {
          "ret": "Vector value at the given key.",
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Gets the given linear vector material parameter.",
          "param": {
            "1": "param",
            "param": "The string key to read."
          }
        },
        "getFloat": {
          "ret": "Float value at the given key.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the given float material parameter.",
          "param": {
            "1": "param",
            "param": "The string key to read."
          }
        },
        "getShader": {
          "ret": "String shader name, e.g \"UnlitGeneric\".",
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Gets the shader the material is using."
        },
        "getColor": {
          "ret": "Pixel colour object.",
          "returntypes": [
            "Color"
          ],
          "client": true,
          "description": "Gets the colour of the given pixel co-ordinates on the texture. \nOnly works for PNG files.",
          "param": {
            "1": "x",
            "2": "y",
            "y": "The y co-ordinate.",
            "x": "The x co-ordinate."
          }
        },
        "height": {
          "ret": "Height value.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the height of the material."
        },
        "width": {
          "ret": "Width value.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the width of the material."
        },
        "getVector": {
          "ret": "Vector value at the given key.",
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Gets the given vector material parameter.",
          "param": {
            "1": "param",
            "param": "The string key to read."
          }
        },
        "getInt": {
          "ret": "Integer value at the given key.",
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Gets the given integer material parameter.",
          "param": {
            "1": "param",
            "param": "The string key to read."
          }
        }
      }
    },
    "RenderTarget": {
      "description": "Render Target",
      "client": true,
      "methods": {
        "1": "draw",
        "2": "drawToTexture",
        "3": "freeRT",
        "draw": {
          "client": true,
          "description": "Draws the texture itself at the given position and with given width/height. \nNote that width/height values different from the texture size will stretch the texture, \nnot resize it.",
          "param": {
            "1": "x",
            "2": "y",
            "3": "w",
            "4": "h",
            "h": "Height.",
            "w": "Width.",
            "y": "Y position to draw.",
            "x": "X position to draw."
          }
        },
        "freeRT": {
          "client": true,
          "description": "Frees the given RT for use by another entity, allowing you to allocate a new one. \nDo not attempt to draw/update it after freeing or your chip will error."
        },
        "drawToTexture": {
          "client": true,
          "description": "Runs the given function, drawing anything rendered to the RT texture.",
          "param": {
            "1": "func",
            "func": "A function that will be executed to draw to the texture."
          }
        }
      }
    },
    "Vector": {
      "description": "3-dimensional vectors.",
      "operators": {
        "1": "mul_Vector_number",
        "2": "div_Vector_number",
        "3": "add_Vector_Vector",
        "4": "sub_Vector_Vector",
        "5": "unm_Vector_nil",
        "sub_Vector_Vector": {
          "ret": "A new vector whose values are the values in the first vector minus those in the second.",
          "description": "Subtracts one vector's values from another.",
          "lhs": "Vector",
          "returntypes": [
            "Vector"
          ],
          "rhs": "Vector"
        },
        "mul_Vector_number": {
          "ret": "A new vector whose values are equal to those in the original vector multiplied by the given number.",
          "description": "Multiplies a vector by a scalar value.",
          "lhs": "Vector",
          "returntypes": [
            "Vector"
          ],
          "rhs": "number"
        },
        "unm_Vector_nil": {
          "ret": "A new vector whose values are the negation of the given vector's.",
          "description": "Returns the negation of the given vector.",
          "lhs": "Vector",
          "returntypes": [
            "Vector"
          ]
        },
        "add_Vector_Vector": {
          "ret": "A new vector whose values are the sum of the values in the given vectors.",
          "description": "Adds two vectors.",
          "lhs": "Vector",
          "returntypes": [
            "Vector"
          ],
          "rhs": "Vector"
        },
        "div_Vector_number": {
          "ret": "A new vector whose values are equal to those in the original vector divided by the given number.",
          "description": "Divides a vector by a scalar value.",
          "lhs": "Vector",
          "returntypes": [
            "Vector"
          ],
          "rhs": "number",
          "commutative": false
        }
      },
      "methods": {
        "1": "Add",
        "2": "Angle",
        "3": "AngleEx",
        "4": "Cross",
        "5": "DistToSqr",
        "6": "Distance",
        "7": "Div",
        "8": "Dot",
        "9": "GetNormalized",
        "10": "IsEqualTol",
        "11": "IsZero",
        "12": "Length",
        "13": "Length2D",
        "14": "Length2DSqr",
        "15": "LengthSqr",
        "16": "Mul",
        "17": "Normalize",
        "18": "Rotate",
        "19": "Set",
        "20": "SetUnpacked",
        "21": "Sub",
        "22": "ToColor",
        "23": "ToScreen",
        "24": "ToTable",
        "25": "Unpack",
        "26": "WithinAABox",
        "27": "Zero",
        "Length2DSqr": {
          "description": "Returns the squared 2-dimensional length of the vector (ignoring the z component).",
          "returntypes": [
            "number"
          ]
        },
        "IsEqualTol": {
          "description": "Returns whether the given vectors are equal, using the given tolerance value.",
          "returntypes": [
            "boolean"
          ],
          "param": {
            "1": "vector",
            "2": "tolerance",
            "tolerance": "The tolerance value to use to consider the vectors equal.",
            "vector": "The vector to compare against."
          }
        },
        "LengthSqr": {
          "description": "Returns the squared length of the vector.",
          "returntypes": [
            "number"
          ]
        },
        "DistToSqr": {
          "description": "Returns the squared distance between the two vectors. This avoids the cost of a square-root.",
          "returntypes": [
            "number"
          ],
          "param": {
            "1": "vector",
            "vector": "The vector to get the squared distance from."
          }
        },
        "Zero": {
          "ret": "The modified vector.",
          "description": "Sets all component values to 0, modifying in-place..",
          "returntypes": [
            "Vector"
          ]
        },
        "Normalize": {
          "ret": "The normalised vector.",
          "description": "Normalises the given vector's length to equal 1, modifying in-place.",
          "returntypes": [
            "Vector"
          ]
        },
        "Dot": {
          "description": "Returns the dot product of the two vectors.",
          "returntypes": [
            "number"
          ],
          "param": {
            "1": "vector",
            "vector": "The vector to get the dot product with."
          }
        },
        "WithinAABox": {
          "description": "Returns true if the given vector is within the axis-aligned bounding box defined by the given vector arguments.",
          "returntypes": [
            "boolean"
          ],
          "param": {
            "1": "mins",
            "2": "maxs",
            "maxs": "The maximum corner of the box.",
            "mins": "The minimum corner of the box."
          }
        },
        "Angle": {
          "description": "Returns an Angle object representing the vector as a forward direction, using Vector( 0, 0, 1 ) as up.",
          "returntypes": [
            "Angle"
          ]
        },
        "Unpack": {
          "ret": [
            "The x-component.",
            "The y-component.",
            "The z-component."
          ],
          "description": "Returns the component values of the vector.",
          "returntypes": [
            "number",
            "number",
            "number"
          ]
        },
        "Distance": {
          "description": "Returns the distance between the two vectors.",
          "returntypes": [
            "number"
          ],
          "param": {
            "1": "vector",
            "vector": "The vector to get the distance from."
          }
        },
        "Sub": {
          "ret": "The modified vector.",
          "description": "Subtracts the given argument vector, modifying in-place.",
          "returntypes": [
            "Vector"
          ],
          "param": {
            "1": "vector",
            "vector": "The vector to subtract."
          }
        },
        "GetNormalized": {
          "description": "Returns a new vector that has the same direction as the given vector, but with length equal to 1.",
          "returntypes": [
            "Vector"
          ]
        },
        "ToScreen": {
          "description": "Returns the position on the local player's screen that corresponds to this vector as a world position.",
          "returntypes": [
            "ToScreenData"
          ],
          "client": true
        },
        "Set": {
          "ret": "The modified vector.",
          "description": "Sets the vector's component values to equal the given vector, modifying in-place.",
          "returntypes": [
            "Vector"
          ],
          "param": {
            "1": "vector",
            "vector": "The vector to take the component values from."
          }
        },
        "IsZero": {
          "description": "Returns true if the given vector has all components equal to 0.",
          "returntypes": [
            "boolean"
          ]
        },
        "Div": {
          "ret": "The modified vector.",
          "description": "Divides the vector by the given argument value, modifying in-place.",
          "returntypes": [
            "Vector"
          ],
          "param": {
            "1": "divisor",
            "divisor": "The number to divide the vector's components by."
          }
        },
        "SetUnpacked": {
          "ret": "The modified vector.",
          "description": "Sets the vector's component values, modifying in-place.",
          "returntypes": [
            "Vector"
          ],
          "param": {
            "1": "x",
            "2": "y",
            "3": "z",
            "x": "The x-component value.",
            "z": "The z-component value.",
            "y": "The y-component value."
          }
        },
        "Rotate": {
          "ret": "The rotated vector.",
          "description": "Rotates the given vector by the given angles, modifying in-place.",
          "param": {
            "1": "angles",
            "angles": "The angles to rotate the vector with."
          }
        },
        "Length2D": {
          "description": "Returns the 2-dimensional length of the vector (ignoring the z component).",
          "returntypes": [
            "number"
          ]
        },
        "Mul": {
          "ret": "The modified vector.",
          "description": "Multiplies the given vector by the given number, modifying in-place.",
          "returntypes": [
            "Vector"
          ],
          "param": {
            "1": "multiplier",
            "multiplier": "The value to multiply the vector's components with."
          }
        },
        "ToTable": {
          "description": "Returns the vector as an array of 3 elements.",
          "returntypes": [
            "table<number,number>"
          ]
        },
        "Cross": {
          "description": "Returns the cross product of the two vectors as a new vector.",
          "returntypes": [
            "Vector"
          ],
          "param": {
            "1": "vector",
            "vector": "The vector to take the cross product with."
          }
        },
        "ToColor": {
          "ret": "A colour representing the vector.",
          "description": "Converts the vector into a colour by multiplying each component by 255.",
          "returntypes": [
            "Color"
          ]
        },
        "AngleEx": {
          "description": "Returns an Angle object representing the vector as a forward direction, using the given up direction.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "up",
            "up": "The up direction to use."
          }
        },
        "Length": {
          "description": "Returns the length of the vector.",
          "returntypes": [
            "number"
          ]
        },
        "Add": {
          "ret": "The modified vector.",
          "description": "Adds the given argument vector's component values to the given vector, modifying in-place.",
          "returntypes": [
            "Vector"
          ],
          "param": {
            "1": "vector",
            "vector": "The vector to add."
          }
        }
      },
      "client": true,
      "server": true
    },
    "Entity": {
      "description": "Entity",
      "methods": {
        "1": "addCallback",
        "2": "ang",
        "3": "attachments",
        "4": "boundingRadius",
        "5": "callOnRemove",
        "6": "class",
        "7": "color",
        "8": "coreHealth",
        "9": "coreMaxHealth",
        "10": "createWire",
        "11": "deleteWire",
        "12": "entHealth",
        "13": "entMaxHealth",
        "14": "eyeAngles",
        "15": "eyePos",
        "16": "followBone",
        "17": "forward",
        "18": "getAttachment",
        "19": "getBodygroup",
        "20": "getBodygroupCount",
        "21": "getBoneCount",
        "22": "getBoneName",
        "23": "getBoneParent",
        "24": "getBonePosition",
        "25": "getChildBones",
        "26": "getChildren",
        "27": "getClippingPlanes",
        "28": "getCollisionGroup",
        "29": "getConstraints",
        "30": "getCore",
        "31": "getCreationID",
        "32": "getDoorState",
        "33": "getDoors",
        "34": "getEFlags",
        "35": "getEnvironmentData",
        "36": "getFlags",
        "37": "getGroundEntity",
        "38": "getMapCreationID",
        "39": "getMaterials",
        "40": "getModelBounds",
        "41": "getNode",
        "42": "getParent",
        "43": "getPhysicsObject",
        "44": "getPhysicsObjectCount",
        "45": "getPhysicsObjectNum",
        "46": "getPoseParameter",
        "47": "getPropScale",
        "48": "getRenderMode",
        "49": "getResourceAmount",
        "50": "getRotatedAABB",
        "51": "getScreen",
        "52": "getSequence",
        "53": "getSequenceList",
        "54": "getSequenceName",
        "55": "getSingleConstrainedEnts",
        "56": "getSubMaterial",
        "57": "getSubMaterialColor",
        "58": "getSubsystemHealth",
        "59": "getUnitCapacity",
        "60": "getWireName",
        "61": "getWirelink",
        "62": "getWorldTransformMatrix",
        "63": "index",
        "64": "isConstrained",
        "65": "isDormant",
        "66": "isEFlagSet",
        "67": "isFlagSet",
        "68": "isNPC",
        "69": "isPlayer",
        "70": "isValid",
        "71": "isVehicle",
        "72": "isWeapon",
        "73": "isWeldedTo",
        "74": "link",
        "75": "lookupBone",
        "76": "lookupSequence",
        "77": "material",
        "78": "model",
        "79": "nocollide",
        "80": "obbCenter",
        "81": "obbCenterW",
        "82": "obbMaxs",
        "83": "obbMins",
        "84": "obbSize",
        "85": "owner",
        "86": "pos",
        "87": "pullResource",
        "88": "pushResource",
        "89": "remove",
        "90": "removeCallOnRemove",
        "91": "removeCallback",
        "92": "removeTrail",
        "93": "right",
        "94": "sequenceDuration",
        "95": "setAlpha",
        "96": "setAng",
        "97": "setBodygroup",
        "98": "setCollisionGroup",
        "99": "setColor",
        "100": "setLocalAng",
        "101": "setMaterial",
        "102": "setModel",
        "103": "setNotSolid",
        "104": "setParent",
        "105": "setPos",
        "106": "setPullRate",
        "107": "setPushRate",
        "108": "setRenderMode",
        "109": "setSkin",
        "110": "setSubMaterial",
        "111": "setSubMaterialColor",
        "112": "skin",
        "113": "spriteTrail",
        "114": "toLocal",
        "115": "toWorld",
        "116": "unconstrain",
        "117": "unlink",
        "118": "up",
        "119": "vel",
        "120": "waterLevel",
        "121": "weldTo",
        "getUnitCapacity": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Retrieves the maximum supply of the given resource.",
          "param": {
            "1": "resource",
            "resource": "String resource name, e.g \"energy\"."
          }
        },
        "index": {
          "ret": "The numerical index of the entity",
          "server": true,
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the EntIndex of the entity"
        },
        "getPhysicsObjectCount": {
          "ret": "The number of physics objects present.",
          "returntypes": [
            "number"
          ],
          "description": "Gets the number of physics objects the entity has."
        },
        "class": {
          "ret": "The string class name",
          "server": true,
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Returns the class of the entity"
        },
        "addCallback": {
          "usage": "-- Adding a PhysicsCollide callback \nEntity:addCallback( \"PhysicsCollide\", \"MyUniqueName\", function( Ent, CollisionData ) \n\tprint( Ent, \"hit\", CollisionData.HitEntity, \"with speed\", CollisionData.Speed ) \nend )",
          "description": "Adds a callback to an entity for a specific event. \nValid events are: \n- <a href=\"https://wiki.facepunch.com/gmod/Structures/CollisionData\">PhysicsCollide</a>",
          "param": {
            "1": "name",
            "2": "identifier",
            "3": "func",
            "func": "The function to call when the event is fired.",
            "identifier": "The identifier for the event.",
            "name": "The name of the event to add a callback for."
          }
        },
        "getClippingPlanes": {
          "ret": "A table of clipping planes if the entity has been clipped, otherwise nil.",
          "returntypes": [
            [
              "table<number,ClippingPlane>",
              "nil"
            ]
          ],
          "description": "Returns the clipping planes applied to the entity using the physical clipping tool."
        },
        "getRenderMode": {
          "ret": "The entity's current render mode.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the entity's current render mode. See the ents.RENDERMODE_* enums for possible values."
        },
        "getSequenceList": {
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Returns a list of all sequences (animations) on the model."
        },
        "isConstrained": {
          "deprecated": "Use constraint.hasConstraints",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the entity is constrained to something."
        },
        "getWirelink": {
          "ret": "A wirelink for the given entity, if it has inputs/outputs. Otherwise nil.",
          "server": true,
          "returntypes": [
            [
              "Wirelink",
              "nil"
            ],
            "string"
          ],
          "description": "Gets the wirelink associated with the given entity (if the entity is wireable)."
        },
        "isValid": {
          "ret": "True if valid, false if not",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Checks if an entity is valid."
        },
        "obbSize": {
          "ret": "The outer bounding box size",
          "server": true,
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Returns the x, y, z size of the entity's outer bounding box (local to the entity) \nNote that this will return a zero-vector on clientside models as it is derived from collision data."
        },
        "deleteWire": {
          "ret": "True if successful, false, error if not.",
          "deprecated": "Use wire.delete",
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Deletes the wire leading to self's input.",
          "param": {
            "1": "input",
            "input": "The name of the input to unwire."
          }
        },
        "pullResource": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Pulls the given amount of resource from node 2 to node 1 instantly.",
          "param": {
            "1": "resource",
            "2": "amount",
            "amount": "Amount to transfer.",
            "resource": "String resource name, e.g \"energy\", \"oxygen\" etc."
          }
        },
        "spriteTrail": {
          "ret": "The created sprite trail entity.",
          "server": true,
          "returntypes": [
            "Entity"
          ],
          "description": "Adds/updates a sprite trail on the given entity.",
          "param": {
            "1": "colour",
            "2": "startSize",
            "3": "endSize",
            "4": "length",
            "5": "material",
            "material": "The material to use. Invalid materials will have no effect.",
            "length": "The length of the trail.",
            "startSize": "The starting size of the trail.",
            "endSize": "The end size of the trail.",
            "colour": "The colour of the trail."
          }
        },
        "getMapCreationID": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the map creation ID of the entity (or -1 if the entity is not part of the map)."
        },
        "getBonePosition": {
          "ret": [
            "The world position of the bone, or nil if no such bone exists.",
            "The world angles of the bone."
          ],
          "returntypes": [
            [
              "nil",
              "Vector"
            ],
            [
              "nil",
              "Angle"
            ]
          ],
          "description": "Gets the position and angles of the bone with the given ID on the entity.",
          "param": {
            "1": "boneID",
            "boneID": "The ID of the bone to get the position of."
          }
        },
        "getSubMaterial": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the currently set sub-material at the given index.",
          "param": {
            "1": "index",
            "index": "The index from Entity:getMaterials(), minus 1."
          }
        },
        "getNode": {
          "ret": "Resource node entity, potentially two of them for a resource valve.",
          "server": true,
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the resource node the entity is connected to, or nil."
        },
        "createWire": {
          "ret": "True if successful, false, error if not.",
          "deprecated": "Use wire.create",
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Wires the input of self to the output of Ent.",
          "param": {
            "1": "ent",
            "2": "input",
            "3": "output",
            "output": "The name of the output on Ent to wire to.",
            "input": "The name of the input on self to wire.",
            "ent": "The entity to wire to."
          }
        },
        "setPullRate": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the pull rate (node 2 to node 1) on the given resource valve.",
          "param": {
            "1": "resource",
            "2": "rate",
            "rate": "Rate to transfer resources.",
            "resource": "String resource name, e.g \"energy\", \"oxygen\" etc."
          }
        },
        "link": {
          "ret": "True if succeeded, false and a failure reason otherwise.",
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Links two entities. One should be a resource node.",
          "param": {
            "1": "ent",
            "ent": "Second entity to link to."
          }
        },
        "unconstrain": {
          "server": true,
          "deprecated": "Use constraint.removeConstraints( entity, type ) or constraint.removeAll( entity ).",
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "type": "string?"
          },
          "description": "Removes constraints from the given entity.",
          "param": {
            "1": "type",
            "type": "Optional type of constraint to remove. No type will remove all constraints."
          }
        },
        "getBoneName": {
          "ret": "The name of the bone, or nil if no such bone exists.",
          "returntypes": [
            [
              "nil",
              "string"
            ]
          ],
          "description": "Gets the nice name of the bone with the given ID on the entity.",
          "param": {
            "1": "boneID",
            "boneID": "The ID of the bone to get the name of."
          }
        },
        "pos": {
          "ret": "The position vector",
          "server": true,
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Returns the position of the entity"
        },
        "callOnRemove": {
          "description": "Registers a callback to run on removal of this entity.",
          "param": {
            "1": "identifier",
            "2": "callback",
            "3": "...",
            "...": "Arguments to pass to the callback.",
            "callback": "The function to run when the entity is removed. Receives the entity, then the arguments passed to this.",
            "identifier": "A unique string identifier for this callback. Used if you want to remove it later."
          }
        },
        "nocollide": {
          "server": true,
          "deprecated": "Use constraint.noCollide",
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "bone2": "number?",
            "bone1": "number?",
            "ent": "Entity"
          },
          "description": "Creates a nocollide constraint between two entities.",
          "param": {
            "1": "ent",
            "2": "bone1",
            "3": "bone2",
            "bone2": "Bone on the second entity, defaults to 0.",
            "bone1": "Bone on the first entity, defaults to 0.",
            "ent": "Second entity."
          }
        },
        "getDoors": {
          "server": true,
          "returntypes": [
            "table"
          ],
          "description": "Returns the door entities an SBEP door controller is controlling."
        },
        "getEnvironmentData": {
          "server": true,
          "returntypes": [
            "Environment"
          ],
          "usage": "return { \n\tgravity = 1, \n\tradius = 1000, \n\ttemperature = 285, \n\tair = { \n\t\tOxygen = 20, \n\t\tNitrogen = 75, \n\t\tHydrogen = 4.5, \n\t\tCO2 = 0.5 \n\t}, \n\tname = \"Planet Name\", \n\t--Entity = Entity [1000][stargazer_ls_core] \n}",
          "description": "Gets the environment data table of an entity."
        },
        "getDoorState": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns the state of an SBEP door."
        },
        "getBoneCount": {
          "ret": "The number of bones on the entity, or -1 if the number is not known.",
          "returntypes": [
            "number"
          ],
          "description": "Gets the number of bones the entity's model has defined."
        },
        "getResourceAmount": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Retrieves the current supply of the given resource.",
          "param": {
            "1": "resource",
            "resource": "String resource name, e.g \"energy\"."
          }
        },
        "attachments": {
          "returntypes": [
            "table<number,AttachmentData>"
          ],
          "description": "Returns a table of all attachments the entity's model has, or nil if it has none."
        },
        "setAlpha": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "alpha": "number"
          },
          "description": "Sets the alpha of the given entity without changing the colour.",
          "param": {
            "1": "alpha",
            "alpha": "The alpha value to set from 0 - 255."
          }
        },
        "setSubMaterialColor": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets an entity's sub-material colour.",
          "param": {
            "1": "index",
            "2": "colour",
            "colour": "The colour to set on the sub-material.",
            "index": "The index of the sub-material, get it from getMaterials()."
          }
        },
        "isDormant": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns true if the entity is dormant, that is, outside the current PVS of the local player."
        },
        "getCore": {
          "server": true,
          "returntypes": [
            "ShipCore"
          ],
          "description": "Returns the ship core that the entity is assigned to, or nil if it does not have one."
        },
        "removeTrail": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Removes an entity's sprite trail."
        },
        "setColor": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the entity's colour. \nIf you're changing alpha < 255, then you also need to update the rendermode to something like ents.RENDERMODE_TRANSALPHA.",
          "param": {
            "1": "r",
            "2": "g",
            "3": "b",
            "4": "a",
            "a": "Alpha value",
            "b": "Blue number value",
            "g": "Green number value",
            "r": "Either a colour object, or the red number value."
          }
        },
        "vel": {
          "ret": "The velocity vector",
          "server": true,
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Returns the velocity of the entity"
        },
        "isEFlagSet": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the given EFL_* flag is set on the entity.",
          "param": [
            "flag"
          ]
        },
        "isPlayer": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given entity is a player."
        },
        "setNotSolid": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the entity solid state",
          "param": {
            "1": "notsolid",
            "notsolid": "Should the entity be not solid?"
          }
        },
        "setLocalAng": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the entity's angles locally.",
          "param": {
            "1": "ang",
            "ang": "Local angles."
          }
        },
        "getModelBounds": {
          "ret": [
            "The position of the local minimum corner of the model's bounding box.",
            "The position of the local maximum corner of the model's bounding box."
          ],
          "server": true,
          "returntypes": [
            "Vector",
            "Vector"
          ],
          "client": true,
          "description": "Returns the min and max bounds for the entity's model, ignoring its current scale. \nThis works on normal entities and clientside models."
        },
        "obbMaxs": {
          "ret": "The outer bounding box maximum",
          "server": true,
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Returns the max of the entity's outer bounding box (local to the entity) \nNote that this will return a zero-vector on clientside models as it is derived from collision data."
        },
        "owner": {
          "server": true,
          "returntypes": [
            [
              "Entity",
              "Player"
            ]
          ],
          "description": "Gets the owner of the entity"
        },
        "setSkin": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the skin of an entity.",
          "param": {
            "1": "skin",
            "skin": "The skin index to use."
          }
        },
        "isWeapon": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given entity is a weapon."
        },
        "weldTo": {
          "server": true,
          "deprecated": "Use constraint.weld",
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "deleteEnt1OnBreak": "boolean?",
            "noCollide": "boolean?",
            "bone2": "number?",
            "bone1": "number?",
            "ent": "Entity"
          },
          "description": "Creates a weld constraint between two entities.",
          "param": {
            "1": "ent",
            "2": "bone1",
            "3": "bone2",
            "4": "forceLimit",
            "5": "noCollide",
            "6": "deleteEnt1OnBreak",
            "deleteEnt1OnBreak": "Sets whether to delete the first entity when the weld breaks.",
            "noCollide": "Limit on the weld before it breaks, default is 0 (no limit).",
            "bone2": "Bone on the second entity, defaults to 0.",
            "bone1": "Bone on the first entity, defaults to 0.",
            "ent": "Second entity."
          }
        },
        "getRotatedAABB": {
          "ret": "Mins, Maxs vectors which represent a world-space AABB containing the entire box given (and often more).",
          "usage": "-- Get the extents of an AABB containing the entity's OBB entirely. \nlocal Mins, Maxs = Ent:getRotatedAABB( Ent:obbMins(), Ent:obbMaxs() ) \n-- Find all entities inside the entity. If you use Ent:localToWorld() on the OBB, it will not find correctly. \nlocal EntsInside = find.inBox( Ent:pos() + Mins, Ent:pos() + Maxs )",
          "returntypes": [
            "Vector",
            "Vector"
          ],
          "server": true,
          "client": true,
          "description": "Returns world-space extents for the entity given local-space mins and maxs. \nUnlike using localToWorld, this creates a true AABB that encompasses the given space regardless of rotation.",
          "param": {
            "1": "mins",
            "2": "maxs",
            "maxs": "The OBB maxs vector to end the box at.",
            "mins": "The OBB mins vector to start the box at."
          }
        },
        "setModel": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the model of the given entity (does not change physics!)",
          "param": {
            "1": "model",
            "model": "The path to the model to use."
          }
        },
        "getCreationID": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the creation ID of the entity."
        },
        "setBodygroup": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the bodygroup of the given entity.",
          "param": {
            "1": "id",
            "2": "subID",
            "subID": "Sub ID.",
            "id": "Bodygroup ID."
          }
        },
        "getSubMaterialColor": {
          "returntypes": [
            "Color"
          ],
          "description": "Returns the currently set sub-material colour at the given index.",
          "param": {
            "1": "index",
            "index": "The index from Entity:getMaterials(), minus 1."
          }
        },
        "setPos": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the entitiy's position. \nWhen called on a player and running in restricted mode (e.g. executed from the shared area), this requires the SET_PLAYER_POSITION permission.",
          "param": {
            "1": "vec",
            "vec": "New position"
          }
        },
        "getWireName": {
          "returntypes": [
            "string"
          ],
          "description": "Gets the name set with the wire namer tool."
        },
        "getBoneParent": {
          "ret": "The ID of the parent bone, or -1 if no parent bone exists.",
          "returntypes": [
            "number"
          ],
          "description": "Gets the ID of the bone that is the parent bone for the given bone ID on the entity.",
          "param": {
            "1": "boneID",
            "boneID": "The ID of the bone to get the parent bone ID for."
          }
        },
        "setMaterial": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets an entity's material.",
          "param": {
            "1": "material",
            "material": "The string path to the material."
          }
        },
        "setSubMaterial": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets an entity's sub-material.",
          "param": {
            "1": "index",
            "2": "material",
            "material": "The material to replace the sub-material with.",
            "index": "The index of the sub-material, get it from getMaterials()."
          }
        },
        "getGroundEntity": {
          "ret": "The entity below this entity.",
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the entity that this entity is currently standing on."
        },
        "color": {
          "returntypes": [
            "table"
          ],
          "description": "Returns the entity's colour."
        },
        "getPoseParameter": {
          "returntypes": [
            "number"
          ],
          "description": "Gets the given pose parameter.",
          "param": {
            "1": "pose",
            "pose": "Pose parameter."
          }
        },
        "lookupSequence": {
          "returntypes": [
            "number"
          ],
          "description": "Looks up the index of the given animation name.",
          "param": {
            "1": "name",
            "name": "Animation name."
          }
        },
        "getAttachment": {
          "ret": "A table with fields \"Pos\" and \"Ang\", or nil if no such attachment exists.",
          "returntypes": [
            "PosAngData"
          ],
          "description": "Returns a table containing the position and angles of the given attachment, if it exists.",
          "param": {
            "1": "attachment",
            "attachment": "The attachment name to get the position/angle for."
          }
        },
        "getChildren": {
          "ret": "A table containing all child entities.",
          "server": true,
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Returns a list of all child entities parented to this entity."
        },
        "getFlags": {
          "returntypes": [
            "number"
          ],
          "description": "Returns a mask indicating the FL_* flags the entity has currently set."
        },
        "setAng": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the entity's angles",
          "param": {
            "1": "ang",
            "ang": "New angles"
          }
        },
        "skin": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the entity's skin."
        },
        "coreMaxHealth": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the maximum health of the ship core the entity is assigned to."
        },
        "material": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the entity's material."
        },
        "getSequenceName": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the name of the given sequence (animation) index.",
          "param": {
            "1": "sequence",
            "sequence": "Sequence index."
          }
        },
        "isFlagSet": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the given FL_* flag is set on the entity.",
          "param": [
            "flag"
          ]
        },
        "getWorldTransformMatrix": {
          "ret": "The entity's world transform as a matrix.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Returns the entity's world transform matrix. \nThe first 3 columns are a rotation matrix representing the entity's angles, and the last column is its position."
        },
        "getSubsystemHealth": {
          "ret": "Subsystem health or nil if the entity is not a subsystem.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the entity's subsystem health, if it has any. Otherwise nil."
        },
        "coreHealth": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the health of the ship core the entity is assigned to."
        },
        "up": {
          "returntypes": [
            "Vector"
          ],
          "description": "Gets the entity's upward direction vector."
        },
        "getPhysicsObjectNum": {
          "ret": "The physics object, or nil if no such physics object exists.",
          "returntypes": [
            "PhysObj"
          ],
          "description": "Gets the physics object at the given index. \nNote: indices are 0 based.",
          "param": {
            "1": "index",
            "index": "The index of the physics object, starting from 0."
          }
        },
        "obbMins": {
          "ret": "The outer bounding box minimum",
          "server": true,
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Returns the min of the entity's outer bounding box (local to the entity) \nNote that this will return a zero-vector on clientside models as it is derived from collision data."
        },
        "eyePos": {
          "server": true,
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Gets the entity's eye position"
        },
        "entHealth": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the entity's current health."
        },
        "forward": {
          "returntypes": [
            "Vector"
          ],
          "description": "Gets the entity's forward direction vector."
        },
        "getMaterials": {
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Returns all materials on the given entity. \nUse the index value - 1 in Entity:setSubMaterial() to replace it. \nAlways returns the original materials, is not affected by Entity:setSubMaterial()."
        },
        "removeCallback": {
          "description": "Removes a callback added by Entity:addCallback().",
          "param": {
            "1": "name",
            "2": "identifier",
            "identifier": "The identifier given when the callback was added.",
            "name": "The name of the event to remove a callback for."
          }
        },
        "model": {
          "server": true,
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Gets the model of an entity"
        },
        "followBone": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "boneID": "number",
            "parent": "Entity"
          },
          "description": "Parents the entity to the given parent's bone.",
          "param": {
            "1": "parent",
            "2": "boneID",
            "boneID": "The ID of the bone on the parent to attach to.",
            "parent": "The parent entity to attach this entity to."
          }
        },
        "toLocal": {
          "returntypes": [
            "Vector"
          ],
          "server": true,
          "client": true,
          "description": "Converts a vector in world space to entity local space",
          "param": {
            "1": "data",
            "data": "Local space vector"
          }
        },
        "waterLevel": {
          "ret": "0 is not in water, 1 is slightly inside, 2 is mostly inside and 3 is completely inside.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the entity's water level."
        },
        "getBodygroup": {
          "returntypes": [
            "number"
          ],
          "description": "Gets the bodygroup the current ID is using.",
          "param": {
            "1": "id",
            "id": "Bodygroup ID."
          }
        },
        "obbCenterW": {
          "ret": "The position vector of the outer bounding box center in world space.",
          "server": true,
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Returns the world position of the entity's outer bounding box. \nNote that this will return the entity's position on clientside models as it is derived from collision data."
        },
        "remove": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Removes the given entity. \nThis requires the REMOVE_ENTITY permission when running in restricted mode (e.g. executed from the shared area)."
        },
        "getSingleConstrainedEnts": {
          "deprecated": "Use constraint.getConstrainedEntities",
          "server": true,
          "returntypes": [
            "table<number,Entity>"
          ],
          "description": "Gets all entities constrained to self, non-recursive."
        },
        "isVehicle": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given entity is a vehicle."
        },
        "isWeldedTo": {
          "deprecated": "Use constraint.findConstraintEntity( entity, \"Weld\" )",
          "server": true,
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the first entity that is welded to the given entity."
        },
        "right": {
          "returntypes": [
            "Vector"
          ],
          "description": "Gets the entity's right direction vector."
        },
        "getConstraints": {
          "server": true,
          "deprecated": "Use constraint.getAllConstrainedEntities",
          "returntypes": [
            "table<number,Entity>"
          ],
          "paramtypes": {
            "filter": "function?"
          },
          "description": "Gets a table of all constrained entities.",
          "param": {
            "1": "filter",
            "filter": "(Optional) Filter function, return true to keep the entity, false to discard it."
          }
        },
        "getEFlags": {
          "returntypes": [
            "number"
          ],
          "description": "Returns a mask indicating the EFL_* flags the entity has currently set."
        },
        "isNPC": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given entity is an NPC."
        },
        "getParent": {
          "server": true,
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the parent of the given entity."
        },
        "setPushRate": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the push rate (node 1 to node 2) on the given resource valve.",
          "param": {
            "1": "resource",
            "2": "rate",
            "rate": "Rate to transfer resources.",
            "resource": "String resource name, e.g \"energy\", \"oxygen\" etc."
          }
        },
        "getPhysicsObject": {
          "ret": "The physics object, or nil if it does not have one.",
          "returntypes": [
            "PhysObj"
          ],
          "description": "Gets the physics object associated with the entity."
        },
        "ang": {
          "ret": "The angle",
          "server": true,
          "returntypes": [
            "Angle"
          ],
          "client": true,
          "description": "Returns the angle of the entity"
        },
        "getSequence": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the current sequence (animation) playing on the given entity."
        },
        "unlink": {
          "ret": "True if succeeded, false and a failure reason otherwise.",
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Unlinks the given entity from its resource node."
        },
        "getCollisionGroup": {
          "ret": "The collision group (one of ents.COLLISION_GROUP_*)",
          "returntypes": [
            "number"
          ],
          "description": "Gets the collision group of an entity."
        },
        "sequenceDuration": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the duration of the current playing sequence (animation)."
        },
        "toWorld": {
          "returntypes": [
            "Vector"
          ],
          "server": true,
          "client": true,
          "description": "Converts a vector in entity local space to world space",
          "param": {
            "1": "data",
            "data": "Local space vector"
          }
        },
        "getBodygroupCount": {
          "returntypes": [
            "number"
          ],
          "description": "Gets the bodygroup count.",
          "param": {
            "1": "id",
            "id": "Bodygroup ID."
          }
        },
        "getPropScale": {
          "ret": "Vector or number scale value, depending on the settings used to resize the entity.",
          "returntypes": [
            [
              "number",
              "Vector",
              "VMatrix"
            ]
          ],
          "description": "Returns the scaling used to resize the given entity, or 1 if no scaling is applied."
        },
        "lookupBone": {
          "ret": "The ID of the bone, or nil if no such bone exists.",
          "returntypes": [
            [
              "nil",
              "number"
            ]
          ],
          "description": "Looks up the ID for an entity's bone using its nice name.",
          "param": {
            "1": "boneName",
            "boneName": "The name of the bone to lookup."
          }
        },
        "removeCallOnRemove": {
          "description": "Removes a registered removal callback.",
          "param": {
            "1": "identifier",
            "identifier": "The unique string identifier given to Entity:callOnRemove()."
          }
        },
        "obbCenter": {
          "ret": "The position vector of the outer bounding box center",
          "server": true,
          "returntypes": [
            "Vector"
          ],
          "client": true,
          "description": "Returns the local position of the entity's outer bounding box \nNote that this will return a zero-vector on clientside models as it is derived from collision data."
        },
        "getChildBones": {
          "ret": "A table containing all child bone IDs, or nil if no such bone exists.",
          "returntypes": [
            [
              "table<number,number>",
              "nil"
            ]
          ],
          "description": "Gets the IDs of all child bones for the given bone ID on the entity.",
          "param": {
            "1": "boneID",
            "boneID": "The ID of the bone to get child bones for."
          }
        },
        "entMaxHealth": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the entity's maximum health."
        },
        "setParent": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "paramtypes": {
            "ent": "Entity"
          },
          "description": "Parents the first entity to the second.",
          "param": {
            "1": "ent",
            "ent": "Entity to parent to. Pass nil to remove the entity's current parent."
          }
        },
        "boundingRadius": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "client": true,
          "description": "Returns the distance to the furthest corner on the entity's bounding box. \nNote that this will return 0 on clientside models as it is derived from collision data."
        },
        "setCollisionGroup": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the entity's collision group, which determines what it collides with.",
          "param": {
            "1": "group",
            "group": "COLLISION_GROUP_* enum."
          }
        },
        "eyeAngles": {
          "server": true,
          "returntypes": [
            "Angle"
          ],
          "client": true,
          "description": "Gets the entitiy's eye angles"
        },
        "pushResource": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Pushes the given amount of resource from node 1 to node 2 instantly.",
          "param": {
            "1": "resource",
            "2": "amount",
            "amount": "Amount to transfer.",
            "resource": "String resource name, e.g \"energy\", \"oxygen\" etc."
          }
        },
        "setRenderMode": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the render mode of the given entity.",
          "param": {
            "1": "mode",
            "mode": "ents.RENDERMODE_* enum."
          }
        },
        "getScreen": {
          "ret": "Linked Starfall screen, or nil if no screen is linked.",
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the screen a repeater is linked to."
        }
      }
    },
    "Angle": {
      "description": "3-dimensional eulerian angles.",
      "operators": {
        "1": "mul_Angle_number",
        "2": "div_Angle_number",
        "3": "add_Angle_Angle",
        "4": "sub_Angle_Angle",
        "5": "unm_Angle_nil",
        "div_Angle_number": {
          "ret": "A new angle whose values are equal to those in the original angle divided by the given number.",
          "description": "Divides an angle by a scalar value.",
          "lhs": "Angle",
          "returntypes": [
            "Angle"
          ],
          "rhs": "number",
          "commutative": false
        },
        "mul_Angle_number": {
          "ret": "A new angle whose values are equal to those in the original angle multiplied by the given number.",
          "description": "Multiplies an angle by a scalar value.",
          "lhs": "Angle",
          "returntypes": [
            "Angle"
          ],
          "rhs": "number"
        },
        "unm_Angle_nil": {
          "ret": "A new angle whose values are the negation of the given angle's.",
          "description": "Returns the negation of the given angle.",
          "lhs": "Angle",
          "returntypes": [
            "Angle"
          ]
        },
        "add_Angle_Angle": {
          "ret": "A new angle whose values are the sum of the values in the given vectors.",
          "description": "Adds two angles.",
          "lhs": "Angle",
          "returntypes": [
            "Angle"
          ],
          "rhs": "Angle"
        },
        "sub_Angle_Angle": {
          "ret": "A new angle whose values are the values in the first angle minus those in the second.",
          "description": "Subtracts one angle's values from another.",
          "lhs": "Angle",
          "returntypes": [
            "Angle"
          ],
          "rhs": "Angle"
        }
      },
      "methods": {
        "1": "Add",
        "2": "Div",
        "3": "Forward",
        "4": "IsZero",
        "5": "Mul",
        "6": "Normalize",
        "7": "Right",
        "8": "RotateAroundAxis",
        "9": "Set",
        "10": "SetUnpacked",
        "11": "SnapTo",
        "12": "Sub",
        "13": "ToTable",
        "14": "Unpack",
        "15": "Up",
        "16": "Zero",
        "SetUnpacked": {
          "ret": "The modified angle.",
          "description": "Sets the angle's component values, modifying in-place.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "pitch",
            "2": "yaw",
            "3": "roll",
            "pitch": "The pitch to set.",
            "roll": "The roll to set.",
            "yaw": "The yaw to set."
          }
        },
        "Up": {
          "description": "Returns the up direction for the given angles.",
          "returntypes": [
            "Vector"
          ]
        },
        "Zero": {
          "ret": "The modified angle.",
          "description": "Sets all component values to 0, modifying in-place..",
          "returntypes": [
            "Angle"
          ]
        },
        "Set": {
          "ret": "The modified angle.",
          "description": "Sets the angle's component values to equal the given angles, modifying in-place.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "angle",
            "angle": "The angle to take the component values from."
          }
        },
        "IsZero": {
          "description": "Returns true if the angle has all components equal to 0.",
          "returntypes": [
            "boolean"
          ]
        },
        "Div": {
          "ret": "The modified angle.",
          "description": "Divides the given angle's component values by the given number, modifying in-place.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "divisor",
            "divisor": "The number value to divide the angle's components by."
          }
        },
        "SnapTo": {
          "ret": "The modified angle.",
          "description": "Rounds a component of the given angles to the given amount of degrees.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "component",
            "2": "targetDegrees",
            "targetDegrees": "The amount of degrees to round to (e.g. 90 would round to the nearest multiple of 90 degrees).",
            "component": "The component to be snapped (e.g. \"p\", \"y\", \"r\")."
          }
        },
        "ToTable": {
          "description": "Returns the angles as an array of 3 elements.",
          "returntypes": [
            "table<number,number>"
          ]
        },
        "Sub": {
          "ret": "The modified angle.",
          "description": "Subtracts the given argument angles from the given angles, modifying in-place.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "angle",
            "angle": "The angle to subtract."
          }
        },
        "Mul": {
          "ret": "The modified angle.",
          "description": "Multiplies the given angle's component values by the given number, modifying in-place.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "multiplier",
            "multiplier": "The number value to multiply the angle's components by."
          }
        },
        "Normalize": {
          "ret": "The modified angle.",
          "description": "Normalises the given angle's components into the (-180, 180] range, modifying in-place.",
          "returntypes": [
            "Angle"
          ]
        },
        "Unpack": {
          "ret": [
            "The pitch value.",
            "The yaw value.",
            "The roll value."
          ],
          "description": "Returns the component values of the angle.",
          "returntypes": [
            "number",
            "number",
            "number"
          ]
        },
        "RotateAroundAxis": {
          "ret": "The modified angle.",
          "description": "Rotates the given angles around the given axis by the given amount in degrees, modifying in-place.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "axis",
            "2": "amount",
            "amount": "The amount in degrees to rotate by.",
            "axis": "The axis vector to rotate the angles around."
          }
        },
        "Forward": {
          "description": "Returns the forward direction for the given angles.",
          "returntypes": [
            "Vector"
          ]
        },
        "Right": {
          "description": "Returns the right direction for the given angles.",
          "returntypes": [
            "Vector"
          ]
        },
        "Add": {
          "ret": "The modified angle.",
          "description": "Adds the given argument angle's component values to the given angle, modifying in-place.",
          "returntypes": [
            "Angle"
          ],
          "param": {
            "1": "angle",
            "angle": "The angle to add."
          }
        }
      },
      "client": true,
      "server": true
    },
    "Sound": {
      "description": "Sound",
      "methods": {
        "1": "isPlaying",
        "2": "isValid",
        "3": "play",
        "4": "setLevel",
        "5": "setPitch",
        "6": "setVolume",
        "7": "stop",
        "isValid": {
          "ret": "True if the sound is valid, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Checks if the given sound is valid."
        },
        "stop": {
          "description": "Stops or fades out the sound.",
          "param": {
            "1": "fade",
            "fade": "(Optional) Time, in seconds, to fade out the sound. Not given = stop immediately"
          }
        },
        "setLevel": {
          "description": "Sets the sound level. This determines the sound attenuation. Only works when the sound is not playing. \nSee https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel for values and more info \n(use decibel value from the 'code' column, not the actual enum or 'value' column).",
          "param": {
            "1": "level",
            "level": "The sound level to set (between 10 and 511)."
          }
        },
        "isPlaying": {
          "ret": "True if the sound is playing, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Checks if the sound is playing"
        },
        "setVolume": {
          "description": "Sets the sound volume",
          "param": {
            "1": "vol",
            "2": "delta",
            "vol": "Volume as a percent between 0 and 1",
            "delta": "(Optional) The transition time between the current volume and the new one (in seconds)."
          }
        },
        "play": {
          "description": "Plays the sound."
        },
        "setPitch": {
          "description": "Sets the sound pitch",
          "param": {
            "1": "pitch",
            "2": "delta",
            "pitch": "The sound pitch as a percent from 0 to 255",
            "delta": "(Optional) The transition time between the current pitch and the new one (in seconds)."
          }
        }
      }
    },
    "Shuttle": {
      "supertype": "Entity",
      "description": "Represents TSCM shuttles.",
      "server": true,
      "methods": {
        "1": "getMaxShieldCharge",
        "2": "getPassenger",
        "3": "getPassengerCount",
        "4": "getPassengerSeatPoint",
        "5": "getPilot",
        "6": "getTotalShieldCharge",
        "7": "isShieldActive",
        "getPassenger": {
          "server": true,
          "returntypes": [
            [
              "Player",
              "nil"
            ]
          ],
          "description": "Returns the passenger at the given index in the shuttle.",
          "param": {
            "1": "index",
            "index": "The index of the passenger to return (1-based)."
          }
        },
        "isShieldActive": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the shuttle's shield is active, false otherwise."
        },
        "getPassengerCount": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the number of passenger seats available in the shuttle."
        },
        "getPilot": {
          "server": true,
          "returntypes": [
            [
              "Player",
              "nil"
            ]
          ],
          "description": "Returns the pilot of the shuttle."
        },
        "getPassengerSeatPoint": {
          "ret": [
            "The position of the seat position in world space.",
            "The angles of the seat position in world space."
          ],
          "server": true,
          "returntypes": [
            [
              "Vector",
              "nil"
            ],
            [
              "Angle",
              "nil"
            ]
          ],
          "description": "Returns the position and angles of the passenger seat position at the given index.",
          "param": {
            "1": "index",
            "index": "The index of the passenger seat position and angles to return (1-based)."
          }
        },
        "getMaxShieldCharge": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the maximum charge for the shuttle's shields."
        },
        "getTotalShieldCharge": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the current state of charge for the shuttle's shields."
        }
      }
    },
    "IMesh": {
      "description": "IMesh object, holds static mesh data.",
      "client": true,
      "methods": {
        "1": "buildFromTriangles",
        "2": "destroy",
        "3": "draw",
        "4": "isValid",
        "draw": {
          "client": true,
          "description": "Draws the given mesh."
        },
        "isValid": {
          "ret": "True if the mesh has not yet been destroyed",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Indicates whether this mesh can still be used."
        },
        "buildFromTriangles": {
          "usage": "local OurMesh = Mesh() \nlocal Triangles = { \n\t{ pos = Vector( 0,  0,  0 ), u = 0, v = 0 }, \n\t{ pos = Vector( 10, 0,  0 ), u = 1, v = 0 }, \n\t{ pos = Vector( 10, 10, 0 ), u = 1, v = 1 } \n} \nOurMesh:buildFromTriangles( Triangles )",
          "client": true,
          "description": "Builds the mesh from the given table of triangles.",
          "param": {
            "1": "triangles",
            "triangles": "Table of triangle vertices (see the MeshVertex structure)."
          }
        },
        "destroy": {
          "client": true,
          "description": "Destroys the given mesh. Do not attempt to use it again."
        }
      }
    },
    "Effect": {
      "description": "Effect",
      "server": true,
      "methods": {
        "1": "setAngles",
        "2": "setEntity",
        "3": "setMagnitude",
        "4": "setOrigin",
        "5": "setRadius",
        "6": "setScale",
        "7": "setStart",
        "setScale": {
          "server": true,
          "description": "Sets the scale of the effect data object.",
          "param": {
            "1": "num",
            "num": "Number scale."
          }
        },
        "setEntity": {
          "server": true,
          "description": "Sets the entity of the effect data object.",
          "param": {
            "1": "ent",
            "ent": "Entity to set."
          }
        },
        "setStart": {
          "server": true,
          "description": "Sets the start of the effect data object.",
          "param": {
            "1": "vec",
            "vec": "Vector start."
          }
        },
        "setRadius": {
          "server": true,
          "description": "Sets the radius of the effect data object.",
          "param": {
            "1": "num",
            "num": "Number radius."
          }
        },
        "setAngles": {
          "server": true,
          "description": "Sets the angles of the effect data object.",
          "param": {
            "1": "ang",
            "ang": "Angles to set."
          }
        },
        "setMagnitude": {
          "server": true,
          "description": "Sets the magnitude of the effect data object.",
          "param": {
            "1": "num",
            "num": "Number magnitude."
          }
        },
        "setOrigin": {
          "server": true,
          "description": "Sets the origin of the effect data object.",
          "param": {
            "1": "vec",
            "vec": "Vector origin."
          }
        }
      }
    },
    "Shield": {
      "supertype": "Entity",
      "description": "Atlantis/Starship Shield Emitter",
      "server": true,
      "methods": {
        "1": "addPlayersToWhitelist",
        "2": "divertPower",
        "3": "getFaceCharge",
        "4": "getMaxCharge",
        "5": "getRealTransferRate",
        "6": "getTotalCharge",
        "7": "getTransferRate",
        "8": "getTransferTickInterval",
        "9": "getType",
        "10": "hasFaces",
        "11": "hasWhitelist",
        "12": "isActive",
        "13": "removePlayersFromWhitelist",
        "14": "setActive",
        "getRealTransferRate": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "usage": "-- To compute the current transfer rate per second: \nlocal EnergyPerSecond = Shield:getRealTransferRate() / Shield:getTransferTickInterval()",
          "description": "Returns the current rate energy can be transferred between faces per transfer tick."
        },
        "getTotalCharge": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the current total charge of the shield emitter."
        },
        "getFaceCharge": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the current charge of the given face.",
          "param": {
            "1": "face",
            "face": "The face to check, 1-6 match front, back, left, right, up, down."
          }
        },
        "removePlayersFromWhitelist": {
          "returntypes": [
            "boolean",
            "string"
          ],
          "server": true,
          "usage": "Shield:removePlayersFromWhitelist( { Player1, Player2, Player3 } )",
          "description": "Removes the given list of players from the shield's whitelist.",
          "param": {
            "1": "players",
            "players": "A list of players to be removed."
          }
        },
        "isActive": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the shield is currently active."
        },
        "addPlayersToWhitelist": {
          "returntypes": [
            "boolean",
            "string"
          ],
          "server": true,
          "usage": "Shield:addPlayersToWhitelist( { Player1, Player2, Player3 } )",
          "description": "Adds the given list of players to the shield's whitelist.",
          "param": {
            "1": "players",
            "players": "A list of players to be added."
          }
        },
        "getTransferTickInterval": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the time (in seconds) between shield facing power transfers (the transfer ticks)."
        },
        "setActive": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets whether the shield should be active.",
          "param": {
            "1": "active",
            "active": "Boolean to indicate whether to activate or deactivate the shield."
          }
        },
        "getMaxCharge": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the maximum possible charge of the shield emitter."
        },
        "getType": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the type (number identifier) of the shield emitter."
        },
        "getTransferRate": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "usage": "-- To compute the base transfer rate per second: \nlocal EnergyPerSecond = Shield:getTransferRate() / Shield:getTransferTickInterval()",
          "description": "Returns the maximum base rate energy can be transferred between faces per transfer tick."
        },
        "hasFaces": {
          "ret": "True if the shield has faces.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the shield has faces or not."
        },
        "divertPower": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the face to divert power to.",
          "param": {
            "1": "face",
            "face": "-1 distributes equally, 0 disables diversion, 1-6 match front, back, left, right, up, down."
          }
        },
        "hasWhitelist": {
          "ret": "True if the shield can whitelist players, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Indicates whether the shield can whitelist certain players or not."
        }
      }
    },
    "Stargate": {
      "supertype": "Entity",
      "description": "Stargate",
      "server": true,
      "methods": {
        "1": "accessList",
        "2": "active",
        "3": "address",
        "4": "addressList",
        "5": "asuranBeam",
        "6": "blocked",
        "7": "canDial",
        "8": "chevron",
        "9": "chevrons",
        "10": "close",
        "11": "dhd",
        "12": "dial",
        "13": "gateRing",
        "14": "getSignal",
        "15": "group",
        "16": "inbound",
        "17": "iris",
        "18": "listen",
        "19": "listenForCode",
        "20": "listenForTeleport",
        "21": "localgate",
        "22": "name",
        "23": "open",
        "24": "overloadPercent",
        "25": "overloadTime",
        "26": "overloading",
        "27": "private",
        "28": "setAddress",
        "29": "setBlocked",
        "30": "setGroup",
        "31": "setLocal",
        "32": "setName",
        "33": "setPrivate",
        "34": "setSGC",
        "35": "sgc",
        "36": "stop",
        "37": "stopCodeListen",
        "38": "stopTeleListen",
        "39": "target",
        "40": "transmit",
        "41": "unstable",
        "overloading": {
          "ret": "True if this gate is being overloaded, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether this gate is being overloaded."
        },
        "transmit": {
          "ret": [
            "True if the data was transimitted, false otherwise.",
            "If the data was not transmitted, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Transmits the given string data through this Stargate's connection.",
          "param": {
            "1": "data",
            "data": "String data to send through."
          }
        },
        "setLocal": {
          "ret": [
            "True if the local state was set, false otherwise.",
            "If the local state was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the local state of this Stargate.",
          "param": {
            "1": "local",
            "local": "Boolean local."
          }
        },
        "localgate": {
          "ret": "True if this gate is set to local-only mode. False otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets this gate's local mode state."
        },
        "listen": {
          "server": true,
          "description": "Adds a listener to this gate.",
          "param": {
            "1": "function",
            "function": "Function to run when this gate is dialled."
          }
        },
        "inbound": {
          "ret": "True if this gate currently has an inbound connection, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether this gate has an inbound connection."
        },
        "unstable": {
          "ret": "True if the event horizon is unstable, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether this Stargate's event horizon is currently unstable."
        },
        "target": {
          "ret": "The gate that is connected to this gate (either inbound or outbound).",
          "server": true,
          "returntypes": [
            "Stargate"
          ],
          "description": "Gets the gate connected to this gate."
        },
        "listenForTeleport": {
          "server": true,
          "description": "Adds a teleport listener for this gate.",
          "param": {
            "1": "function",
            "function": "Function to run when an entity teleports to this gate."
          }
        },
        "chevron": {
          "ret": "The currently dialled chevron number (between 0 to 9).",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets this gate's currently dialled chevron number."
        },
        "iris": {
          "ret": "The iris on this gate, if it exists.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Gets the iris on this gate, if it has one."
        },
        "setAddress": {
          "ret": [
            "True if the address was set, false otherwise.",
            "If the address was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the address of this gate.",
          "param": {
            "1": "address",
            "address": "Address to set."
          }
        },
        "name": {
          "ret": "The name of this gate, if it is visible. Otherwise an empty string.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets this gate's name, if it is visible."
        },
        "stopTeleListen": {
          "server": true,
          "description": "Removes a listener for teleporting entities from this gate.",
          "param": {
            "1": "function",
            "function": "Function to remove."
          }
        },
        "listenForCode": {
          "server": true,
          "description": "Adds an iris code listener for this gate.",
          "param": {
            "1": "function",
            "function": "Function to run when the code is received."
          }
        },
        "getSignal": {
          "ret": "The string value for the signal receieved.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets the currently received signal on this gate."
        },
        "gateRing": {
          "ret": "The entity that represents the ring on this gate, if it exists.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Gets the ring entity on SG1, infinity, movie and universe gates."
        },
        "active": {
          "ret": "True if this gate is currently active, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether this gate is active."
        },
        "group": {
          "ret": "This gate's group, if visible. Otherwise an empty string.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets this gate's group, if it is visible."
        },
        "dial": {
          "ret": [
            "True if the gate was dialled, false otherwise.",
            "If the gate was not dialled, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Dials this gate to another.",
          "param": {
            "1": "target",
            "2": "mode",
            "mode": "The mode with which to dial. One of the stargate.DIAL_MODE_* enum values.",
            "target": "String address to dial to."
          }
        },
        "close": {
          "ret": [
            "True if this gate was closed, false otherwise.",
            "If this gate was not closed, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Closes this Stargate."
        },
        "private": {
          "ret": "True if this gate is private (and thus the address/group/name is hidden if not the owner), false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets this gate's private state."
        },
        "chevrons": {
          "ret": "A string containing the currently active chevrons.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets this gate's currently activated chevrons as a string. Emulates the \"Chevrons [STRING]\" output."
        },
        "setSGC": {
          "ret": [
            "True if the SGC mode was set, false otherwise.",
            "If the SGC mode was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the SGC mode of this Stargate.",
          "param": {
            "1": "sgc",
            "sgc": "Boolean SGC mode."
          }
        },
        "asuranBeam": {
          "ret": "True if an Asuran weapon is being fired through this gate, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether an Asuran weapon is firing through this gate."
        },
        "setPrivate": {
          "ret": [
            "True if the private state was set, false otherwise.",
            "If the private state was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the private state of this Stargate.",
          "param": {
            "1": "private",
            "private": "Boolean private."
          }
        },
        "canDial": {
          "ret": [
            "True if it can be dialled, false otherwise.",
            "If the target cannot be dialled, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Gets whether this gate can dial the given target gate.",
          "param": {
            "1": "target",
            "target": "The gate being dialled."
          }
        },
        "overloadPercent": {
          "ret": "A number between 0 and 100 indicating how much this gate has been overloaded.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets the percentage this gate has been overloaded."
        },
        "blocked": {
          "ret": "True if this gate is set to be blocked, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets this gate's blocked state (shows as red in the dialling menu)."
        },
        "addressList": {
          "ret": "A table containing a list of gate addresses that are available to dial.",
          "server": true,
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Gets a list of diallable addresses from this gate."
        },
        "accessList": {
          "ret": [
            "True if the access list is applied.",
            "If the access list is not applied, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Restricts access to this gate to players/Steam IDs in the given list.",
          "param": {
            "1": "list",
            "list": "A table of players and/or Steam IDs to allow. Anyone else is blocked."
          }
        },
        "open": {
          "ret": "True if this gate is open, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets whether this gate is open."
        },
        "stopCodeListen": {
          "server": true,
          "description": "Removes a listener for iris codes from this gate.",
          "param": {
            "1": "function",
            "function": "Function to remove."
          }
        },
        "setBlocked": {
          "ret": [
            "True if the blocked state was set, false otherwise.",
            "If the blocked state was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the blocked state of this Stargate.",
          "param": {
            "1": "blocked",
            "blocked": "Boolean blocked."
          }
        },
        "dhd": {
          "ret": "The DHD associated with this gate, if it exists.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Gets the DHD on this gate if it has one."
        },
        "setName": {
          "ret": [
            "True if the name was set, false otherwise.",
            "If the name was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the name of this Stargate.",
          "param": {
            "1": "name",
            "name": "Name to set."
          }
        },
        "overloadTime": {
          "ret": "The time in seconds until this gate will overload.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets the time remaining before overloading."
        },
        "stop": {
          "server": true,
          "description": "Removes a gate network listener from this gate.",
          "param": {
            "1": "function",
            "function": "Function to remove."
          }
        },
        "address": {
          "ret": "The address of this gate, if it is visible. Otherwise an empty string.",
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Gets this gate's address if it is visible."
        },
        "setGroup": {
          "ret": [
            "True if the group was set, false otherwise.",
            "If the group was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the group of this Stargate.",
          "param": {
            "1": "group",
            "group": "Group to set."
          }
        },
        "sgc": {
          "ret": "True if this gate is set to use SGC dialling mode, false otherwise.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Gets this gate's SGC mode state (applicable to milky-way gates only)."
        }
      }
    },
    "Vehicle": {
      "supertype": "Entity",
      "description": "Vehicle",
      "methods": {
        "1": "boostTimeLeft",
        "2": "cameraDistance",
        "3": "driver",
        "4": "getHLSpeed",
        "5": "getMaxSpeed",
        "6": "getPassengerSeatPoint",
        "7": "getRPM",
        "8": "getSpeed",
        "9": "getSteering",
        "10": "getSteeringDegrees",
        "11": "getThrottle",
        "12": "getVehicleViewPosition",
        "13": "getWheel",
        "14": "getWheelContactPoint",
        "15": "getWheelCount",
        "16": "hasBoost",
        "17": "hasBrakePedal",
        "18": "isEngineEnabled",
        "19": "isEngineStarted",
        "20": "isVehicleBodyInWater",
        "21": "passenger",
        "22": "thirdPersonMode",
        "thirdPersonMode": {
          "ret": "True if in third person.",
          "description": "Returns whether the vehicle is in third person mode.",
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "client": true
        },
        "getSpeed": {
          "ret": "Current speed in miles per hour.",
          "description": "Returns the current speed of the vehicle in miles per hour.",
          "server": true,
          "returntypes": [
            "number"
          ]
        },
        "hasBoost": {
          "ret": "True if the vehicle can boost, false otherwise.",
          "description": "Gets whether the vehicle has boost functionality.",
          "server": true,
          "returntypes": [
            "boolean"
          ]
        },
        "getWheel": {
          "ret": "The physics object for the given wheel, if it exists.",
          "description": "Gets the physics object of the given wheel.",
          "server": true,
          "returntypes": [
            "PhysObj"
          ]
        },
        "getWheelContactPoint": {
          "ret": [
            "Contact position",
            "Surface properties",
            "Indicates if it's on the ground."
          ],
          "description": "Returns the wheel contact point.",
          "server": true,
          "returntypes": [
            "Vector",
            "number",
            "boolean"
          ],
          "param": {
            "1": "wheel",
            "wheel": "Number indicating which wheel to check."
          }
        },
        "getSteering": {
          "ret": "Steering value.",
          "description": "Returns the current steering of the vehicle.",
          "server": true,
          "returntypes": [
            "number"
          ]
        },
        "isVehicleBodyInWater": {
          "ret": "True if in water, false otherwise.",
          "description": "Returns whether the vehicle is in water.",
          "server": true,
          "returntypes": [
            "boolean"
          ]
        },
        "boostTimeLeft": {
          "ret": "Time left for boosting.",
          "description": "Gets the amount of time remaining in the vehicle's boost.",
          "server": true,
          "returntypes": [
            "number"
          ]
        },
        "passenger": {
          "ret": "Passenger player or nil.",
          "server": true,
          "returntypes": [
            "Player"
          ],
          "description": "Returns the passenger of the given vehicle.",
          "param": {
            "1": "num",
            "num": "The passenger to get. Starts at 0."
          }
        },
        "getVehicleViewPosition": {
          "ret": [
            "View position",
            "View angles",
            "Field of view."
          ],
          "description": "Returns the view position of a given passenger.",
          "server": true,
          "returntypes": [
            "Vector",
            "Angle",
            "number"
          ],
          "param": {
            "1": "num",
            "num": "The passenger to get, 1 is the driver."
          }
        },
        "getSteeringDegrees": {
          "ret": "Steering degrees.",
          "description": "Returns the current steering in degrees.",
          "server": true,
          "returntypes": [
            "number"
          ]
        },
        "isEngineEnabled": {
          "ret": "Boolean true if the vehicle's engine can be started, false otherwise.",
          "description": "Gets whether the vehicle's engine can be started.",
          "server": true,
          "returntypes": [
            "boolean"
          ]
        },
        "cameraDistance": {
          "ret": "Distance of the camera.",
          "description": "Returns the distance of the camera from the vehicle.",
          "server": true,
          "returntypes": [
            "number"
          ],
          "client": true
        },
        "getWheelCount": {
          "ret": "Number of wheels the vehicle has.",
          "description": "Returns the number of wheels the vehicle has.",
          "server": true,
          "returntypes": [
            "number"
          ]
        },
        "getThrottle": {
          "ret": "Current throttle value.",
          "description": "Gets the current throttle value.",
          "server": true,
          "returntypes": [
            "number"
          ]
        },
        "driver": {
          "ret": "Driver player or nil.",
          "description": "Returns the driver of the given vehicle.",
          "server": true,
          "returntypes": [
            "Player"
          ]
        },
        "isEngineStarted": {
          "ret": "True if the vehicle's engine is started, false otherwise.",
          "description": "Gets whether the vehicle's engine is started.",
          "server": true,
          "returntypes": [
            "boolean"
          ]
        },
        "getMaxSpeed": {
          "ret": "Maximum speed in miles per hour.",
          "description": "Returns the maximum speed of the vehicle in miles per hour.",
          "server": true,
          "returntypes": [
            "number"
          ]
        },
        "hasBrakePedal": {
          "ret": "True if the vehicle has a break pedal, false otherwise.",
          "description": "Gets whether the vehicle has a break pedal.",
          "server": true,
          "returntypes": [
            "boolean"
          ]
        },
        "getRPM": {
          "ret": "RPM.",
          "description": "Returns the vehicle's RPM value. This may not be accurate due to the way vehicles operate internally.",
          "server": true,
          "returntypes": [
            "number"
          ]
        },
        "getHLSpeed": {
          "ret": "Speed value, the length of the velocity vector.",
          "description": "Returns the vehicle's current speed in Hammer units.",
          "server": true,
          "returntypes": [
            "number"
          ]
        },
        "getPassengerSeatPoint": {
          "ret": [
            "Position",
            "Seat angles."
          ],
          "description": "Returns the position and angles of a passenger seat.",
          "server": true,
          "returntypes": [
            "Vector",
            "Angle"
          ],
          "param": {
            "1": "num",
            "num": "The passenger to get, 1 is the driver."
          }
        }
      }
    },
    "Wirelink": {
      "description": "Wirelink",
      "server": true,
      "methods": {
        "1": "addOutputCallback",
        "2": "entity",
        "3": "getWiredTo",
        "4": "getWiredToName",
        "5": "inputType",
        "6": "inputs",
        "7": "isValid",
        "8": "isWired",
        "9": "outputType",
        "10": "outputs",
        "11": "removeOutputCallback",
        "isValid": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Checks if a wirelink is valid. (ie. doesn't point to an invalid entity)"
        },
        "outputType": {
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Returns the type of output name, or nil if it doesn't exist",
          "param": [
            "name"
          ]
        },
        "addOutputCallback": {
          "returntypes": [
            "boolean",
            "string"
          ],
          "server": true,
          "usage": "Wirelink:addOutputCallback( \"MyAwesomeCallback\", function( Wirelink, Output, Value ) \n\tprint( Wirelink, Output, Value ) \nend )",
          "description": "Adds an output change callback to the wirelink. This is called whenever an output changes. \nIt is passed the wirelink, output name and new output value.",
          "param": {
            "1": "id",
            "2": "callback",
            "callback": "The function to run when an output changes.",
            "id": "Identifier, used to remove it later if you need to."
          }
        },
        "getWiredTo": {
          "ret": "The entity wired to the given input, if the input exists and is wired. Otherwise nil.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Returns the entity the given input is wired to.",
          "param": {
            "1": "inputName",
            "inputName": "The name of the input to get the entity for."
          }
        },
        "removeOutputCallback": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Removes an output change callback you registered.",
          "param": {
            "1": "id",
            "id": "The ID you used to register it."
          }
        },
        "inputType": {
          "server": true,
          "returntypes": [
            "string"
          ],
          "description": "Returns the type of input name, or nil if it doesn't exist",
          "param": [
            "name"
          ]
        },
        "isWired": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Checks if an input is wired.",
          "param": [
            "name"
          ]
        },
        "entity": {
          "server": true,
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the entity that the wirelink represents"
        },
        "getWiredToName": {
          "ret": "The name of the output the given input is wired to, if the input exists and is wired. Otherwise nil.",
          "server": true,
          "returntypes": [
            [
              "string",
              "nil"
            ]
          ],
          "description": "Returns the name of the output the given input is wired to.",
          "param": {
            "1": "inputName",
            "inputName": "the name of the input to get the output name for."
          }
        },
        "inputs": {
          "server": true,
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Returns a table of all of the wirelink's inputs"
        },
        "outputs": {
          "server": true,
          "returntypes": [
            "table<number,string>"
          ],
          "description": "Returns a table of all of the wirelink's outputs"
        }
      }
    },
    "ShipCore": {
      "supertype": "Entity",
      "description": "Ship Core",
      "server": true,
      "methods": {
        "1": "addTarget",
        "2": "enableEmitters",
        "3": "fireRepairBeam",
        "4": "getShield",
        "5": "getShipSize",
        "6": "isTarget",
        "7": "platingStrength",
        "8": "removeTarget",
        "9": "selfDestruct",
        "10": "setEnvironmentSound",
        "11": "setRepairTarget",
        "12": "stopEnvironmentSound",
        "getShipSize": {
          "ret": [
            "Mins vector (local to the shield emitter).",
            "Maxs vector (local to the shield emitter)."
          ],
          "server": true,
          "returntypes": [
            "Vector",
            "Vector"
          ],
          "description": "Gets the mins and maxs of the ship in co-ordinates local to the core's shield emitter. \nMake sure the core has a starship or Atlantis shield, or it will return 0,0,0."
        },
        "enableEmitters": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Enables or disables any pulsar emitters under control of the given core.",
          "param": {
            "1": "bool",
            "bool": "Boolean enable."
          }
        },
        "removeTarget": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Removes a target Steam ID to the given ship core.",
          "param": {
            "1": "steamID",
            "steamID": "The Steam ID to remove."
          }
        },
        "setRepairTarget": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the repair beam target.",
          "param": {
            "1": "target",
            "target": "Entity to repair."
          }
        },
        "stopEnvironmentSound": {
          "server": true,
          "description": "Stops any environment sound that was playing."
        },
        "addTarget": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Adds a target Steam ID to the given ship core.",
          "param": {
            "1": "steamID",
            "steamID": "The Steam ID to add."
          }
        },
        "setEnvironmentSound": {
          "server": true,
          "description": "Sets a sound that will play to the LS core environment assigned to the ship core.",
          "param": {
            "1": "soundPath",
            "2": "volume",
            "3": "pitch",
            "soundPath": "The path to the sound to play.",
            "pitch": "(Optional) The pitch of the sound, between 0 and 255. Defaults to 100.",
            "volume": "(Optional) The volume of the sound, between 0 and 1. Defaults to 1."
          }
        },
        "isTarget": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Returns whether the given Steam ID is a target.",
          "param": {
            "1": "steamID",
            "steamID": "The Steam ID to check."
          }
        },
        "selfDestruct": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Triggers the ship core's self destruct. There's no going back."
        },
        "fireRepairBeam": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the repair beam to fire or not.",
          "param": {
            "1": "fire",
            "fire": "Should the repair beam fire?"
          }
        },
        "getShield": {
          "ret": "The starship or Atlantis shield assigned to the ship core.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "Shield"
            ]
          ],
          "description": "Gets the shield assigned to the ship core."
        },
        "platingStrength": {
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Returns the current strength of the ship core's plating."
        }
      }
    },
    "Player": {
      "supertype": "Entity",
      "description": "Player",
      "methods": {
        "1": "accountID",
        "2": "activeWeapon",
        "3": "aimEntity",
        "4": "aimPos",
        "5": "aimVector",
        "6": "alive",
        "7": "armor",
        "8": "crouching",
        "9": "deaths",
        "10": "eyeTrace",
        "11": "flashlightIsOn",
        "12": "fov",
        "13": "frags",
        "14": "getAmmoCount",
        "15": "getEntityInUse",
        "16": "getFriendStatus",
        "17": "getShuttle",
        "18": "getTeamColor",
        "19": "getUserGroup",
        "20": "getViewEntity",
        "21": "hasDamageEnabled",
        "22": "hasPlayerDamageEnabled",
        "23": "health",
        "24": "inShuttle",
        "25": "inVehicle",
        "26": "isAdmin",
        "27": "isBot",
        "28": "isConnected",
        "29": "isFrozen",
        "30": "isMuted",
        "31": "isSprinting",
        "32": "isSuperAdmin",
        "33": "isUserGroup",
        "34": "jumpPower",
        "35": "keyDown",
        "36": "keyReleased",
        "37": "maxArmor",
        "38": "maxHealth",
        "39": "maxSpeed",
        "40": "name",
        "41": "nick",
        "42": "ping",
        "43": "runSpeed",
        "44": "setVelocity",
        "45": "shootPos",
        "46": "steamID",
        "47": "steamID64",
        "48": "team",
        "49": "teamName",
        "50": "uniqueID",
        "51": "userID",
        "52": "vehicle",
        "isUserGroup": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the player is in the given user group.",
          "param": [
            "group"
          ]
        },
        "nick": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the player's name."
        },
        "isBot": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the player is a bot."
        },
        "aimPos": {
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the position the player is looking at."
        },
        "userID": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's user ID."
        },
        "inVehicle": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the player is in a vehicle."
        },
        "armor": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's armour."
        },
        "keyReleased": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the player has released the given key.",
          "param": {
            "1": "key",
            "key": "input.IN_ enum."
          }
        },
        "keyDown": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the player is holding the given key down.",
          "param": {
            "1": "key",
            "key": "input.IN_ enum."
          }
        },
        "ping": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's ping."
        },
        "setVelocity": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets a player's velocity.",
          "param": {
            "1": "velocity",
            "velocity": "The new (world) velocity vector."
          }
        },
        "aimEntity": {
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the entity the player is looking at."
        },
        "steamID": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the player's Steam ID."
        },
        "getViewEntity": {
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the current view entity of the given player."
        },
        "maxSpeed": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's max speed."
        },
        "activeWeapon": {
          "returntypes": [
            "Weapon"
          ],
          "description": "Returns the player's active weapon."
        },
        "inShuttle": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the player is seated in a shuttle, false otherwise."
        },
        "getUserGroup": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the player's user group."
        },
        "maxArmor": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's maximum armour."
        },
        "getTeamColor": {
          "returntypes": [
            "Color"
          ],
          "description": "Returns the player's team colour."
        },
        "hasDamageEnabled": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given player is opted into prop damage."
        },
        "crouching": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the player is crouching."
        },
        "name": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the player's name."
        },
        "runSpeed": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's run speed."
        },
        "getShuttle": {
          "server": true,
          "returntypes": [
            [
              "Shuttle",
              "nil"
            ]
          ],
          "description": "Returns the shuttle the player is currently seated in."
        },
        "eyeTrace": {
          "returntypes": [
            "TraceResult"
          ],
          "description": "Returns an eye trace from the player ignoring the cursor position."
        },
        "getAmmoCount": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the amount of ammo the player currently has of the given type.",
          "param": {
            "1": "ammoType",
            "ammoType": "The type of ammo, get this from Weapon:getPrimaryAmmoType()/Weapon:getSecondaryAmmoType()."
          }
        },
        "vehicle": {
          "returntypes": [
            "Vehicle"
          ],
          "description": "Returns the vehicle the player is in if applicable."
        },
        "isAdmin": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the player is an admin."
        },
        "isSuperAdmin": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the player is a super admin."
        },
        "alive": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the player is alive."
        },
        "getEntityInUse": {
          "ret": "The entity currently being used by the given player.",
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the entity the player is currently using (e.g. a picked up prop)."
        },
        "shootPos": {
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the player's shoot position."
        },
        "flashlightIsOn": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the player's flashlight is on."
        },
        "isMuted": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the player is muted for the client running this function."
        },
        "getFriendStatus": {
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Returns the friend status code for the client running this function."
        },
        "uniqueID": {
          "deprecated": "This value should not be used as it is not truly unique. Use the player's Steam ID where possible.",
          "returntypes": [
            "string"
          ],
          "description": "Returns the player's unique ID."
        },
        "deaths": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's deaths count."
        },
        "teamName": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the player's team name."
        },
        "isSprinting": {
          "ret": "True if the player is sprinting, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the player is sprinting."
        },
        "team": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's team ID."
        },
        "accountID": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's account ID (SteamID3) as an integer."
        },
        "steamID64": {
          "returntypes": [
            "string"
          ],
          "description": "Returns the player's 64 bit Steam ID."
        },
        "hasPlayerDamageEnabled": {
          "server": true,
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given player is opted into player damage."
        },
        "frags": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's frag count."
        },
        "aimVector": {
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the player's aim vector."
        },
        "health": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's health."
        },
        "fov": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's FOV."
        },
        "isFrozen": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the player is frozen."
        },
        "isConnected": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the player is connected."
        },
        "maxHealth": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's max health."
        },
        "jumpPower": {
          "returntypes": [
            "number"
          ],
          "description": "Returns the player's jump power."
        }
      }
    },
    "PhysObj": {
      "description": "PhysObj",
      "methods": {
        "1": "addAngleVelocity",
        "2": "applyForceCenter",
        "3": "applyForceOffset",
        "4": "applyTorqueCenter",
        "5": "enableCollisions",
        "6": "enableDrag",
        "7": "enableGravity",
        "8": "enableMotion",
        "9": "getAngleVelocity",
        "10": "getAngles",
        "11": "getContents",
        "12": "getDamping",
        "13": "getEnergy",
        "14": "getEntity",
        "15": "getInertia",
        "16": "getInvInertia",
        "17": "getInvMass",
        "18": "getMass",
        "19": "getMassCenter",
        "20": "getMaterial",
        "21": "getPos",
        "22": "getPositionMatrix",
        "23": "getRotDamping",
        "24": "getSpeedDamping",
        "25": "getStress",
        "26": "getSurfaceArea",
        "27": "getVelocity",
        "28": "getVelocityAtPoint",
        "29": "getVolume",
        "30": "isAsleep",
        "31": "isCollisionEnabled",
        "32": "isDragEnabled",
        "33": "isGravityEnabled",
        "34": "isMotionEnabled",
        "35": "isMoveable",
        "36": "isPenetrating",
        "37": "isValid",
        "38": "localToWorld",
        "39": "setMass",
        "40": "setVelocity",
        "41": "worldToLocal",
        "localToWorld": {
          "ret": "Translated and rotated vector.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the input vector transformed from local space to world space.",
          "param": [
            "vec"
          ]
        },
        "getAngles": {
          "ret": "Angle object.",
          "returntypes": [
            "Angle"
          ],
          "description": "Returns the angles of the physics object."
        },
        "applyForceOffset": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Applies force to the physics object from the given offset position.",
          "param": {
            "1": "force",
            "2": "offset",
            "offset": "Position in world space to apply from.",
            "force": "Force vector to apply."
          }
        },
        "applyTorqueCenter": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Applies torque to the centre of the physics object.",
          "param": {
            "1": "torque",
            "torque": "The torque vector (where the direction is in world space and the magnitude's units are kg * degrees / s)."
          }
        },
        "isPenetrating": {
          "ret": "True if intersecting, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the physics object is intersecting another or not."
        },
        "getDamping": {
          "ret": "Linear damping, angular damping.",
          "returntypes": [
            "number",
            "number"
          ],
          "description": "Returns damping values on the physics object."
        },
        "getContents": {
          "ret": "The contents flags applied to this physics object (see trace.CONTENTS_*).",
          "returntypes": [
            "number"
          ],
          "description": "Returns the contents of the physics object."
        },
        "isValid": {
          "ret": "True if the physics object is valid, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the physics object is valid. \nNote that trying to use an invalid physics object will throw an error."
        },
        "getVelocityAtPoint": {
          "ret": "The velocity at the given point.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the velocity in the object's local space at a specific point.",
          "param": {
            "1": "point",
            "point": "The point (in world space) to get the velocity at."
          }
        },
        "isAsleep": {
          "ret": "True if sleeping, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the physics object is \"sleeping\", that is, not being simulated."
        },
        "enableCollisions": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Enables or disables collisions on the physics object.",
          "param": {
            "1": "enable",
            "enable": "Boolean flag whether to enable."
          }
        },
        "enableMotion": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Enables or disables motion on the physics object.",
          "param": {
            "1": "enable",
            "enable": "Boolean flag whether to enable."
          }
        },
        "getAngleVelocity": {
          "ret": "Angular velocity *VECTOR*.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the angular velocity of the physics object."
        },
        "isMoveable": {
          "ret": "True if moveable, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the physics object is moveable or not."
        },
        "getVelocity": {
          "ret": "Velocity vector.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the velocity of the physics object."
        },
        "getVolume": {
          "ret": "Volume value.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the total volume of the physics object in units^3."
        },
        "getRotDamping": {
          "ret": "Rotation damping value.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the rotation damping value of the physics object."
        },
        "getSpeedDamping": {
          "ret": "Speed damping value.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the speed damping value of the physics object."
        },
        "getMass": {
          "ret": "Mass value.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the mass of the physics object."
        },
        "isCollisionEnabled": {
          "ret": "True if collisions are enabled, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the physics object has collisions enabled."
        },
        "isGravityEnabled": {
          "ret": "True if gravity is enabled, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the physics object has gravity enabled."
        },
        "isMotionEnabled": {
          "ret": "True if motion is enabled, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the physics object has motion enabled, i.e whether it is not frozen."
        },
        "getInvInertia": {
          "ret": "Inverse inertia vector.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns 1 / the inertia of the physics object."
        },
        "getInertia": {
          "ret": "Vector inertia.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the inertia of the physics object."
        },
        "setVelocity": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the linear velocity of the physics object.",
          "param": {
            "1": "velocity",
            "velocity": "Velocity vector in world space."
          }
        },
        "applyForceCenter": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Applies force to the centre of the physics object.",
          "param": {
            "1": "force",
            "force": "Force vector to apply."
          }
        },
        "addAngleVelocity": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Adds the given angular velocity value to the current angular velocity. Each component applies the given magnitude \nto the entity's corresponding local axis, e.g. a value of Vector( 0, 0, 50 ) applies an angular velocity to rotate \nthe entity around its up direction by 50 units/s.",
          "param": {
            "1": "angularVelocity",
            "angularVelocity": "The angular velocity to add."
          }
        },
        "getMaterial": {
          "ret": "String material type. NOT the same as Entity:getMaterial().",
          "returntypes": [
            "string"
          ],
          "description": "Returns the type of material the physics object represents, e.g \"wood\", \"metal\"."
        },
        "getEntity": {
          "ret": "The entity this physics object belongs to.",
          "returntypes": [
            "Entity"
          ],
          "description": "Returns the entity this physics object belongs to."
        },
        "enableDrag": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Enables or disables drag on the physics object.",
          "param": {
            "1": "enable",
            "enable": "Boolean flag whether to enable."
          }
        },
        "getPos": {
          "ret": "Position vector.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the position of the physics object."
        },
        "enableGravity": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Enables or disables gravity on the physics object.",
          "param": {
            "1": "enable",
            "enable": "Boolean flag whether to enable."
          }
        },
        "getMassCenter": {
          "ret": "Vector mass centre position in local space.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the mass centre of the physics object in local space."
        },
        "getStress": {
          "ret": "Stress value.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the stress being exerted on the physics object as a number value."
        },
        "getPositionMatrix": {
          "ret": "The physics object's world transform as a matrix.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Returns the physics object's world transform matrix. \nThe first 3 columns are a rotation matrix representing the physics object's angles, and the last column is its position."
        },
        "getSurfaceArea": {
          "ret": "Surface area value.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the total surface area of the physics object in units^2."
        },
        "setMass": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the mass of the physics object. Mass cannot exceed 50,000.",
          "param": {
            "1": "mass",
            "mass": "The new mass to give the physics object, in kilograms."
          }
        },
        "getInvMass": {
          "ret": "Inverse mass.",
          "returntypes": [
            "number"
          ],
          "description": "Returns 1 / the physics object's mass."
        },
        "worldToLocal": {
          "ret": "Translated and rotated vector.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the input vector transformed from world space to local space.",
          "param": [
            "vec"
          ]
        },
        "isDragEnabled": {
          "ret": "True if drag is enabled, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the physics object has drag enabled."
        },
        "getEnergy": {
          "ret": "Kinetic energy value.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the kinetic energy of the physics object."
        }
      }
    },
    "VMatrix": {
      "operators": {
        "1": "mul_VMatrix_VMatrix",
        "2": "mul_VMatrix_Vector",
        "3": "add_VMatrix_VMatrix",
        "4": "sub_VMatrix_VMatrix",
        "5": "eq_VMatrix_VMatrix",
        "sub_VMatrix_VMatrix": {
          "ret": "A new matrix whose components are the left matrix minus the right matrix.",
          "description": "Subtracts component values of the right matrix from those in the left matrix.",
          "lhs": "VMatrix",
          "returntypes": [
            "VMatrix"
          ],
          "rhs": "VMatrix"
        },
        "eq_VMatrix_VMatrix": {
          "ret": "True if the 2 matrices have the same component values, false otherwise.",
          "description": "Determines if the given matrices are equal by checking each component.",
          "lhs": "VMatrix",
          "returntypes": [
            "boolean"
          ],
          "rhs": "VMatrix"
        },
        "mul_VMatrix_VMatrix": {
          "ret": "A new matrix that is the result of the matrix product.",
          "description": "Multiplies a matrix by another matrix.",
          "lhs": "VMatrix",
          "returntypes": [
            "VMatrix"
          ],
          "rhs": "VMatrix"
        },
        "mul_VMatrix_Vector": {
          "ret": "A new vector that is the result of the matrix by column vector multiplication.",
          "description": "Multiplies a vector by a matrix.",
          "lhs": "VMatrix",
          "returntypes": [
            "Vector"
          ],
          "rhs": "Vector",
          "commutative": false
        },
        "add_VMatrix_VMatrix": {
          "ret": "A new matrix whose components are the sum of the components of the 2 matrices.",
          "description": "Adds the values of 2 matrices component-wise.",
          "lhs": "VMatrix",
          "returntypes": [
            "VMatrix"
          ],
          "rhs": "VMatrix"
        }
      },
      "description": "VMatrix",
      "methods": {
        "1": "getAngles",
        "2": "getField",
        "3": "getForward",
        "4": "getInverse",
        "5": "getInverseTR",
        "6": "getRight",
        "7": "getScale",
        "8": "getTranslation",
        "9": "getUp",
        "10": "identity",
        "11": "invert",
        "12": "invertTR",
        "13": "isIdentity",
        "14": "isRotationMatrix",
        "15": "rotate",
        "16": "scale",
        "17": "scaleTranslation",
        "18": "set",
        "19": "setAngles",
        "20": "setField",
        "21": "setForward",
        "22": "setRight",
        "23": "setScale",
        "24": "setTranslation",
        "25": "setUnpacked",
        "26": "setUp",
        "27": "toTable",
        "28": "translate",
        "29": "unpack",
        "setUnpacked": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Sets the values of all fields in the matrix.",
          "param": {
            "1": "row1Column1",
            "2": "row1Column2",
            "3": "row1Column3",
            "4": "row1Column4",
            "5": "row2Column1",
            "6": "row2Column2",
            "7": "row2Column3",
            "8": "row2Column4",
            "9": "row3Column1",
            "10": "row3Column2",
            "11": "row3Column3",
            "12": "row3Column4",
            "13": "row4Column1",
            "14": "row4Column2",
            "15": "row4Column3",
            "16": "row4Column4",
            "row4Column4": "The value for row 4, column 4",
            "row4Column3": "The value for row 4, column 3",
            "row4Column2": "The value for row 4, column 2",
            "row4Column1": "The value for row 4, column 1",
            "row3Column4": "The value for row 3, column 4",
            "row3Column3": "The value for row 3, column 3",
            "row3Column2": "The value for row 3, column 2",
            "row3Column1": "The value for row 3, column 1",
            "row2Column4": "The value for row 2, column 4",
            "row2Column3": "The value for row 2, column 3",
            "row2Column2": "The value for row 2, column 2",
            "row2Column1": "The value for row 2, column 1",
            "row1Column4": "The value for row 1, column 4",
            "row1Column3": "The value for row 1, column 3",
            "row1Column2": "The value for row 1, column 2",
            "row1Column1": "The value for row 1, column 1"
          }
        },
        "getRight": {
          "ret": "A vector representing the right direction.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the right direction of the matrix. \nThis is the second column of the matrix excluding the 4th component."
        },
        "getUp": {
          "ret": "A vector representing the up direction.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the up direction of the matrix. \nThis is the third column of the matrix excluding the 4th component."
        },
        "scale": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Scales the matrix",
          "param": {
            "1": "vec",
            "vec": "Vector to scale by"
          }
        },
        "getScale": {
          "ret": "Scale",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the matrix's scale"
        },
        "identity": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Resets the matrix's values to the identity matrix. \nModifies the given matrix directly."
        },
        "getAngles": {
          "ret": "Angles",
          "returntypes": [
            "Angle"
          ],
          "description": "Returns the matrix's angles"
        },
        "isIdentity": {
          "ret": "True if the matrix is the identity matrix, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given matrix is the identity matrix."
        },
        "unpack": {
          "ret": [
            "Row 1, column 1",
            "Row 1, column 2",
            "Row 1, column 3",
            "Row 1, column 4",
            "Row 2, column 1",
            "Row 2, column 2",
            "Row 2, column 3",
            "Row 2, column 4",
            "Row 3, column 1",
            "Row 3, column 2",
            "Row 3, column 3",
            "Row 3, column 4",
            "Row 4, column 1",
            "Row 4, column 2",
            "Row 4, column 3",
            "Row 4, column 4"
          ],
          "returntypes": [
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number"
          ],
          "description": "Returns all fields in the matrix."
        },
        "setAngles": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Sets the angles",
          "param": {
            "1": "ang",
            "ang": "New angles"
          }
        },
        "setField": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Sets the value at the given row and column.",
          "param": {
            "1": "row",
            "2": "column",
            "3": "value",
            "value": "The value to set.",
            "column": "The column to change the value of.",
            "row": "The row to change the value of."
          }
        },
        "invert": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Inverts the given matrix directly, does not return anything. \nThis operation will fail for matrices with determinant close to or equal to 0. If it does fail, the matrix is not modified."
        },
        "scaleTranslation": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Scales the absolute translation",
          "param": {
            "1": "num",
            "num": "Amount to scale by"
          }
        },
        "translate": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Translates the matrix",
          "param": {
            "1": "vec",
            "vec": "Vector to translate by"
          }
        },
        "getField": {
          "ret": "The number value at the given row and column.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the value in the given row and column. There are 4 rows and 4 columns.",
          "param": {
            "1": "row",
            "2": "column",
            "column": "The column to retrieve the value from.",
            "row": "The row to retrieve the value from."
          }
        },
        "setTranslation": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Sets the translation",
          "param": {
            "1": "vec",
            "vec": "New translation"
          }
        },
        "set": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Copies the values from the given matrix object to self.",
          "param": {
            "1": "matrix",
            "matrix": "The matrix to copy values from."
          }
        },
        "isRotationMatrix": {
          "returntypes": [
            "boolean"
          ],
          "description": "Returns whether the given matrix is a \"rotation matrix\". \nThis checks whether the forward, right and up directions are orthogonal and normalised to 1."
        },
        "setRight": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Sets the right direction of the matrix. \nThis changes the first 3 values in the second column of the matrix.",
          "param": {
            "1": "vec",
            "vec": "The right direction vector."
          }
        },
        "setScale": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Sets the scale of the matrix.",
          "param": {
            "1": "vec",
            "vec": "The new scale."
          }
        },
        "setForward": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Sets the forward direction of the matrix. \nThis changes the first 3 values in the first column of the matrix.",
          "param": {
            "1": "vec",
            "vec": "The forward direction vector."
          }
        },
        "invertTR": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Inverts the given matrix directly, does not return anything. \nThis function will not fail, but only works correctly on matrices that contain only translation and/or rotation."
        },
        "getTranslation": {
          "ret": "Translation",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the matrix's translation"
        },
        "toTable": {
          "ret": "Table containing 4 tables representing the rows of the matrix.",
          "returntypes": [
            "table<number,table<number,number>>"
          ],
          "description": "Returns a 4x4 table representing the values of the matrix."
        },
        "getForward": {
          "ret": "A vector representing the forward direction.",
          "returntypes": [
            "Vector"
          ],
          "description": "Returns the forward direction of the matrix. \nThis is the first column of the matrix excluding the 4th component."
        },
        "getInverse": {
          "ret": "The matrix representing the inverse of the given matrix.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Returns the inverse matrix of the given matrix. \nThis operation will fail for matrices with determinant close to or equal to 0."
        },
        "rotate": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Rotates the matrix",
          "param": {
            "1": "ang",
            "ang": "Angle to rotate by"
          }
        },
        "getInverseTR": {
          "ret": "The matrix representing the inverse of the given matrix, assumming the matrix was not scaled.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Returns the inverse matrix of the given matrix. \nThis function will not fail, but only works correctly on matrices that contain only translation and/or rotation."
        },
        "setUp": {
          "ret": "The matrix itself.",
          "returntypes": [
            "VMatrix"
          ],
          "description": "Sets the up direction of the matrix. \nThis changes the first 3 values in the third column of the matrix.",
          "param": {
            "1": "vec",
            "vec": "The up direction vector."
          }
        }
      }
    },
    "NPC": {
      "supertype": "Entity",
      "description": "NPC",
      "server": true,
      "methods": {
        "1": "facePos",
        "2": "getBlockingEntity",
        "3": "getDisposition",
        "4": "getTarget",
        "5": "giveWeapon",
        "6": "kill",
        "7": "meleeAttack",
        "8": "runTo",
        "9": "setCurrentWeaponProficiency",
        "10": "setRelationship",
        "11": "setTarget",
        "12": "shoot",
        "13": "stop",
        "14": "walkTo",
        "facePos": {
          "ret": [
            "True if the NPC was rotated, false otherwise.",
            "If the NPC was not rotated, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Makes the NPC face the given position.",
          "param": {
            "1": "pos",
            "pos": "Position to face towards."
          }
        },
        "kill": {
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Kills the NPC."
        },
        "meleeAttack": {
          "ret": [
            "True if the NPC was set to melee attack, false otherwise.",
            "If the NPC was not set to melee attack, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Makes the NPC perform their melee attack once."
        },
        "setRelationship": {
          "ret": [
            "True if the relationship was set, false otherwise.",
            "If the relationship was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the NPC's relationship with the given target.",
          "param": {
            "1": "target",
            "2": "disposition",
            "3": "priority",
            "priority": "Weighting, up to 99.",
            "disposition": "One of the npc.D_* enum values.",
            "target": "The target entity."
          }
        },
        "getBlockingEntity": {
          "ret": "The entity blocking the NPC from moving, if there is one.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Returns the entity currently blocking the NPC."
        },
        "setTarget": {
          "ret": [
            "True if the target was set, false otherwise.",
            "If the target was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the NPC's enemy target.",
          "param": {
            "1": "target",
            "target": "The target entity."
          }
        },
        "shoot": {
          "ret": [
            "True if the NPC was set to fire, false otherwise.",
            "If the NPC was not set to fire, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Makes the NPC shoot their weapon once."
        },
        "setCurrentWeaponProficiency": {
          "ret": [
            "True if the proficiency was set.",
            "If the proficiency was not set, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Sets the NPC's current weapon proficiency.",
          "param": {
            "1": "proficiency",
            "proficiency": "The proficiency level to set (one of npc.WEAPON_PROFICIENCY_*)."
          }
        },
        "stop": {
          "ret": [
            "True if the NPC was stopped, false otherwise.",
            "If the NPC was not stopped, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Stops what the NPC is doing."
        },
        "giveWeapon": {
          "ret": [
            "True if the weapon was given, false otherwise.",
            "If the weapon was not given, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Gives the NPC the given weapon",
          "param": {
            "1": "class",
            "class": "Classname without weapon_, so smg1, ar2 etc."
          }
        },
        "getDisposition": {
          "ret": "The disposition the NPC has towards the target (one of the npc.D_* enum values.)",
          "server": true,
          "returntypes": [
            "number"
          ],
          "description": "Gets the disposition the NPC has towards the target.",
          "param": {
            "1": "target",
            "target": "The target entity."
          }
        },
        "getTarget": {
          "ret": "The entity the NPC is currently targeting, or nil if they are not targeting anyone.",
          "server": true,
          "returntypes": [
            [
              "Entity",
              "nil"
            ]
          ],
          "description": "Returns the NPC's current enemy target."
        },
        "runTo": {
          "ret": [
            "True if the NPC was set to run, false otherwise.",
            "If the NPC was not set to run, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Makes the NPC run to the given position.",
          "param": {
            "1": "vec",
            "vec": "Position vector."
          }
        },
        "walkTo": {
          "ret": [
            "True if the NPC was set to walk, false otherwise.",
            "If the NPC was not set to walk, the reason why."
          ],
          "server": true,
          "returntypes": [
            "boolean",
            "string"
          ],
          "description": "Makes the NPC walk to the given position.",
          "param": {
            "1": "vec",
            "vec": "Position vector."
          }
        }
      }
    },
    "File": {
      "description": "File",
      "methods": {
        "1": "close",
        "2": "flush",
        "3": "lines",
        "4": "read",
        "5": "seek",
        "6": "setvbuf",
        "7": "write",
        "setvbuf": {
          "description": "Sets the buffering mode for the given file. \nSee: <a href=\"http://www.lua.org/manual/5.2/manual.html#pdf-file:setvbuf\">http://www.lua.org/manual/5.2/manual.html#pdf-file:setvbuf</a>",
          "param": {
            "1": "mode",
            "2": "size",
            "size": "The size of the buffer. Applicable only if mode = \"full\".",
            "mode": "The mode to use for buffering (one of \"no\", \"full\" or \"line\")."
          }
        },
        "read": {
          "ret": "All read values.",
          "returntypes": [
            "any..."
          ],
          "usage": "local Line, Byte, Rest = File:read( \"*l\", 1, \"*a\" )",
          "description": "Reads the given file using the arguments.",
          "param": {
            "1": "...",
            "...": "Reading arguments. '*n' reads a number, '*a' reads the entire file, \n'*l' reads a line without the new line character, '*L' reads a line with the new line character \nand a number reads that many bytes."
          }
        },
        "write": {
          "ret": "The file, allowing for chained calls.",
          "returntypes": [
            "File"
          ],
          "description": "Writes every passed in value to the given file.",
          "param": {
            "1": "...",
            "...": "String or number values to write to the given file."
          }
        },
        "close": {
          "description": "Closes the file. You cannot perform any further operations on the file once it is closed."
        },
        "flush": {
          "description": "Writes all buffered data to the file and saves it."
        },
        "seek": {
          "ret": "The new file cursor position.",
          "returntypes": [
            "number"
          ],
          "description": "Moves the file cursor position for reading from. \nIf no arguments are provided, it returns the current position. \nSee: <a href=\"http://www.lua.org/manual/5.2/manual.html#pdf-file:seek\">http://www.lua.org/manual/5.2/manual.html#pdf-file:seek</a>",
          "param": {
            "1": "whence",
            "2": "offset",
            "offset": "If whence is provided, the offset from that given position to seek to.",
            "whence": "The position in the file to seek from (one of \"set\", \"cur\" or \"end\")."
          }
        },
        "lines": {
          "ret": "Iterator.",
          "returntypes": [
            "function"
          ],
          "usage": "--Iterate over all lines. \nfor Line in File:lines() do \n\tprint( Line ) \nend \n--Iterate over every byte. \nfor Letter in File:lines( 1 ) do \n\tprint( Letter ) \nend",
          "description": "Returns an iterator over the file's contents, starting from the current position. \nPass in read arguments to have them returned in the iteration.",
          "param": {
            "1": "...",
            "...": "Reading arguments to use. Defaults to \"*l\"."
          }
        }
      }
    },
    "Panel": {
      "description": "Panel \nNote that most methods are from the panel object itself, so you'll need to look up GLua's documentation on panels to find them.",
      "externaldocs": "https://wiki.facepunch.com/gmod/Panel",
      "client": true,
      "methods": {
        "1": "isValid",
        "2": "replaceMethod",
        "replaceMethod": {
          "deprecated": "Use standard Lua assignment/method declarations, e.g. function Panel:DoClick() end.",
          "client": true,
          "description": "Replaces the given method with your function.",
          "param": {
            "1": "name",
            "2": "replacementFunc",
            "replacementFunc": "The function that should replace this method.",
            "name": "The name of the method to replace."
          }
        },
        "isValid": {
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the given panel is valid. Just a proxy to Panel:IsValid(), you could call that instead."
        }
      }
    },
    "Weapon": {
      "supertype": "Entity",
      "description": "Weapon",
      "methods": {
        "1": "clip1",
        "2": "clip2",
        "3": "getActivity",
        "4": "getHoldType",
        "5": "getMaxClip1",
        "6": "getMaxClip2",
        "7": "getPrimaryAmmoType",
        "8": "getPrintName",
        "9": "getSecondaryAmmoType",
        "10": "getSlot",
        "11": "getSlotPos",
        "12": "isCarriedByLocalPlayer",
        "13": "isScripted",
        "14": "isWeaponVisible",
        "getSlot": {
          "ret": "The weapon's slot.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the slot the weapon lives in."
        },
        "getSlotPos": {
          "ret": "The weapon's slot position.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the weapon's slot position."
        },
        "getMaxClip2": {
          "ret": "The maximum amount of ammo the weapon's secondary clip can hold.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the weapon's maximum secondary ammo size."
        },
        "getPrintName": {
          "ret": "The weapon's \"nice\" name.",
          "returntypes": [
            "string"
          ],
          "client": true,
          "description": "Returns a \"nice\" name for the weapon."
        },
        "clip2": {
          "ret": "The amount of ammo in the weapon's secondary clip.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the weapon's secondary ammo capacity."
        },
        "isCarriedByLocalPlayer": {
          "ret": "True if the weapon is being carried by the local client player.",
          "returntypes": [
            "boolean"
          ],
          "client": true,
          "description": "Returns whether the weapon is being carried by the local player."
        },
        "getActivity": {
          "ret": "ACT_ enum.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the current animation the weapon is playing."
        },
        "clip1": {
          "ret": "The amount of ammo in the weapon's primary clip.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the weapon's primary ammo capacity."
        },
        "getSecondaryAmmoType": {
          "ret": "The weapon's secondary ammo type, either a number or a string.",
          "returntypes": [
            [
              "number",
              "string"
            ]
          ],
          "description": "Returns the weapon's secondary ammo type."
        },
        "isScripted": {
          "ret": "True if it's a SWEP, false otherwise.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the weapon is a SWEP (scripted weapon)."
        },
        "getPrimaryAmmoType": {
          "ret": "The weapon's primary ammo type, either a number or a string.",
          "returntypes": [
            [
              "number",
              "string"
            ]
          ],
          "description": "Returns the weapon's primary ammo type."
        },
        "getHoldType": {
          "ret": "Hold type.",
          "returntypes": [
            "string"
          ],
          "description": "Returns the weapon's hold type."
        },
        "getMaxClip1": {
          "ret": "The maximum amount of ammo the weapon's primary clip can hold.",
          "returntypes": [
            "number"
          ],
          "description": "Returns the weapon's maximum primary ammo size."
        },
        "isWeaponVisible": {
          "ret": "True if the weapon does not have the nodraw flag.",
          "returntypes": [
            "boolean"
          ],
          "description": "Returns true if the weapon is visible."
        }
      }
    }
  },
  "directives": {
    "1": "autoupdate",
    "2": "class",
    "3": "dependency",
    "4": "highres",
    "5": "include",
    "6": "includedir",
    "7": "includesv",
    "8": "mainfile",
    "9": "model",
    "10": "name",
    "11": "precache",
    "12": "require",
    "13": "requirecl",
    "14": "requiresv",
    "15": "shared",
    "16": "updater",
    "17": "widescreen",
    "mainfile": {
      "description": "Marks the script as only runnable as the main file. \nAny instance attempting to load with this script as an include rather than the main script will error before running.",
      "usage": "--@mainfile \n-- This can only be executing if the file is the mainfile. \nassert( _MAINFILE == starfall.getMainFileName() )"
    },
    "highres": {
      "description": "Sets whether the screen should be high resolution. \nHigh resolution screens are 1024 x 1024, while normal resolution screens are 512 x 512."
    },
    "class": {
      "description": "Sets what type of entity is allowed to run this script. \nAttempting to spawn the script on an entity that is not in the list will result in an error message. \nValid classes are: processor, screen, hud, emitter. \nIn addition, if the value is set to \"none\", the script will be blocked from spawning with any type. This can be useful for library files.",
      "usage": "--@class screen, hud",
      "param": {
        "1": "Classes",
        "Classes": "A list of comma separated classes to allow to run this script."
      }
    },
    "autoupdate": {
      "description": "Marks the entity to automatically update its files. \nIf --@updater is set, the newest version in the shared area will be used both after spawning normally and from the duplicator if it is available (with read access). \nOtherwise, the newest version stored in the owner's local files will be used."
    },
    "widescreen": {
      "description": "Sets whether the screen should be widescreen. \nWidescreen screens are 1024 x 512, while normal resolution screens are 512 x 512."
    },
    "requirecl": {
      "description": "Mark a file to be included in the upload and then required on the client only.",
      "usage": "--@requirecl lib/someLibrary.txt \nif CLIENT then \n-- Your file is already required and ready to use here. \nend",
      "param": {
        "1": "path",
        "path": "Path to the file."
      }
    },
    "require": {
      "description": "Mark a file to be included in the upload and then required on both the server and the client.",
      "usage": "--@require lib/someLibrary.txt \n-- Your file is already required and ready to use here.",
      "param": {
        "1": "path",
        "path": "Path to the file."
      }
    },
    "include": {
      "description": "Mark a file to be included in the upload. \nThis is required to use the file in require() and dofile()",
      "usage": "--@include lib/someLibrary.txt \n \nrequire( \"lib/someLibrary.txt\" ) \n-- CODE",
      "param": {
        "1": "path",
        "path": "Path to the file."
      }
    },
    "includedir": {
      "description": "Mark a folder to be included in the upload. This is not recursive.",
      "usage": "--@includedir lib \n \nrequire( \"lib/someLibrary.txt\" ) \nrequire( \"lib/someOtherLibrary.txt\" ) \n-- CODE",
      "param": {
        "1": "path",
        "path": "Path to the folder."
      }
    },
    "includesv": {
      "description": "Mark a file to be included in the upload, but not sent to clients for download. Use this for files that will only be used on the server.",
      "usage": "--@includesv lib/someLibrary.txt \nif SERVER then \n\trequire( \"lib/someLibrary.txt\" ) \nend \n-- CODE",
      "param": {
        "1": "path",
        "path": "Path to the file."
      }
    },
    "precache": {
      "description": "Precaches a sound or model file. \nThis ensures that playing the sound or creating a prop with the model does not use a large amount of CPU time.",
      "usage": "--@precache vo/k_lab/kl_fiddlesticks.wav,vo/k_lab/kl_dearme.wav",
      "param": {
        "1": "Paths",
        "Paths": "A comma-separated list of file paths (.wav, .ogg, .mp3, .mdl) to precache."
      }
    },
    "name": {
      "description": "Set the name of the script. \nThis will become the name of the tab and will show on the overlay of the processor",
      "usage": "--@name Awesome script \n-- CODE",
      "param": {
        "1": "name",
        "name": "Name of the script."
      }
    },
    "model": {
      "description": "Sets the model of a processor entity only.",
      "usage": "--@model models/props_borealis/bluebarrel001.mdl",
      "param": {
        "1": "path",
        "path": "Path of the model to use."
      }
    },
    "shared": {
      "description": "For screens, HUDs and emitters, make the script run on the server alongside the client. \nYou can use \"if SERVER then\" and \"if CLIENT then\" to determine if the script is currently being run on the server or the client, respectively.",
      "usage": "--@shared \n \nif SERVER then \n\t-- Do important calculations \n\t-- Send net message \nelse \n\t-- Display result of important calculations \nend"
    },
    "requiresv": {
      "description": "Mark a file to be included in the upload and then required on the server only. This file will not be sent to clients.",
      "usage": "--@requiresv lib/someLibrary.txt \nif SERVER then \n-- Your file is already required and ready to use here. \nend",
      "param": {
        "1": "path",
        "path": "Path to the file."
      }
    },
    "updater": {
      "description": "Sets the Steam ID of the shared area folder to check for updates against. \nThis allows users of your script to right click the file in the editor and choose \"Update\". \nThey will then download the latest version of this file and all included files from your shared folder.",
      "usage": "--@updater STEAM_0:0:123456",
      "param": {
        "1": "SteamID",
        "SteamID": "The SteamID of the player responsible for updating this script."
      }
    },
    "dependency": {
      "description": "Add a dependency on a shared file. \nThe file will be pulled in from the shared area belonging to the specified Steam ID, or your own if no Steam ID is given. \nNote that if you do not have permission to read the file, you'll get an error.",
      "usage": "--@dependency lib/myServerLibrary.txt sv \n--@dependency STEAM_0:0:1234 lib/theirUsefulLib.txt sh \n--@dependency coolstuff/requiredlater.txt \n \n-- lib/myServerLibrary.txt is loaded on the server \n-- lib/theirUsefulLib.txt is loaded shared from STEAM_0:0:1234's shared folder. \n-- coolstuff/requiredlater.txt is included but not loaded yet. \nif SERVER then \n\trequire( \"coolstuff/requiredlater.txt\" ) \nend",
      "param": {
        "1": "steamID",
        "2": "path",
        "3": "realm",
        "steamID": "Steam ID whose shared folder the file should be pulled from.",
        "path": "The path to the file you want to include.",
        "realm": "Optional realm to auto-require the file in. One of sv, sh or cl for server, shared and client respectively."
      }
    }
  }
}